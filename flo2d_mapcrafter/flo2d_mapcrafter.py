# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FLO2DMapCrafter
                                 A QGIS plugin
 This plugin creates maps from FLO-2D output files.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-09-21
        git sha              : $Format:%H$
        copyright            : (C) 2023 by FLO-2D
        email                : contact@flo-2d.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QColor
from qgis.PyQt import QtWidgets
from PyQt5.QtWidgets import QMessageBox, QApplication, QCheckBox, QTableWidgetItem, QHeaderView
from PyQt5.QtXml import QDomDocument
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QHeaderView
from qgis._core import (
    QgsCoordinateReferenceSystem,
    QgsRasterBandStats,
    QgsColorRampShader,
    QgsRasterShader,
    QgsSingleBandPseudoColorRenderer,
    QgsProject,
    QgsVectorLayer,
    QgsPrintLayout,
    QgsReadWriteContext,
    QgsMessageLog, QgsProcessingUtils, Qgis,
)
from qgis._gui import QgsProjectionSelectionDialog
from .mapping.flood import FloodMaps
from .mapping.hazard import HazardMaps
from .mapping.mudflow import MudflowMaps
from .mapping.scripts import set_icon
from .mapping.sd_results_viewer import SDResultsViewer
from .mapping.sediment import SedimentMaps
from .mapping.storm_drain import StormDrainPlots
from .mapping.twophase import TwophaseMaps
from .resources import *
from .flo2d_mapcrafter_dialog import FLO2DMapCrafterDialog
import re
import os
import os.path
import processing
import time
from datetime import datetime
from typing import List, Tuple
from qgis.core import QgsProject
from .simple_swmm_parser import SimpleSWMMModel


class FLO2DMapCrafter:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.units_switch = None
        self.iface = iface
        self.dlg = FLO2DMapCrafterDialog()
        self._prime_sim_summary_table()
        self.actions = []
        self.menu = self.tr("&FLO-2D MapCrafter ")

        self._swmm_model = None  # Cache for parsed SWMM model.

        # Project Summary: Wire summary items to update whenever the export folder changes
        fw = getattr(self.dlg, "flo2d_out_folder", None) or getattr(self.dlg, "flo2dExportFolder", None)
        if fw:
            try:
                fw.fileChanged.connect(lambda *_: self._update_summary_fields())
            except Exception:
                pass
        self._update_summary_fields()
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value("locale/userLocale")[0:2]
        locale_path = os.path.join(
            self.plugin_dir, "i18n", "FLO2DMapCrafter_{}.qm".format(locale)
        )

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr("&FLO-2D MapCrafter ")

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        # Adjust CRS
        self.crs = QgsCoordinateReferenceSystem(QgsProject.instance().crs().authid())
        self.dlg.crsselector.crsChanged.connect(self.set_crs)

        # Select export folder
        self.dlg.flo2d_out_folder.fileChanged.connect(self.check_files)

        # Run Button
        self.dlg.runButton.clicked.connect(self.run_map_creator)

        # Cancel Button
        self.dlg.cancelButton.clicked.connect(self.closeDialog)

        # Export project Summary Button
        self.dlg.sumExportRptBtn.clicked.connect(self._export_summary_to_rpt)

        # Check all available maps
        self.dlg.check_cw_cb.stateChanged.connect(self.check_cw)
        self.dlg.check_mf_cb.stateChanged.connect(self.check_mf)
        self.dlg.check_tp_cb.stateChanged.connect(self.check_tp)
        self.dlg.check_sd_cb.stateChanged.connect(self.check_sd)
        self.dlg.check_hm_cb.stateChanged.connect(self.check_hm)
        self.dlg.check_storm_drain_chbox.stateChanged.connect(self.check_storm_drain)

        self.dlg.runButton_2.clicked.connect(self.run_open_layout)

        self.dlg.tab0.setEnabled(False)
        self.dlg.tab1.setEnabled(False)
        self.dlg.tab2.setEnabled(False)
        self.dlg.tab3.setEnabled(False)
        self.dlg.tab4.setEnabled(False)
        self.dlg.tab5.setEnabled(False)
        self.dlg.tab.setEnabled(False)
        self.dlg.tabs.currentChanged.connect(self.clear_chboxes)

        self.dlg.cg_cw_btn.clicked.connect(self.collapse_all_groups)
        self.dlg.eg_cw_btn.clicked.connect(self.expand_all_groups)
        self.dlg.cg_sd_btn.clicked.connect(self.collapse_all_groups)
        self.dlg.eg_sd_btn.clicked.connect(self.expand_all_groups)
        self.dlg.cg_md_btn.clicked.connect(self.collapse_all_groups)
        self.dlg.eg_md_btn.clicked.connect(self.expand_all_groups)
        self.dlg.cg_tp_btn.clicked.connect(self.collapse_all_groups)
        self.dlg.eg_tp_btn.clicked.connect(self.expand_all_groups)
        self.dlg.cg_hm_btn.clicked.connect(self.collapse_all_groups)
        self.dlg.eg_hm_btn.clicked.connect(self.expand_all_groups)
        self.dlg.cg_storm_drain_btn.clicked.connect(self.collapse_all_groups)
        self.dlg.eg_storm_drain_btn.clicked.connect(self.expand_all_groups)

        set_icon(self.dlg.cg_cw_btn, "collapse_groups.svg")
        set_icon(self.dlg.eg_cw_btn, "expand_groups.svg")
        set_icon(self.dlg.cg_sd_btn, "collapse_groups.svg")
        set_icon(self.dlg.eg_sd_btn, "expand_groups.svg")
        set_icon(self.dlg.cg_md_btn, "collapse_groups.svg")
        set_icon(self.dlg.eg_md_btn, "expand_groups.svg")
        set_icon(self.dlg.cg_tp_btn, "collapse_groups.svg")
        set_icon(self.dlg.eg_tp_btn, "expand_groups.svg")
        set_icon(self.dlg.cg_hm_btn, "collapse_groups.svg")
        set_icon(self.dlg.eg_hm_btn, "expand_groups.svg")
        set_icon(self.dlg.cg_storm_drain_btn, "collapse_groups.svg")
        set_icon(self.dlg.eg_storm_drain_btn, "expand_groups.svg")

        # Storm Drain subplots
        self.dlg.see_nodes_results_btn.clicked.connect(self.see_nodes_results)

    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate("FLO2DMapCrafter", message)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None,
    ):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        self.actions.append(action)

        if not hasattr(self, "menu") or not self.menu:
            self.menu = self.tr("&FLO-2D MapCrafter ")
        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ":/plugins/flo2d_mapcrafter/icon.png"
        self.add_action(
            icon_path,
            text=self.tr("FLO-2D MapCrafter"),
            callback=self.open,
            parent=self.iface.mainWindow(),
        )

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(self.tr("&FLO-2D MapCrafter "), action)
            self.iface.removeToolBarIcon(action)

    def set_crs(self):
        """
        Function to set the CRS
        """
        self.crs = self.dlg.crsselector.crs()
        self.projected_crs()
        QgsProject.instance().setCrs(self.crs)

    def projected_crs(self):
        """
        Function to allow only projected crs
        """
        is_geographic = self.crs.isGeographic()
        while is_geographic:
            dialog = QgsProjectionSelectionDialog()
            if dialog.exec_():
                self.crs = dialog.crs()
                is_geographic = self.crs.isGeographic()
                if is_geographic:
                    self.iface.messageBar().pushMessage("MapCrafter requires a projected Coordinate Reference System!",
                                                        level=Qgis.Info, duration=5)
                else:
                    self.dlg.crsselector.setCrs(self.crs)
                    QgsProject.instance().setCrs(self.crs)
                    return True
            else:
                return False
        return True

    # Opening the dialog
    def open(self):
        """Shows the dialog"""

        # Adjust the CRS
        self.crs = QgsCoordinateReferenceSystem(QgsProject.instance().crs().authid())

        is_projected = self.projected_crs()
        if is_projected:
            self.dlg.crsselector.setCrs(self.crs)

            # Set the grid layer as extent, if it exists
            layer = QgsProject.instance().mapLayersByName("Grid")
            if layer:
                # Add the layer to the QgsMapLayerComboBox
                self.dlg.layer_extent_cb.setLayer(layer[0])

            self.dlg.show()
            self.dlg.activateWindow()

    def closeDialog(self):
        """Closes the Dialog"""

        checkboxes = self.dlg.tabs.findChildren(QtWidgets.QCheckBox)
        for checkBox in checkboxes:
            checkBox.setChecked(False)

        self.collapse_all_groups()

        self.dlg.close()

    # ---------------------------------------------------------------------------------------------------------#
    #                                            Helpers                                                      #
    # ---------------------------------------------------------------------------------------------------------#

    # -----------------------------------#
    # Project Summary: Units Helper     #
    # -----------------------------------#
    def _export_folder(self):
        """Return the path from the FLO-2D Export Folder widget."""
        w = getattr(self.dlg, "flo2d_out_folder", None) or getattr(self.dlg, "flo2dExportFolder", None)
        return w.filePath() if w else ""

    def _find_cont_dat(self, base):
        """Look for CONT.DAT in base or its parent (common folder layouts)."""
        if not base:
            return None
        for folder in (base, os.path.dirname(base)):
            for name in ("CONT.DAT", "cont.dat"):
                p = os.path.join(folder, name)
                if os.path.isfile(p):
                    return p
        return None

    def _detect_units_from_cont(self, cont_path: str):
        """Return 'English (Imperial)' or 'SI (Metric)' from CONT.DAT line 1, token 4."""
        import os
        if not cont_path or not os.path.isfile(cont_path):
            return None
        try:
            with open(cont_path, "r", errors="ignore") as f:
                first_line = f.readline()
            if not first_line:
                return None

            # Split on any whitespace; token #4 (index 3) is the units flag.
            toks = first_line.split()
            if len(toks) >= 4 and toks[3].isdigit():
                return "SI (Metric)" if toks[3] == "1" else "English (Imperial)"
            return None
        except Exception:
            return None

    # -----------------------------------#
    # Project Summary: Build No. Helper #
    # -----------------------------------#

    def _find_summary_out(self, base):
        """Return path to SUMMARY.OUT by checking base and its parent."""
        if not base:
            return None
        for folder in (base, os.path.dirname(base)):
            for name in ("SUMMARY.OUT", "summary.out"):
                p = os.path.join(folder, name)
                if os.path.isfile(p):
                    return p
        return None

    def _detect_build_from_summary(self, summary_path):
        """
        Parse 'Build No.' from SUMMARY.OUT.
        Finds the line containing 'SUMMARY.OUT FILE' and then reads the *next* line,
        which should contain 'Build No.' text. Returns the build number string.
        """
        if not summary_path or not os.path.isfile(summary_path):
            return None
        try:
            with open(summary_path, "r", errors="ignore") as f:
                lines = f.readlines()
        except Exception:
            return None

        for idx, line in enumerate(lines):
            if "SUMMARY.OUT FILE" in line.upper():
                if idx + 1 < len(lines):
                    next_line = lines[idx + 1]
                    # Extract build number from that line
                    m = re.search(r"Build\s*No\.?\s*([0-9][0-9\.\-]+)", next_line, flags=re.IGNORECASE)
                    if m:
                        return m.group(1).strip()
                    # Fallback: return whole line stripped if regex fails
                    return next_line.strip()
        return None

    # ------------------------------------#
    # Project Summary: Grid (Cell) Size  #
    # ------------------------------------#
    def _detect_cellsize_from_summary(self, summary_path: str):
        """
        Return grid cell size with units (e.g., '30.0 FT' or '10.0 M')
        by reading the 'GRID ELEMENT SIZE:' line in SUMMARY.OUT.
        """
        if not summary_path or not os.path.isfile(summary_path):
            return None
        try:
            with open(summary_path, "r", errors="ignore") as f:
                for line in f:
                    if "GRID ELEMENT SIZE" in line.upper():
                        # Accept variations in spacing/case, capture number + unit token
                        m = re.search(
                            r"GRID\s+ELEMENT\s+SIZE\s*:\s*([0-9]+(?:\.[0-9]+)?)\s*([A-Za-z]+)",
                            line, flags=re.IGNORECASE
                        )
                        if m:
                            val = m.group(1)
                            unit = m.group(2).upper()  # FT, M, etc.
                            return f"{val} {unit}"
                        # Fallback: whole line trimmed if regex fails
                        return line.strip()
        except Exception:
            return None
        return None

    # ------------------------------------#
    # Project Summary: No. of Elements   #
    # ------------------------------------#

    def _detect_elements_from_summary(self, summary_path: str):
        """
        Return the total number of grid elements as a string (e.g., '54,306')
        by parsing the 'TOTAL NUMBER OF GRID ELEMENTS:' line in SUMMARY.OUT.
        """
        if not summary_path or not os.path.isfile(summary_path):
            return None
        try:
            pat = re.compile(r"TOTAL\s+NUMBER\s+OF\s+GRID\s+ELEMENTS\s*:\s*([0-9,]+)",
                             flags=re.IGNORECASE)
            with open(summary_path, "r", errors="ignore") as f:
                for line in f:
                    m = pat.search(line)
                    if m:
                        digits = m.group(1).replace(",", "").strip()
                        if digits.isdigit():
                            return f"{int(digits):,}"
                        return m.group(1).strip()
        except Exception:
            return None
        return None

    # ------------------------------------#
    # Project Summary: Simulation Type   #
    # ------------------------------------#

    def _detect_simulation_type(self, base_dir: str, cont_path: str, summary_path: str):
        """
        Infer simulation type(s) from files & keywords.
        Returns a string like: 'Flood + Storm Drain + Sediment'
        """
        labels = []

        # Quick file existence check in base and parent
        def find_any(fnames):
            for folder in (base_dir, os.path.dirname(base_dir) if base_dir else None):
                if not folder:
                    continue
                for nm in fnames:
                    p = os.path.join(folder, nm)
                    if os.path.isfile(p):
                        return True
            return False

        # Load small snippets of CONT.DAT and SUMMARY.OUT for keyword scanning
        contU = ""
        if cont_path and os.path.isfile(cont_path):
            try:
                with open(cont_path, "r", errors="ignore") as f:
                    contU = f.read(20000).upper()  # header is enough
            except Exception:
                pass

        sumU = ""
        if summary_path and os.path.isfile(summary_path):
            try:
                with open(summary_path, "r", errors="ignore") as f:
                    sumU = f.read(50000).upper()
            except Exception:
                pass

        # Base module: Flood (always present for grid hydraulics)
        labels.append("Flood")

        # Storm Drain signals
        storm_files = ("SWMM.INP", "HYDRAULICS.DAT", "STORM.DAT")
        storm_kw = ("SWMM", "STORM DRAIN", "STORM_DRAIN", "HYDRAULIC STRUCTURE")
        if find_any(storm_files) or any(k in contU or k in sumU for k in storm_kw):
            labels.append("Storm Drain")

        # Mudflow / Debris-flow / Two-phase signals
        mud_files = ("MUDFLOW.DAT", "TWO_PHASE.DAT", "TAILINGS.DAT", "TAILINGS_STACK_DEPTH.DAT")
        mud_kw = ("MUD", "MUDFLOW", "DEBRIS", "TWO-PHASE", "TWO PHASE", "TAILINGS")
        if find_any(mud_files) or any(k in contU or k in sumU for k in mud_kw):
            labels.append("Mudflow")

        # Sediment signals
        sed_files = ("SEDIMENT.DAT", "SED.DAT")
        sed_kw = ("SEDIMENT", "BEDLOAD", "SUSPENDED LOAD")
        if find_any(sed_files) or any(k in contU or k in sumU for k in sed_kw):
            labels.append("Sediment")

        # De-duplicate & format
        seen, final = set(), []
        for lab in labels:
            if lab not in seen:
                final.append(lab);
                seen.add(lab)

        return " + ".join(final) if final else "Unknown"

    # ----------------------------------------#
    # Project Summary: Simulation Date       #
    # ----------------------------------------#

    def _detect_simulation_date_from_summary(self, summary_path: str):
        """
        Find the line like:
            THIS OUTPUT FILE WAS TERMINATED ON:   5/15/2025  AT:   8:14:28
        and return a readable timestamp, e.g. '2025-05-15 08:14:28'.
        If parsing fails, return the raw 'date [time]' substring.
        """
        if not summary_path or not os.path.isfile(summary_path):
            return None

        pat = re.compile(
            r"TERMINATED\s+ON:\s*([0-9]{1,2}[/-][0-9]{1,2}[/-][0-9]{2,4})"
            r"(?:\s+AT:\s*([0-9]{1,2}:[0-9]{2}:[0-9]{2}(?:\s*[APMapm]{2})?))?",
            re.IGNORECASE
        )
        try:
            with open(summary_path, "r", errors="ignore") as f:
                for line in f:
                    if "TERMINATED ON" not in line.upper():
                        continue
                    m = pat.search(line)
                    if not m:
                        continue
                    date_str = m.group(1).strip()
                    time_str = (m.group(2) or "").strip()

                    # Try to normalize to ISO-ish 'YYYY-MM-DD HH:MM:SS'
                    # Accept MM/DD/YYYY or MM-DD-YYYY (or 2-digit year)
                    for fmt in ("%m/%d/%Y", "%m/%d/%y", "%m-%d-%Y", "%m-%d-%y"):
                        try:
                            d = datetime.strptime(date_str, fmt)
                            break
                        except ValueError:
                            d = None
                    if d is None:
                        # fallback: return raw substring
                        return (date_str + (" " + time_str if time_str else "")).strip()

                    if time_str:
                        # Try 24h first, then 12h with AM/PM
                        for tfmt in ("%H:%M:%S", "%I:%M:%S %p", "%I:%M:%S%p"):
                            try:
                                t = datetime.strptime(time_str.upper().replace(".", ""), tfmt)
                                # merge date+time
                                merged = d.replace(hour=t.hour, minute=t.minute, second=t.second)
                                return merged.strftime("%Y-%m-%d %H:%M:%S")
                            except ValueError:
                                pass
                        # if time unparseable, return date + raw time
                        return f"{d.strftime('%Y-%m-%d')} {time_str}"
                    else:
                        return d.strftime("%Y-%m-%d")
        except Exception:
            return None
        return None

    # --------------------------------------------#
    # Project Summary: Coordinate System (EPSG)  #
    # --------------------------------------------#

    def _detect_epsg_code(self):
        """
        Return the project's EPSG code (e.g., 'EPSG:32637').
        """
        try:
            crs = QgsProject.instance().crs()
            if crs.isValid():
                return crs.authid()
        except Exception:
            pass
        return None

    # ------------------------------------------------------------------#
    # Project Summary: Extra Info: Simulation Summary|STATUS|ACTION    #
    # ------------------------------------------------------------------#
    def _extract_simulation_summary_table(self, summary_path: str) -> List[Tuple[str, str, str]]:
        """
        Parse the three columns under the SIMULATION SUMMARY section of SUMMARY.OUT.
        Returns a list of (summary, status, action).
        Robust to variable spacing; stops at blank line or next section.
        """
        rows: List[Tuple[str, str, str]] = []
        if not summary_path:
            return rows

        try:
            with open(summary_path, "r", errors="ignore") as f:
                lines = f.readlines()
        except Exception:
            return rows

        # 1) Find the section start: the line that has 'SIMULATION SUMMARY'
        start = None
        for i, line in enumerate(lines):
            if re.search(r"\bSIMULATION SUMMARY\b", line, re.IGNORECASE):
                start = i
                break
        if start is None:
            return rows

        # 2) Skip blanks to find the header row that contains both STATUS and ACTION
        i = start + 1
        while i < len(lines) and not lines[i].strip():
            i += 1

        # header row (best effort)
        if i < len(lines) and re.search(r"\bSTATUS\b", lines[i], re.IGNORECASE) and re.search(r"\bACTION\b", lines[i],
                                                                                              re.IGNORECASE):
            i += 1  # move to first data row

        # 3) Read data rows until a blank spacer or another header-like line
        while i < len(lines):
            raw = lines[i].rstrip("\n")
            i += 1

            if not raw.strip():
                break  # end of table block

            # stop if we hit another obvious header/section
            if re.search(r"\b(UNITS|BUILD|GRID SIZE|NO\.? OF ELEMENTS|SIMULATION TYPE|COORD\.?|FLO-2D|SUMMARY)\b", raw,
                         re.IGNORECASE):
                break

            # split into up to 3 columns by 2+ spaces
            parts = re.split(r"\s{2,}", raw.strip(), maxsplit=2)
            if len(parts) == 3:
                s, status, action = parts
            elif len(parts) == 2:
                s, status = parts
                action = ""
            else:
                # single token: treat as continuation of previous row's action if present
                if rows:
                    prev = list(rows[-1])
                    prev[2] = (prev[2] + " " + parts[0]).strip()
                    rows[-1] = tuple(prev)
                continue

            rows.append((s, status, action))
        return rows

        # Prime the Simulation Summary table headers before data exists

    def _prime_sim_summary_table(self):
        tbl = getattr(self.dlg, "sumSimSummaryTable", None)
        if not tbl:
            return
        tbl.setColumnCount(3)
        tbl.setHorizontalHeaderLabels(["Simulation Summary", "Status", "Action"])
        h = tbl.horizontalHeader()
        # Make headers readable before there are any rows
        h.setSectionResizeMode(0, QHeaderView.Stretch)
        h.setSectionResizeMode(1, QHeaderView.ResizeToContents)
        h.setSectionResizeMode(2, QHeaderView.Stretch)
        tbl.verticalHeader().setVisible(False)
        tbl.setAlternatingRowColors(False)

    def _update_summary_fields(self):
        base = self._export_folder()

        # If no export folder chosen yet reset all summary fields to "—"
        if not base or not os.path.isdir(base):
            self.dlg.sumUnits.setText("—")
            self.dlg.sumBuild.setText("—")
            self.dlg.sumCellSize.setText("—")
            self.dlg.sumNElems.setText("—")
            self.dlg.sumSimType.setText("—")
            self.dlg.sumSimDate.setText("—")
            self.dlg.sumEPSG.setText("—")

            if hasattr(self.dlg, "sumSimSummaryTable") and self.dlg.sumSimSummaryTable:
                self._prime_sim_summary_table()
            return

        cont_path = self._find_cont_dat(base)
        summary_path = self._find_summary_out(base)

        # Fill values
        units = self._detect_units_from_cont(cont_path)
        build = self._detect_build_from_summary(summary_path)
        cell = self._detect_cellsize_from_summary(summary_path)
        nelems = self._detect_elements_from_summary(summary_path)
        simtype = self._detect_simulation_type(base, cont_path, summary_path)
        simdate = self._detect_simulation_date_from_summary(summary_path)
        epsg = self._detect_epsg_code()

        self.dlg.sumUnits.setText(units or "—")
        self.dlg.sumBuild.setText(build or "—")
        self.dlg.sumCellSize.setText(cell or "—")
        self.dlg.sumNElems.setText(nelems or "—")
        self.dlg.sumSimType.setText(simtype or "—")
        self.dlg.sumSimDate.setText(simdate or "—")
        self.dlg.sumEPSG.setText(epsg or "—")

        # Simulation Summary (3-column table)
        sim_table_rows = self._extract_simulation_summary_table(summary_path)

        if hasattr(self.dlg, "sumSimSummaryTable") and self.dlg.sumSimSummaryTable:
            tbl = self.dlg.sumSimSummaryTable
            tbl.clear()
            tbl.setRowCount(len(sim_table_rows))
            tbl.setColumnCount(3)
            tbl.setHorizontalHeaderLabels(["Simulation Summary", "Status", "Action"])

            for r, (summary_txt, status_txt, action_txt) in enumerate(sim_table_rows):
                tbl.setItem(r, 0, QTableWidgetItem(summary_txt))
                tbl.setItem(r, 1, QTableWidgetItem(status_txt))
                tbl.setItem(r, 2, QTableWidgetItem(action_txt))

            header = tbl.horizontalHeader()
            header.setSectionResizeMode(0, QHeaderView.ResizeToContents)
            header.setSectionResizeMode(1, QHeaderView.ResizeToContents)
            header.setSectionResizeMode(2, QHeaderView.Stretch)

            tbl.verticalHeader().setVisible(False)
            tbl.setAlternatingRowColors(True)
            tbl.setEditTriggers(tbl.NoEditTriggers)
            tbl.setAlternatingRowColors(False)

    def _export_summary_to_rpt(self):
        """
        Export the 'Summary' tab contents to report_proj.rpt.
        If a file with the same name already exists, ask the user to Overwrite or Cancel.
        """
        try:
            # Ensure UI is up to date
            self._update_summary_fields()

            # Prefer MapCrafter Output Folder; fallback to export folder
            out_dir = ""
            try:
                out_dir = self.dlg.mapper_out_folder.filePath().strip()
            except Exception:
                pass
            if not out_dir:
                out_dir = (self._export_folder() or "").strip()

            if not out_dir:
                self.iface.messageBar().pushMessage(
                    "Please set an output folder (MapCrafter or FLO-2D Export Folder) before exporting.",
                    level=Qgis.Warning, duration=5
                )
                return

            os.makedirs(out_dir, exist_ok=True)
            out_path = os.path.join(out_dir, "report_proj.rpt")

            # If file exists, ask user whether to overwrite or cancel
            if os.path.exists(out_path):
                mb = QMessageBox(self.dlg)
                mb.setIcon(QMessageBox.Warning)
                mb.setWindowTitle("File already exists")
                mb.setText(
                    f"A file named 'report_proj.rpt' already exists in:\n\n{out_dir}\n\n"
                    "Do you want to overwrite it?"
                )
                overwrite_btn = mb.addButton("Overwrite", QMessageBox.YesRole)
                cancel_btn = mb.addButton("Cancel", QMessageBox.RejectRole)
                mb.setDefaultButton(cancel_btn)
                mb.exec_()

                if mb.clickedButton() is not overwrite_btn:
                    # User cancelled the export
                    self.iface.messageBar().pushMessage("Export cancelled.", level=Qgis.Info, duration=4)
                    return

            # Gather fields from the Summary tab
            g = self.dlg

            def txt(w):
                try:
                    return (w.text() or "").strip()
                except Exception:
                    return ""

            project_id = txt(g.project_id)
            units = txt(g.sumUnits)
            build_no = txt(g.sumBuild)
            cell_size = txt(g.sumCellSize)
            n_elems = txt(g.sumNElems)
            sim_type = txt(g.sumSimType)
            sim_date = txt(g.sumSimDate)
            epsg_code = txt(g.sumEPSG)

            # Simulation Summary table rows
            rows = []
            tbl = getattr(g, "sumSimSummaryTable", None)
            if tbl:
                for r in range(tbl.rowCount()):
                    c0 = tbl.item(r, 0).text().strip() if tbl.item(r, 0) else ""
                    c1 = tbl.item(r, 1).text().strip() if tbl.item(r, 1) else ""
                    c2 = tbl.item(r, 2).text().strip() if tbl.item(r, 2) else ""
                    rows.append((c0, c1, c2))

            hdr = ("Simulation Summary", "Status", "Action")
            w0 = max(len(hdr[0]), *(len(r[0]) for r in rows)) if rows else len(hdr[0])
            w1 = max(len(hdr[1]), *(len(r[1]) for r in rows)) if rows else len(hdr[1])

            def line3(a, b, c):
                return f"{a.ljust(w0)}  |  {b.ljust(w1)}  |  {c}"

            now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            header = [
                "FLO-2D MapCrafter — Project Summary",
                f"Generated: {now}",
                ""
            ]
            meta = [
                "Project metadata:",
                f"  Units:               {units or '—'}",
                f"  Build No.:           {build_no or '—'}",
                f"  Grid Size:           {cell_size or '—'}",
                f"  No. of Elements:     {n_elems or '—'}",
                f"  Simulation Type:     {sim_type or '—'}",
                f"  Simulation Date:     {sim_date or '—'}",
                f"  Coord. Ref. System:  {epsg_code or '—'}",
                ""
            ]
            table = [line3(*hdr)]
            table.append("-" * (w0 + 2 + 2 + w1 + 2 + 2 + 40))
            if rows:
                for r in rows:
                    table.append(line3(*r))
            else:
                table.append("(no simulation summary rows parsed)")

            content = "\n".join(header + meta + ["Simulation Summary Table:", ""] + table) + "\n"

            # Write file
            with open(out_path, "w", encoding="utf-8") as f:
                f.write(content)

            QMessageBox.information(self.dlg, "Summary exported",
                                    f"Summary written to:\n{out_path}")

        except Exception as e:
            self.iface.messageBar().pushMessage(
                f"Export failed: {e}", level=Qgis.Critical, duration=6
            )

    def _load_swmm_model(self, inp_file, rpt_file):
        """Load and cache SWMM model. Re-parse only if .rpt file changed."""
        rpt_mtime = os.path.getmtime(rpt_file) if os.path.isfile(rpt_file) else None
        model = getattr(self, "_swmm_model", None)
        if (model is None) or (getattr(model, "_rpt_mtime", None) != rpt_mtime):
            from .simple_swmm_parser import SimpleSWMMModel
            self._swmm_model = SimpleSWMMModel(inp_file, rpt_file)
            self._swmm_model._rpt_mtime = rpt_mtime
        return self._swmm_model

    def check_files(self):
        """Function to check the type of files present on the simulation"""

        # check if simulation was run
        files_in_directory = os.listdir(self.dlg.flo2d_out_folder.filePath())

        # In future version, calculate the Cell size from the DEPTH.OUT file
        if "DEPTH.OUT" in files_in_directory and "CONT.DAT" in files_in_directory:
            self.dlg.runButton.setEnabled(True)
            self.dlg.label_2.setEnabled(True)
            self.dlg.mapper_out_folder.setEnabled(True)
            self.dlg.tab4.setEnabled(True)
        else:
            msg_box = QMessageBox()
            msg_box.setIcon(QMessageBox.Warning)
            msg_box.setWindowTitle("Warning")
            msg_box.setText("No CONT.DAT and *.OUT files were found in this directory!")
            msg_box.exec_()
            return

        output_directory = self.dlg.flo2d_out_folder.filePath()

        with open(output_directory + r"\CONT.DAT", "r") as file:
            lines = file.readlines()
            elements = lines[2].split()
            self.units_switch = lines[0].split()[3]
            mud_switch = elements[3]
            sed_switch = elements[4]
            file.close()

        max_vector_scale = self.dlg.max_vector_scale_sb.value()
        min_vector_scale = self.dlg.min_vector_scale_sb.value()
        vector_scale = [max_vector_scale, min_vector_scale]

        # Flood simulation
        if mud_switch == "0" and sed_switch == "0":
            self.dlg.tab0.setEnabled(False)
            self.dlg.tab1.setEnabled(True)
            self.dlg.tab2.setEnabled(False)
            self.dlg.tab3.setEnabled(False)
            self.dlg.tabs.setCurrentIndex(0)

            flood_maps = FloodMaps(self.units_switch, vector_scale)
            flood_files_dict = flood_maps.check_flood_files(output_directory)

            flood_rbs = {
                r"TOPO.DAT": self.dlg.ge_cw_cb,
                r"DEPTH.OUT": self.dlg.md_cw_cb,
                r"VELFP.OUT": self.dlg.mv_cw_cb,
                r"VELDIREC.OUT": self.dlg.mvv_cw_cb,
                r"MAXWSELEV.OUT": self.dlg.mwse_cw_cb,
                r"FINALDEP.OUT": self.dlg.fd_cw_cb,
                r"FINALVEL.OUT": self.dlg.fv_cw_cb,
                r"FINALDIR.OUT": self.dlg.fvv_cw_cb,
                r"VEL_X_DEPTH.OUT": self.dlg.dv_cw_cb,
                r"TIMEONEFT.OUT": self.dlg.t1ft_cw_cb,
                r"TIMETWOFT.OUT": self.dlg.t2ft_cw_cb,
                r"TIMETOPEAK.OUT": self.dlg.tmax_cw_cb,
                r"DEPCH.OUT": self.dlg.cd_cw_cb,
                r"VELOC.OUT": self.dlg.cv_cw_cb,
                r"VELCHFINAL.OUT": self.dlg.fcv_cw_cb,
                r"DEPCHFINAL.OUT": self.dlg.fcd_cw_cb,
                r"LEVEEDEFIC.OUT": self.dlg.ld_cw_cb,
                r"SPECENERGY.OUT": self.dlg.se_cw_cb,
                r"STATICPRESS.OUT": self.dlg.sp_cw_cb,
                r"IMPACT.OUT": self.dlg.if_cw_cb,
            }

            for key, value in flood_files_dict.items():
                if value:
                    flood_rbs[key].setEnabled(True)
                else:
                    flood_rbs[key].setEnabled(False)

            # Enable the virtual derived checkbox (needs both inputs)
            vxd_ok = flood_files_dict.get(r"VEL_X_DEPTH.OUT", False)
            v_ok = flood_files_dict.get(r"VELFP.OUT", False)
            self.dlg.v2xd_cw_cb.setEnabled(vxd_ok and v_ok)

        # Sediment simulation
        if mud_switch == "0" and sed_switch == "1":
            self.dlg.tab1.setEnabled(False)
            self.dlg.tab2.setEnabled(False)
            self.dlg.tab0.setEnabled(True)
            self.dlg.tab3.setEnabled(False)
            self.dlg.tabs.setCurrentIndex(1)

            sediment_maps = SedimentMaps(self.units_switch, vector_scale)
            sediment_files_dict = sediment_maps.check_sediment_files(output_directory)

            sediment_rbs = {
                r"TOPO.DAT": self.dlg.ge_sd_cb,
                r"DEPTH.OUT": self.dlg.md_sd_cb,
                r"VELFP.OUT": self.dlg.mv_sd_cb,
                r"VELDIREC.OUT": self.dlg.mvv_sd_cb,
                r"MAXWSELEV.OUT": self.dlg.mwse_sd_cb,
                r"FINALDEP.OUT": self.dlg.fd_sd_cb,
                r"FINALVEL.OUT": self.dlg.fv_sd_cb,
                r"FINALDIR.OUT": self.dlg.fvv_sd_cb,
                r"VEL_X_DEPTH.OUT": self.dlg.dv_sd_cb,
                r"TIMEONEFT.OUT": self.dlg.t1ft_sd_cb,
                r"TIMETWOFT.OUT": self.dlg.t2ft_sd_cb,
                r"TIMETOPEAK.OUT": self.dlg.tmax_sd_cb,
                r"DEPCH.OUT": self.dlg.cd_sd_cb,
                r"VELOC.OUT": self.dlg.cv_sd_cb,
                r"VELCHFINAL.OUT": self.dlg.fcv_sd_cb,
                r"DEPCHFINAL.OUT": self.dlg.fcd_sd_cb,
                r"LEVEEDEFIC.OUT": self.dlg.ld_sd_cb,
                r"SPECENERGY.OUT": self.dlg.se_sd_cb,
                r"STATICPRESS.OUT": self.dlg.sp_sd_cb,
                r"SEDFP.OUT": [
                    self.dlg.mdep_sd_cb,
                    self.dlg.msco_sd_cb,
                    self.dlg.fbd_sd_cb
                ],
                r"IMPACT.OUT": self.dlg.if_sd_cb,
            }

            for key, value in sediment_files_dict.items():
                if value:
                    if isinstance(sediment_rbs[key], list):
                        for cb in sediment_rbs[key]:
                            cb.setEnabled(True)
                    else:
                        sediment_rbs[key].setEnabled(True)
                else:
                    if isinstance(sediment_rbs[key], list):
                        for cb in sediment_rbs[key]:
                            cb.setEnabled(False)
                    else:
                        sediment_rbs[key].setEnabled(False)

        # Mudflow simulation
        if mud_switch == "1" and sed_switch == "0":
            self.dlg.tab0.setEnabled(False)
            self.dlg.tab1.setEnabled(False)
            self.dlg.tab2.setEnabled(True)
            self.dlg.tab3.setEnabled(False)
            self.dlg.tabs.setCurrentIndex(2)

            mudflow_maps = MudflowMaps(self.units_switch, vector_scale)
            mudflow_files_dict = mudflow_maps.check_mudflow_files(output_directory)

            mudflow_rbs = {
                r"TOPO.DAT": self.dlg.ge_mf_cb,
                r"DEPTH.OUT": self.dlg.md_mf_cb,
                r"VELFP.OUT": self.dlg.mv_mf_cb,
                r"VELDIREC.OUT": self.dlg.mvv_mf_cb,
                r"MAXWSELEV.OUT": self.dlg.mwse_mf_cb,
                r"FINALDEP.OUT": self.dlg.fd_mf_cb,
                r"FINALVEL.OUT": self.dlg.fv_mf_cb,
                r"FINALDIR.OUT": self.dlg.fvv_mf_cb,
                r"VEL_X_DEPTH.OUT": self.dlg.dv_mf_cb,
                r"TIMEONEFT.OUT": self.dlg.t1ft_mf_cb,
                r"TIMETWOFT.OUT": self.dlg.t2ft_mf_cb,
                r"TIMETOPEAK.OUT": self.dlg.tmax_mf_cb,
                r"DEPCH.OUT": self.dlg.cd_mf_cb,
                r"VELOC.OUT": self.dlg.cv_mf_cb,
                r"VELCHFINAL.OUT": self.dlg.fcv_mf_cb,
                r"DEPCHFINAL.OUT": self.dlg.fcd_mf_cb,
                r"LEVEEDEFIC.OUT": self.dlg.ld_mf_cb,
                r"SPECENERGY.OUT": self.dlg.se_mf_cb,
                r"STATICPRESS.OUT": self.dlg.sp_mf_cb,
                r"CVFPMAX.OUT": self.dlg.ms_mf_cb,
                r"FINALCVFP.OUT": self.dlg.fs_mf_cb,
                r"IMPACT.OUT": self.dlg.if_mf_cb,
            }

            for key, value in mudflow_files_dict.items():
                if value:
                    mudflow_rbs[key].setEnabled(True)
                else:
                    mudflow_rbs[key].setEnabled(False)

        # Two-phase simulation
        if mud_switch == "2" and sed_switch == "0":
            self.dlg.tab0.setEnabled(False)
            self.dlg.tab1.setEnabled(False)
            self.dlg.tab2.setEnabled(False)
            self.dlg.tab3.setEnabled(True)
            self.dlg.tabs.setCurrentIndex(3)

            twophase_maps = TwophaseMaps(self.units_switch, vector_scale)
            twophase_files_dict = twophase_maps.check_twophase_files(output_directory)

            twophase_rbs = {
                r"TOPO.DAT": self.dlg.ge_tp_cb,
                r"DEPTH.OUT": self.dlg.mfd_tp_cb,
                r"DEPFPMAX_MUD.OUT": self.dlg.mmd_tp_cb,
                r"DEPTHMAX_2PHASE_COMBINED.OUT": self.dlg.cmd_tp_cb,
                r"VELFP.OUT": self.dlg.mfv_tp_cb,
                r"VELFP_MUD.OUT": self.dlg.mmv_tp_cb,
                r"VELDIREC.OUT": self.dlg.mfvv_tp_cb,
                r"VELDIREC_MUD.OUT": self.dlg.mmvv_tp_cb,
                r"CVFPMAX.OUT": self.dlg.mfsc_tp_cb,
                r"CVFPMAX_MUD.OUT": self.dlg.mmsc_tp_cb,
                # r"FINALCVFP.OUT": self.dlg.ffsc_tp_cb,
                r"FINALCVFP_MUD.OUT": self.dlg.fmsc_tp_cb,
                # r"MAXWSELEV.OUT": self.dlg.mwse_mf_cb,
                r"FINALDEP.OUT": self.dlg.ffd_tp_cb,
                r"FINALDEP_MUD.OUT": self.dlg.fmd_tp_cb,
                r"FINALDIR.OUT": self.dlg.ffvv_tp_cb,
                r"FINALDIR_MUD.OUT": self.dlg.fmvv_tp_cb,
                r"FINALDEP_COMBO.OUT": self.dlg.fcd_tp_cb,
                r"FINALVEL.OUT": self.dlg.ffv_tp_cb,
                r"FINALVEL_MUD.OUT": self.dlg.fmv_tp_cb,
                r"VEL_X_DEPTH.OUT": self.dlg.dv_tp_cb,
                r"TIMEONEFT.OUT": self.dlg.t1ft_tp_cb,
                r"TIMETWOFT.OUT": self.dlg.t2ft_tp_cb,
                r"TIMETOPEAK.OUT": self.dlg.tmax_tp_cb,
                r"DEPCH.OUT": self.dlg.mchd_tp_cb,
                r"VELOC.OUT": self.dlg.mchv_tp_cb,
                r"VELCHFINAL.OUT": self.dlg.fchv_tp_cb,
                r"DEPCHFINAL.OUT": self.dlg.fchd_tp_cb,
                r"LEVEEDEFIC.OUT": self.dlg.ld_tp_cb,
                r"SPECENERGY.OUT": self.dlg.se_tp_cb,
                r"STATICPRESS.OUT": self.dlg.sp_tp_cb,
                r"IMPACT.OUT": self.dlg.if_tp_cb,
                r"SEDFP.OUT": [
                    self.dlg.ms_tp_cb,
                    self.dlg.md_tp_cb,
                    self.dlg.fdb_tp_cb
                ],
            }

            for key, value in twophase_files_dict.items():
                if value:
                    if isinstance(twophase_rbs[key], list):
                        for cb in twophase_rbs[key]:
                            cb.setEnabled(True)
                    else:
                        twophase_rbs[key].setEnabled(True)
                else:
                    if isinstance(twophase_rbs[key], list):
                        for cb in twophase_rbs[key]:
                            cb.setEnabled(False)
                    else:
                        twophase_rbs[key].setEnabled(False)

        # Hazard Maps
        self.dlg.tab5.setEnabled(True)
        hazard_maps = HazardMaps(self.units_switch)
        hazard_maps_dict = hazard_maps.check_hazard_files(output_directory)

        hazard_rbs = {
            "ARR": self.dlg.fh_australian_cb,
            "Austrian": self.dlg.fh_austrian_cb,
            "FLO-2D": self.dlg.flo_hm_cb,
            "Swiss": [self.dlg.fi_swiss_cb, self.dlg.di_swiss_cb],
            "UK": self.dlg.fh_uk_cb,
            "USBR": [
                self.dlg.usbrh_hm_cb,
                self.dlg.usbrm_hm_cb,
                self.dlg.usbrv_hm_cb,
                self.dlg.usbra_hm_cb,
                self.dlg.usbrc_hm_cb,
            ],
            "FEMA": self.dlg.fema_hm_cb,
        }

        for key, value in hazard_maps_dict.items():
            if value:
                if isinstance(hazard_rbs[key], list):
                    for cb in hazard_rbs[key]:
                        cb.setEnabled(True)
                else:
                    hazard_rbs[key].setEnabled(True)
            else:
                if isinstance(hazard_rbs[key], list):
                    for cb in hazard_rbs[key]:
                        cb.setEnabled(False)
                else:
                    hazard_rbs[key].setEnabled(False)

        # Add MapCrafter to the output folder
        map_output_dir = output_directory + r"\MapCrafter"
        self.dlg.mapper_out_folder.setFilePath(map_output_dir)
        if not os.path.exists(map_output_dir):
            os.makedirs(map_output_dir)

        inp_present = False
        rpt_present = False

        for file_name in files_in_directory:
            if file_name.lower() == 'swmm.inp':
                inp_present = True
            elif file_name.lower() == 'swmm.rpt':
                rpt_present = True

        if inp_present and rpt_present:
            self.dlg.tab.setEnabled(True)

            # Try lowercase first, fallback to uppercase
            inp_file = os.path.join(output_directory, "swmm.inp")
            rpt_file = os.path.join(output_directory, "swmm.rpt")

            if not os.path.isfile(inp_file):
                inp_file = os.path.join(output_directory, "SWMM.INP")
            if not os.path.isfile(rpt_file):
                rpt_file = os.path.join(output_directory, "SWMM.RPT")

            mymodel = self._load_swmm_model(inp_file, rpt_file)

            nodes_list = mymodel.nodes
            links_list = mymodel.links
            node_results = mymodel.node_results
            link_results = mymodel.link_results

            # self.dlg.start_cbo.addItems(sorted(nodes_list))
            # self.dlg.end_cbo.addItems(sorted(nodes_list))

            self.dlg.hours_lbl.setText("hrs")
            if self.units_switch == "0":
                self.dlg.max_flood_lbl.setText("cfs")
                self.dlg.total_flood_lbl.setText("mgd")
                self.dlg.max_pond_lbl.setText("ft")
            else:
                self.dlg.max_flood_lbl.setText("cms")
                self.dlg.total_flood_lbl.setText("mld")
                self.dlg.max_pond_lbl.setText("m")

            # Check if there are results available in output folders
            sd_results_dir = os.path.join(map_output_dir, "StormDrain")
            if os.path.isdir(sd_results_dir):
                nodes_dir = os.path.join(sd_results_dir, "Nodes")
                links_dir = os.path.join(sd_results_dir, "Links")

                # Use scandir (much faster than os.walk) and check only top-level entries
                def has_files(path):
                    return os.path.isdir(path) and any(entry.is_file() for entry in os.scandir(path))

                if has_files(nodes_dir) or has_files(links_dir):
                    self.dlg.see_nodes_results_btn.setEnabled(True)

            self._update_summary_fields()

    def run_map_creator(self):
        """
        Run method that performs all the real work
        """

        try:

            QApplication.setOverrideCursor(Qt.WaitCursor)

            # input & output directories
            flo2d_results_dir = self.dlg.flo2d_out_folder.filePath()
            map_output_dir = self.dlg.mapper_out_folder.filePath()
            # Ensure MapCrafter output folder exists
            if not map_output_dir:
                map_output_dir = os.path.join(flo2d_results_dir, "MapCrafter")
            os.makedirs(map_output_dir, exist_ok=True)
            self.crs = self.dlg.crsselector.crs()
            project_id = self.dlg.project_id.text()
            max_vector_scale = self.dlg.max_vector_scale_sb.value()
            min_vector_scale = self.dlg.min_vector_scale_sb.value()
            vector_scale = [max_vector_scale, min_vector_scale]

            if map_output_dir == "":
                map_output_dir = QgsProcessingUtils.tempFolder()

            if not self.check_checkboxes():
                return

            with open(flo2d_results_dir + r"\CONT.DAT", "r") as file:
                lines = file.readlines()
                self.units_switch = lines[0].split()[3]
                elements = lines[2].split()
                mud_switch = elements[3]
                sed_switch = elements[4]
                file.close()

            """
            GROUPS CREATION
            """

            root = QgsProject.instance().layerTreeRoot()

            mapping_group_name = "FLO-2D MapCrafter"
            if root.findGroup(mapping_group_name):
                mapping_group = root.findGroup(mapping_group_name)
            else:
                mapping_group = root.insertGroup(0, mapping_group_name)

            """        
            FLOOD MAPS        
            """

            if mud_switch == "0" and sed_switch == "0":
                flood_rbs = {
                    r"TOPO.DAT": self.dlg.ge_cw_cb.isChecked(),
                    r"DEPTH.OUT": self.dlg.md_cw_cb.isChecked(),
                    r"VELFP.OUT": self.dlg.mv_cw_cb.isChecked(),
                    r"VELDIREC.OUT": self.dlg.mvv_cw_cb.isChecked(),
                    r"MAXWSELEV.OUT": self.dlg.mwse_cw_cb.isChecked(),
                    r"FINALDEP.OUT": self.dlg.fd_cw_cb.isChecked(),
                    r"FINALVEL.OUT": self.dlg.fv_cw_cb.isChecked(),
                    r"FINALDIR.OUT": self.dlg.fvv_cw_cb.isChecked(),
                    r"VEL_X_DEPTH.OUT": self.dlg.dv_cw_cb.isChecked(),
                    r"TIMEONEFT.OUT": self.dlg.t1ft_cw_cb.isChecked(),
                    r"TIMETWOFT.OUT": self.dlg.t2ft_cw_cb.isChecked(),
                    r"TIMETOPEAK.OUT": self.dlg.tmax_cw_cb.isChecked(),
                    r"DEPCH.OUT": self.dlg.cd_cw_cb.isChecked(),
                    r"VELOC.OUT": self.dlg.cv_cw_cb.isChecked(),
                    r"VELCHFINAL.OUT": self.dlg.fcv_cw_cb.isChecked(),
                    r"DEPCHFINAL.OUT": self.dlg.fcd_cw_cb.isChecked(),
                    r"LEVEEDEFIC.OUT": self.dlg.ld_cw_cb.isChecked(),
                    r"SPECENERGY.OUT": self.dlg.se_cw_cb.isChecked(),
                    r"STATICPRESS.OUT": self.dlg.sp_cw_cb.isChecked(),
                    r"IMPACT.OUT": self.dlg.if_cw_cb.isChecked(),
                    "VEL_SQ_X_DEPTH": self.dlg.v2xd_cw_cb.isChecked(),
                }

                flood_maps = FloodMaps(self.units_switch, vector_scale)
                flood_maps.create_maps(
                    flood_rbs, flo2d_results_dir, map_output_dir, mapping_group, self.crs, project_id
                )

            """
            SEDIMENT MAPS
            """

            if mud_switch == "0" and sed_switch == "1":
                sediment_rbs = {
                    r"TOPO.DAT": self.dlg.ge_sd_cb.isChecked(),
                    r"DEPTH.OUT": self.dlg.md_sd_cb.isChecked(),
                    r"VELFP.OUT": self.dlg.mv_sd_cb.isChecked(),
                    r"VELDIREC.OUT": self.dlg.mvv_sd_cb.isChecked(),
                    r"MAXWSELEV.OUT": self.dlg.mwse_sd_cb.isChecked(),
                    r"FINALDEP.OUT": self.dlg.fd_sd_cb.isChecked(),
                    r"FINALVEL.OUT": self.dlg.fv_sd_cb.isChecked(),
                    r"FINALDIR.OUT": self.dlg.fvv_sd_cb.isChecked(),
                    r"VEL_X_DEPTH.OUT": self.dlg.dv_sd_cb.isChecked(),
                    r"TIMEONEFT.OUT": self.dlg.t1ft_sd_cb.isChecked(),
                    r"TIMETWOFT.OUT": self.dlg.t2ft_sd_cb.isChecked(),
                    r"TIMETOPEAK.OUT": self.dlg.tmax_sd_cb.isChecked(),
                    r"DEPCH.OUT": self.dlg.cd_sd_cb.isChecked(),
                    r"VELOC.OUT": self.dlg.cv_sd_cb.isChecked(),
                    r"VELCHFINAL.OUT": self.dlg.fcv_sd_cb.isChecked(),
                    r"DEPCHFINAL.OUT": self.dlg.fcd_sd_cb.isChecked(),
                    r"LEVEEDEFIC.OUT": self.dlg.ld_sd_cb.isChecked(),
                    r"SPECENERGY.OUT": self.dlg.se_sd_cb.isChecked(),
                    r"STATICPRESS.OUT": self.dlg.sp_sd_cb.isChecked(),
                    r"SEDFP.OUT": [
                        self.dlg.mdep_sd_cb.isChecked(),
                        self.dlg.msco_sd_cb.isChecked(),
                        self.dlg.fbd_sd_cb.isChecked()
                    ],
                    r"IMPACT.OUT": self.dlg.if_sd_cb.isChecked(),
                }

                sediment_maps = SedimentMaps(self.units_switch, vector_scale)
                sediment_maps.create_maps(
                    sediment_rbs, flo2d_results_dir, map_output_dir, mapping_group, self.crs, project_id
                )

            """"
            MUDFLOW MAPS
            """

            if mud_switch == "1" and sed_switch == "0":
                mudflow_rbs = {
                    r"TOPO.DAT": self.dlg.ge_mf_cb.isChecked(),
                    r"DEPTH.OUT": self.dlg.md_mf_cb.isChecked(),
                    r"VELFP.OUT": self.dlg.mv_mf_cb.isChecked(),
                    r"VELDIREC.OUT": self.dlg.mvv_mf_cb.isChecked(),
                    r"MAXWSELEV.OUT": self.dlg.mwse_mf_cb.isChecked(),
                    r"FINALDEP.OUT": self.dlg.fd_mf_cb.isChecked(),
                    r"FINALVEL.OUT": self.dlg.fv_mf_cb.isChecked(),
                    r"FINALDIR.OUT": self.dlg.fvv_mf_cb.isChecked(),
                    r"VEL_X_DEPTH.OUT": self.dlg.dv_mf_cb.isChecked(),
                    r"TIMEONEFT.OUT": self.dlg.t1ft_mf_cb.isChecked(),
                    r"TIMETWOFT.OUT": self.dlg.t2ft_mf_cb.isChecked(),
                    r"TIMETOPEAK.OUT": self.dlg.tmax_mf_cb.isChecked(),
                    r"DEPCH.OUT": self.dlg.cd_mf_cb.isChecked(),
                    r"VELOC.OUT": self.dlg.cv_mf_cb.isChecked(),
                    r"VELCHFINAL.OUT": self.dlg.fcv_mf_cb.isChecked(),
                    r"DEPCHFINAL.OUT": self.dlg.fcd_mf_cb.isChecked(),
                    r"LEVEEDEFIC.OUT": self.dlg.ld_mf_cb.isChecked(),
                    r"SPECENERGY.OUT": self.dlg.se_mf_cb.isChecked(),
                    r"STATICPRESS.OUT": self.dlg.sp_mf_cb.isChecked(),
                    r"CVFPMAX.OUT": self.dlg.ms_mf_cb.isChecked(),
                    r"FINALCVFP.OUT": self.dlg.fs_mf_cb.isChecked(),
                    r"IMPACT.OUT": self.dlg.if_mf_cb.isChecked(),
                }

                mudflow_maps = MudflowMaps(self.units_switch, vector_scale)
                mudflow_maps.create_maps(
                    mudflow_rbs, flo2d_results_dir, map_output_dir, mapping_group, self.crs, project_id
                )

            """"
            TWO-PHASE MAPS
            """

            if mud_switch == "2" and sed_switch == "0":
                twophase_rbs = {
                    r"TOPO.DAT": self.dlg.ge_tp_cb.isChecked(),
                    r"DEPTH.OUT": self.dlg.mfd_tp_cb.isChecked(),
                    r"DEPFPMAX_MUD.OUT": self.dlg.mmd_tp_cb.isChecked(),
                    r"DEPTHMAX_2PHASE_COMBINED.OUT": self.dlg.cmd_tp_cb.isChecked(),
                    r"VELFP.OUT": self.dlg.mfv_tp_cb.isChecked(),
                    r"VELFP_MUD.OUT": self.dlg.mmv_tp_cb.isChecked(),
                    r"VELDIREC.OUT": self.dlg.mfvv_tp_cb.isChecked(),
                    r"VELDIREC_MUD.OUT": self.dlg.mmvv_tp_cb.isChecked(),
                    r"CVFPMAX.OUT": self.dlg.mfsc_tp_cb.isChecked(),
                    r"CVFPMAX_MUD.OUT": self.dlg.mmsc_tp_cb.isChecked(),
                    # r"FINALCVFP.OUT": self.dlg.ffsc_tp_cb,
                    r"FINALCVFP_MUD.OUT": self.dlg.fmsc_tp_cb.isChecked(),
                    # r"MAXWSELEV.OUT": self.dlg.mwse_mf_cb,
                    r"FINALDEP.OUT": self.dlg.ffd_tp_cb.isChecked(),
                    r"FINALDEP_MUD.OUT": self.dlg.fmd_tp_cb.isChecked(),
                    r"FINALDIR.OUT": self.dlg.ffvv_tp_cb.isChecked(),
                    r"FINALDIR_MUD.OUT": self.dlg.fmvv_tp_cb.isChecked(),
                    r"FINALDEP_COMBO.OUT": self.dlg.fcd_tp_cb.isChecked(),
                    r"FINALVEL.OUT": self.dlg.ffv_tp_cb.isChecked(),
                    r"FINALVEL_MUD.OUT": self.dlg.fmv_tp_cb.isChecked(),
                    r"VEL_X_DEPTH.OUT": self.dlg.dv_tp_cb.isChecked(),
                    r"TIMEONEFT.OUT": self.dlg.t1ft_tp_cb.isChecked(),
                    r"TIMETWOFT.OUT": self.dlg.t2ft_tp_cb.isChecked(),
                    r"TIMETOPEAK.OUT": self.dlg.tmax_tp_cb.isChecked(),
                    r"DEPCH.OUT": self.dlg.mchd_tp_cb.isChecked(),
                    r"VELOC.OUT": self.dlg.mchv_tp_cb.isChecked(),
                    r"VELCHFINAL.OUT": self.dlg.fchv_tp_cb.isChecked(),
                    r"DEPCHFINAL.OUT": self.dlg.fchd_tp_cb.isChecked(),
                    r"LEVEEDEFIC.OUT": self.dlg.ld_tp_cb.isChecked(),
                    r"SPECENERGY.OUT": self.dlg.se_tp_cb.isChecked(),
                    r"STATICPRESS.OUT": self.dlg.sp_tp_cb.isChecked(),
                    r"IMPACT.OUT": self.dlg.if_tp_cb.isChecked(),
                    r"SEDFP.OUT": [
                        self.dlg.ms_tp_cb.isChecked(),
                        self.dlg.md_tp_cb.isChecked(),
                        self.dlg.fdb_tp_cb.isChecked()
                    ],
                }

                twophase_maps = TwophaseMaps(self.units_switch, vector_scale)
                twophase_maps.create_maps(
                    twophase_rbs, flo2d_results_dir, map_output_dir, mapping_group, self.crs, project_id
                )

            """
            HYDRODYNAMIC RISK MAPS
            """

            hazard_rbs = {
                "ARR": self.dlg.fh_australian_cb.isChecked(),
                "Austrian": self.dlg.fh_austrian_cb.isChecked(),
                "Swiss": [
                    self.dlg.fi_swiss_cb.isChecked(),
                    self.dlg.di_swiss_cb.isChecked()
                ],
                "UK": self.dlg.fh_uk_cb.isChecked(),
                "USBR": [
                    self.dlg.usbrh_hm_cb.isChecked(),
                    self.dlg.usbrm_hm_cb.isChecked(),
                    self.dlg.usbrv_hm_cb.isChecked(),
                    self.dlg.usbra_hm_cb.isChecked(),
                    self.dlg.usbrc_hm_cb.isChecked(),
                ],
                "FEMA": self.dlg.fema_hm_cb.isChecked()
            }

            at_least_one_checked = any(
                value if not isinstance(value, list) else any(value) for value in hazard_rbs.values())

            if at_least_one_checked:
                hazard_maps = HazardMaps(self.units_switch)
                hazard_maps.create_maps(
                    hazard_rbs, flo2d_results_dir, map_output_dir, mapping_group, self.crs, project_id
                )

            # remove empty groups
            groups = mapping_group.findGroups()
            for group in groups:
                subgroups = group.findGroups()
                for subgroup in subgroups:
                    all_subgrup_layers = subgroup.findLayers()
                    if len(all_subgrup_layers) == 0:
                        group.removeChildNode(subgroup)
                all_group_layers = group.findLayers()
                if len(all_group_layers) == 0:
                    mapping_group.removeChildNode(group)

            """
            STORM DRAIN PLOTS
            """

            storm_drain_rbs = {
                "Inflow": [self.dlg.inflow_chbox.isChecked()],
                "Flooding": [self.dlg.flooding_chbox.isChecked()],
                "Node Depth": [self.dlg.node_depth_chbox.isChecked()],
                "Head": [self.dlg.head_chbox.isChecked()],
                "Flow": [self.dlg.flow_chbox.isChecked()],
                "Velocity": [self.dlg.velocity_chbox.isChecked()],
                "Link Depth": [self.dlg.link_depth_chbox.isChecked()],
                "Percent Full": [self.dlg.percent_full_chbox.isChecked()],
                "Hours Flooded": [
                    self.dlg.hours_flooded_chbox.isChecked(),
                    self.dlg.hours_flooded_dsb.value()
                ],
                "Maximum Flooding": [
                    self.dlg.max_flood_chbox.isChecked(),
                    self.dlg.max_flood_dsb.value()
                ],
                "Total Flooding": [
                    self.dlg.total_flood_chbox.isChecked(),
                    self.dlg.total_flood_dsb.value()
                ],
                "Maximum Pond": [
                    self.dlg.max_pond_chbox.isChecked(),
                    self.dlg.max_pond_dsb.value()
                ],
                # "Profile": [
                #     self.dlg.plot_profile_chbox.isChecked(),
                #     self.dlg.start_cbo.currentText(),
                #     self.dlg.end_cbo.currentText()
                # ],
            }

            at_least_one_checked = any(
                value[0] if isinstance(value, list) and len(value) > 0 else value
                for value in storm_drain_rbs.values()
            )

            if at_least_one_checked:
                if project_id:
                    sd_output_dir = map_output_dir + rf"\StormDrain - {project_id}"
                else:
                    sd_output_dir = map_output_dir + rf"\StormDrain"
                if not os.path.exists(sd_output_dir):
                    os.makedirs(sd_output_dir)
                # Resolve swmm files
                inp_file = os.path.join(flo2d_results_dir, "swmm.inp")
                rpt_file = os.path.join(flo2d_results_dir, "swmm.rpt")
                if not os.path.isfile(inp_file): inp_file = os.path.join(flo2d_results_dir, "SWMM.INP")
                if not os.path.isfile(rpt_file): rpt_file = os.path.join(flo2d_results_dir, "SWMM.RPT")

                model = self._load_swmm_model(inp_file, rpt_file)

                # Give the cached model to StormDrainPlots so it never re-parses
                storm_drain_plots = StormDrainPlots(self.units_switch, self.iface, swmm_model=model)
                t0 = time.perf_counter()
                plots = storm_drain_plots.create_plots(storm_drain_rbs, flo2d_results_dir, sd_output_dir)
                if plots:
                    self.dlg.see_nodes_results_btn.setEnabled(True)
                t1 = time.perf_counter()
                storm_drain_plots.plot_graphics(storm_drain_rbs, flo2d_results_dir, sd_output_dir, self.crs.authid(),
                                                mapping_group)
                t2 = time.perf_counter()
                storm_drain_plots.storm_drain_profile(storm_drain_rbs, flo2d_results_dir, sd_output_dir, True)
                t3 = time.perf_counter()
                QgsMessageLog.logMessage(
                    f"SD timings: create_plots={t1 - t0:.2f}s, plot_graphics={t2 - t1:.2f}s, profile={t3 - t2:.2f}s",
                    'FLO-2D', Qgis.Info)

            QApplication.restoreOverrideCursor()
            msg_box = QMessageBox()
            msg_box.setIcon(QMessageBox.Information)
            msg_box.setWindowTitle("Mapping complete!")
            msg_box.setText("The selected maps were created!")
            msg_box.exec_()

        except Exception as e:
            QApplication.restoreOverrideCursor()
            self.iface.messageBar().pushMessage(
                "ERROR: Error while creating the maps! See log messages for more information.", level=Qgis.Critical,
                duration=5)
            QgsMessageLog.logMessage(str(e))

    def see_storm_drain_profile(self):
        """
        Function to show the storm drain profile
        """
        storm_drain_plots = StormDrainPlots(self.units_switch, self.iface)
        flo2d_results_dir = self.dlg.flo2d_out_folder.filePath()
        map_output_dir = self.dlg.mapper_out_folder.filePath()
        project_id = self.dlg.project_id.text()
        if project_id:
            sd_output_dir = map_output_dir + rf"\StormDrain - {project_id}"
        else:
            sd_output_dir = map_output_dir + rf"\StormDrain"
        if not os.path.exists(sd_output_dir):
            os.makedirs(sd_output_dir)
        # storm_drain_rbs = {
        #     "Profile": [
        #         True,
        #         self.dlg.start_cbo.currentText(),
        #         self.dlg.end_cbo.currentText()
        #     ],
        # }
        # storm_drain_plots.storm_drain_profile(storm_drain_rbs, flo2d_results_dir, sd_output_dir)

    def see_nodes_results(self):
        """
        Function to open the results viewer
        """
        flo2d_results_dir = self.dlg.output_dir_le.text()
        sd_output_dir = os.path.join(flo2d_results_dir, "Maps", "StormDrain")

        # Define possible file names (lowercase / uppercase)
        inp_file = os.path.join(flo2d_results_dir, "swmm.inp")
        rpt_file = os.path.join(flo2d_results_dir, "swmm.rpt")
        INP_file = os.path.join(flo2d_results_dir, "SWMM.INP")
        RPT_file = os.path.join(flo2d_results_dir, "swmm.RPT")

        # Prefer lowercase, fallback to uppercase
        if not os.path.isfile(inp_file):
            inp_file = INP_file
        if not os.path.isfile(rpt_file):
            rpt_file = RPT_file

        # Parse SWMM model with lightweight parser
        mymodel = self._load_swmm_model(inp_file, rpt_file)
        nodes_list = mymodel.nodes
        links_list = mymodel.links
        node_results = mymodel.node_results
        link_results = mymodel.link_results

        # Get FLO-2D grid names for matching results
        nname_grid = StormDrainPlots(self.units_switch, self.iface).get_nname_grid(flo2d_results_dir)

        # Launch the results viewer
        sd_results_viewer = SDResultsViewer(
            sd_output_dir,
            nodes_list,
            links_list,
            nname_grid,
            node_results=node_results,
            link_results=link_results
        )
        sd_results_viewer.exec_()

    def set_raster_style(self, layer, style):
        """Define the raster styles"""
        colDic = {
            "white": "#ffffff",
            "lightblue": "#9ecae1",
            "blue": "#4292c6",
            "darkblue": "#08306b",
            "lightgreen": "#a1d99b",
            "green": "#41ab5d",
            "darkgreen": "#006d2c",
            "black": "#000000",
            "grey": "#808080",
            "red": "#FF0000",
            "yellow": "#FFFF00",
            "risk_red": "#FF0000",
            "risk_orange": "#FFC000",
            "risk_lightgreen": "#92D050",
            "risk_green": "#006600",
            "risk_lightblue": "#BDD6EE",
            "risk_blue": "#0033CC",
            "mud_lightbrown": "#be4d24",
            "mud_brown": "#752c12",
            "mud_darkbrown": "#2c0c00",
        }

        provider = layer.dataProvider()
        extent = layer.extent()

        script_directory = os.path.dirname(os.path.realpath(__file__))
        style_directory = script_directory + r"/raster_styles"

        # Hydrodynamic Risk
        if style == 2:
            layer.loadNamedStyle(style_directory + r"/hydro_risk.qml")
        elif style == 3:
            layer.loadNamedStyle(style_directory + r"/time.qml")
        # Other styles
        else:
            stats = provider.bandStatistics(1, QgsRasterBandStats.All, extent, 0)
            if stats.minimumValue <= 0.001:
                min = 0.001
            else:
                min = stats.minimumValue

            max = stats.maximumValue
            range = max - min
            add = range / 2
            interval = min + add
            valueList = [min, interval, max]

            dep_lst = [
                QgsColorRampShader.ColorRampItem(
                    valueList[0], QColor(colDic["lightblue"])
                ),
                QgsColorRampShader.ColorRampItem(valueList[1], QColor(colDic["blue"])),
                QgsColorRampShader.ColorRampItem(
                    valueList[2], QColor(colDic["darkblue"])
                ),
            ]

            vel_lst = [
                QgsColorRampShader.ColorRampItem(
                    valueList[0], QColor(colDic["lightgreen"])
                ),
                QgsColorRampShader.ColorRampItem(valueList[1], QColor(colDic["green"])),
                QgsColorRampShader.ColorRampItem(
                    valueList[2], QColor(colDic["darkgreen"])
                ),
            ]

            time_lst = [
                QgsColorRampShader.ColorRampItem(valueList[0], QColor(colDic["green"])),
                QgsColorRampShader.ColorRampItem(
                    valueList[1], QColor(colDic["yellow"])
                ),
                QgsColorRampShader.ColorRampItem(valueList[2], QColor(colDic["red"])),
            ]

            q_lst = [
                QgsColorRampShader.ColorRampItem(valueList[0], QColor(colDic["white"])),
                QgsColorRampShader.ColorRampItem(
                    valueList[1], QColor(colDic["lightblue"])
                ),
                QgsColorRampShader.ColorRampItem(valueList[2], QColor(colDic["blue"])),
            ]

            mud_lst = [
                QgsColorRampShader.ColorRampItem(
                    valueList[0], QColor(colDic["mud_lightbrown"])
                ),
                QgsColorRampShader.ColorRampItem(
                    valueList[1], QColor(colDic["mud_brown"])
                ),
                QgsColorRampShader.ColorRampItem(
                    valueList[2], QColor(colDic["mud_darkbrown"])
                ),
            ]

            style_dict = {
                0: dep_lst,
                1: vel_lst,
                5: mud_lst,
                3: time_lst,
                4: q_lst,
            }

            myRasterShader = QgsRasterShader()
            myColorRamp = QgsColorRampShader(minimumValue=min, maximumValue=max)

            myColorRamp.setColorRampItemList(style_dict[style])
            myColorRamp.setColorRampType(QgsColorRampShader.Interpolated)
            myColorRamp.setClip(True)

            myRasterShader.setRasterShaderFunction(myColorRamp)

            myPseudoRenderer = QgsSingleBandPseudoColorRenderer(
                layer.dataProvider(), layer.type(), myRasterShader
            )

            layer.setRenderer(myPseudoRenderer)

        layer.triggerRepaint()

    def set_vector_style(self, layer, style):
        """Define the vector styles"""

        script_directory = os.path.dirname(os.path.realpath(__file__))
        style_directory = script_directory + r"/vector_styles"

        # Extent red
        if style == 0:
            layer.loadNamedStyle(style_directory + r"/extent.qml")

        # Extent blue
        if style == 1:
            layer.loadNamedStyle(style_directory + r"/fluid_extent.qml")

        # Extent brown
        if style == 2:
            layer.loadNamedStyle(style_directory + r"/mud_extent.qml")

    def remove_layer(self, layer_name):
        """Function to remove layer name based on name"""
        for layer in QgsProject.instance().mapLayers().values():
            if layer.name() == layer_name:
                QgsProject.instance().removeMapLayers([layer.id()])

    def get_extent(self, raster, flood_extent_vector, name):
        """Function to get the extent of a raster layer"""
        vectorized = processing.run(
            "gdal:polygonize",
            {
                "INPUT": raster,
                "BAND": 1,
                "FIELD": "DN",
                "EIGHT_CONNECTEDNESS": False,
                "EXTRA": "",
                "OUTPUT": "TEMPORARY_OUTPUT",
            },
        )["OUTPUT"]

        processing.run(
            "native:dissolve",
            {
                "INPUT": vectorized,
                "FIELD": [],
                "SEPARATE_DISJOINT": False,
                "OUTPUT": flood_extent_vector,
            },
        )
        extent = QgsVectorLayer(flood_extent_vector, name)

        return extent

    def check_checkboxes(self):
        """Function to check if at least one map checkbox was checked"""

        checkboxes = self.dlg.tabs.findChildren(QtWidgets.QCheckBox)

        none_checked = not any(checkbox.isChecked() for checkbox in checkboxes)

        if none_checked:
            msg_box = QMessageBox()
            msg_box.setIcon(QMessageBox.Warning)
            msg_box.setWindowTitle("Warning")
            msg_box.setText("Check at least one map option!")
            msg_box.exec_()
            return False
        else:
            return True

    def run_open_layout(self):
        """Function to open the selected layout"""

        map_title = self.dlg.map_title_le.text()
        map_description = self.dlg.map_description.toPlainText()
        layer_extent = self.dlg.layer_extent_cb.currentLayer()

        lm = QgsProject.instance().layoutManager()
        l = QgsPrintLayout(QgsProject.instance())
        l.initializeDefaults()

        script_directory = os.path.dirname(os.path.realpath(__file__))
        template_directory = script_directory + r"/layout_templates"
        template_source = ""
        if self.dlg.a4_land.isChecked():
            template_source = template_directory + r"/FLO-2D A4 Landscape.qpt"
            layout_name = self.layout_exists("FLO-2D A4 Landscape")

        if self.dlg.a4_port.isChecked():
            template_source = template_directory + r"/FLO-2D A4 Portrait.qpt"
            layout_name = self.layout_exists("FLO-2D A4 Portrait")

        if self.dlg.a3_land.isChecked():
            template_source = template_directory + r"/FLO-2D A3 Landscape.qpt"
            layout_name = self.layout_exists("FLO-2D A3 Landscape")

        if self.dlg.a3_port.isChecked():
            template_source = template_directory + r"/FLO-2D A3 Portrait.qpt"
            layout_name = self.layout_exists("FLO-2D A3 Portrait")

        if template_source == "":
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText("Please, select a layout.")
            msg.exec_()
            return

        # template_source = template_directory + r"/FLO-2D A4 Landscape.qpt"

        template_file = open(template_source, "r+", encoding="utf-8")
        template_content = template_file.read()
        template_file.close()
        document = QDomDocument()
        document.setContent(template_content)
        context = QgsReadWriteContext()
        l.loadFromTemplate(document, context)

        l.setName(layout_name)

        # canvas = self.iface.mapCanvas()
        for item in l.items():
            if item.type() == 65639:  # Map
                item.zoomToExtent(layer_extent.extent())
            if item.type() == 65641:  # Label
                item.setText(item.text().replace("{{title}}", map_title))
                item.setText(item.text().replace("{{description}}", map_description))

        # Add layout to layout manager
        l.refresh()
        lm.addLayout(l)

        # Open and show the layout in designer
        # try:
        self.iface.openLayoutDesigner(l)
        # except:
        #     msg = QMessageBox()
        #     msg.setIcon(QMessageBox.Warning)
        #     msg.setText(self.tr(
        #         f'Error trying to open the layout ({l.name()}) returned errors.'
        #             ))
        #     msg.exec_()

    def layout_exists(self, layout_name):
        """Check if a layout already exists and return a correct name"""
        lm = QgsProject.instance().layoutManager()
        layouts = []
        n_layouts = 0
        for l in lm.layouts():
            layouts.append(l.name())
        if layout_name in layouts:
            n_layouts = sum(layout_name in s for s in layouts)

        if n_layouts == 0:
            return layout_name
        else:
            return layout_name + f" ({n_layouts})"

    def check_cw(self):
        """
        Function to check all available flood maps
        """

        flood_rbs = [
            self.dlg.ge_cw_cb,
            self.dlg.md_cw_cb,
            self.dlg.mv_cw_cb,
            self.dlg.mwse_cw_cb,
            self.dlg.fd_cw_cb,
            self.dlg.fv_cw_cb,
            self.dlg.dv_cw_cb,
            self.dlg.t1ft_cw_cb,
            self.dlg.t2ft_cw_cb,
            self.dlg.tmax_cw_cb,
            self.dlg.cd_cw_cb,
            self.dlg.cv_cw_cb,
            self.dlg.fcd_cw_cb,
            self.dlg.fcv_cw_cb,
            self.dlg.ld_cw_cb,
            self.dlg.se_cw_cb,
            self.dlg.sp_cw_cb,
            self.dlg.mvv_cw_cb,
            self.dlg.fvv_cw_cb,
            self.dlg.if_cw_cb,
            # NEW:
            self.dlg.v2xd_cw_cb,
        ]

        if self.dlg.check_cw_cb.isChecked():
            for cb in flood_rbs:
                if cb.isEnabled():
                    cb.setChecked(True)
                else:
                    cb.setChecked(False)
        else:
            for cb in flood_rbs:
                cb.setChecked(False)

    def check_sd(self):
        """
        Function to check all available sediment maps
        """
        sediment_rbs = [
            self.dlg.ge_sd_cb,
            self.dlg.md_sd_cb,
            self.dlg.mv_sd_cb,
            self.dlg.mwse_sd_cb,
            self.dlg.fd_sd_cb,
            self.dlg.fv_sd_cb,
            self.dlg.dv_sd_cb,
            self.dlg.t1ft_sd_cb,
            self.dlg.t2ft_sd_cb,
            self.dlg.tmax_sd_cb,
            self.dlg.cd_sd_cb,
            self.dlg.cv_sd_cb,
            self.dlg.fcv_sd_cb,
            self.dlg.fcd_sd_cb,
            self.dlg.ld_sd_cb,
            self.dlg.se_sd_cb,
            self.dlg.sp_sd_cb,
            self.dlg.mdep_sd_cb,
            self.dlg.msco_sd_cb,
            self.dlg.fbd_sd_cb,
            self.dlg.mvv_sd_cb,
            self.dlg.fvv_sd_cb,
            self.dlg.if_sd_cb,
        ]

        if self.dlg.check_sd_cb.isChecked():
            for cb in sediment_rbs:
                if cb.isEnabled():
                    cb.setChecked(True)
                else:
                    cb.setChecked(False)
        else:
            for cb in sediment_rbs:
                cb.setChecked(False)

    def check_storm_drain(self):
        """
        Function to check all storm drain plots
        """
        storm_drain_rbs = [
            self.dlg.inflow_chbox,
            self.dlg.flooding_chbox,
            self.dlg.node_depth_chbox,
            self.dlg.head_chbox,
            self.dlg.flow_chbox,
            self.dlg.velocity_chbox,
            self.dlg.link_depth_chbox,
            self.dlg.percent_full_chbox,
            self.dlg.hours_flooded_chbox,
            self.dlg.max_flood_chbox,
            self.dlg.total_flood_chbox,
            self.dlg.max_pond_chbox,
        ]

        if self.dlg.check_storm_drain_chbox.isChecked():
            for cb in storm_drain_rbs:
                if cb.isEnabled():
                    cb.setChecked(True)
                else:
                    cb.setChecked(False)
        else:
            for cb in storm_drain_rbs:
                cb.setChecked(False)

    def check_hm(self):
        """
        Function to check all available hazard maps
        """
        hazard_rbs = [
            self.dlg.fh_australian_cb,
            self.dlg.fh_austrian_cb,
            self.dlg.flo_hm_cb,
            self.dlg.fi_swiss_cb,
            self.dlg.di_swiss_cb,
            self.dlg.fh_uk_cb,
            self.dlg.usbrh_hm_cb,
            self.dlg.usbrm_hm_cb,
            self.dlg.usbrv_hm_cb,
            self.dlg.usbra_hm_cb,
            self.dlg.usbrc_hm_cb,
            self.dlg.fema_hm_cb,
        ]

        if self.dlg.check_hm_cb.isChecked():
            for cb in hazard_rbs:
                if cb.isEnabled():
                    cb.setChecked(True)
                else:
                    cb.setChecked(False)
        else:
            for cb in hazard_rbs:
                cb.setChecked(False)

    def check_mf(self):
        """
        Function to check all available mudflow maps
        """
        mudflow_rbs = [
            self.dlg.ge_mf_cb,
            self.dlg.md_mf_cb,
            self.dlg.mv_mf_cb,
            self.dlg.mvv_mf_cb,
            self.dlg.mwse_mf_cb,
            self.dlg.fd_mf_cb,
            self.dlg.fv_mf_cb,
            self.dlg.fvv_mf_cb,
            self.dlg.dv_mf_cb,
            self.dlg.t1ft_mf_cb,
            self.dlg.t2ft_mf_cb,
            self.dlg.tmax_mf_cb,
            self.dlg.cd_mf_cb,
            self.dlg.cv_mf_cb,
            self.dlg.fcd_mf_cb,
            self.dlg.fcv_mf_cb,
            self.dlg.ld_mf_cb,
            self.dlg.se_mf_cb,
            self.dlg.sp_mf_cb,
            self.dlg.ms_mf_cb,
            self.dlg.fs_mf_cb,
            self.dlg.if_mf_cb,
        ]

        if self.dlg.check_mf_cb.isChecked():
            for cb in mudflow_rbs:
                if cb.isEnabled():
                    cb.setChecked(True)
                else:
                    cb.setChecked(False)
        else:
            for cb in mudflow_rbs:
                cb.setChecked(False)

    def check_tp(self):
        """
        Function to check all available twophase maps
        """
        twophase_rbs = [
            self.dlg.ge_tp_cb,
            self.dlg.mfd_tp_cb,
            self.dlg.mmd_tp_cb,
            self.dlg.cmd_tp_cb,
            self.dlg.mfv_tp_cb,
            self.dlg.mmv_tp_cb,
            self.dlg.mfsc_tp_cb,
            self.dlg.mmsc_tp_cb,
            # self.dlg.ffsc_tp_cb,
            self.dlg.fmsc_tp_cb,
            self.dlg.mwse_mf_cb,
            self.dlg.ffd_tp_cb,
            self.dlg.fmd_tp_cb,
            self.dlg.fcd_tp_cb,
            self.dlg.ffv_tp_cb,
            self.dlg.fmv_tp_cb,
            self.dlg.dv_tp_cb,
            self.dlg.t1ft_tp_cb,
            self.dlg.t2ft_tp_cb,
            self.dlg.tmax_tp_cb,
            self.dlg.mchd_tp_cb,
            self.dlg.mchv_tp_cb,
            self.dlg.fchd_tp_cb,
            self.dlg.fchv_tp_cb,
            self.dlg.ld_tp_cb,
            self.dlg.se_tp_cb,
            self.dlg.sp_tp_cb,
            self.dlg.md_tp_cb,
            self.dlg.ms_tp_cb,
            self.dlg.fdb_tp_cb,
            self.dlg.mfvv_tp_cb,
            self.dlg.ffvv_tp_cb,
            self.dlg.fmvv_tp_cb,
            self.dlg.mmvv_tp_cb,
            self.dlg.if_tp_cb,
        ]

        if self.dlg.check_tp_cb.isChecked():
            for cb in twophase_rbs:
                if cb.isEnabled():
                    cb.setChecked(True)
                else:
                    cb.setChecked(False)
        else:
            for cb in twophase_rbs:
                cb.setChecked(False)

    def collapse_all_groups(self):
        """
        Function to collapse all groups
        """
        cw_grps = [
            self.dlg.sc_cw_cgb,
            self.dlg.bv_cw_cgb,
            self.dlg.dv_cw_cgb,
            self.dlg.tv_cw_cgb,
            self.dlg.ch_cw_cgb,
            self.dlg.sv_cw_cgb,
            self.dlg.hp_cw_cgb,
        ]
        sd_grps = [
            self.dlg.sc_sd_cgb,
            self.dlg.bv_sd_cgb,
            self.dlg.dv_sd_cgb,
            self.dlg.tv_sd_cgb,
            self.dlg.ch_sd_cgb,
            self.dlg.sd_sd_cgb,
            self.dlg.sv_sd_cgb,
            self.dlg.hp_sd_cgb,
        ]
        md_grps = [
            self.dlg.sc_mf_cgb,
            self.dlg.bv_mf_cgb,
            self.dlg.dv_mf_cgb,
            self.dlg.tv_mf_cgb,
            self.dlg.ch_mf_cgb,
            self.dlg.mf_mf_cgb,
            self.dlg.sv_mf_cgb,
            self.dlg.hp_mf_cgb,
        ]
        tp_grps = [
            self.dlg.sc_tp_cgb,
            self.dlg.bv_tp_cgb,
            self.dlg.dv_tp_cgb,
            self.dlg.tv_tp_cgb,
            self.dlg.ch_tp_cgb,
            self.dlg.sv_tp_cgb,
            self.dlg.mv_tp_cgb,
            self.dlg.sdv_tp_cgb,
            self.dlg.hp_tp_cgb,
        ]
        hm_grps = [
            self.dlg.australian_hm_cgb,
            self.dlg.austrian_hm_cgb,
            self.dlg.flo_hm_cgb,
            self.dlg.swiss_hm_cgb,
            self.dlg.uk_hm_cgb,
            self.dlg.usbr_hm_cgb,
            self.dlg.fema_hz_cgb,
        ]
        storm_drain_grps = [
            self.dlg.nodes_cgb,
            self.dlg.links_cgb,
            # self.dlg.profile_plot_cgb,
            self.dlg.graphics_plot_cgb,
        ]

        if self.dlg.tab0.isEnabled():
            for grp in sd_grps:
                if grp.isEnabled():
                    grp.setCollapsed(True)
        if self.dlg.tab1.isEnabled():
            for grp in cw_grps:
                if grp.isEnabled():
                    grp.setCollapsed(True)
        if self.dlg.tab2.isEnabled():
            for grp in md_grps:
                if grp.isEnabled():
                    grp.setCollapsed(True)
        if self.dlg.tab3.isEnabled():
            for grp in tp_grps:
                if grp.isEnabled():
                    grp.setCollapsed(True)
        if self.dlg.tab5.isEnabled():
            for grp in hm_grps:
                if grp.isEnabled():
                    grp.setCollapsed(True)
        if self.dlg.tab.isEnabled():
            for grp in storm_drain_grps:
                if grp.isEnabled():
                    grp.setCollapsed(True)

    def expand_all_groups(self):
        """
        Function to expand all groups
        """
        cw_grps = [
            self.dlg.sc_cw_cgb,
            self.dlg.bv_cw_cgb,
            self.dlg.dv_cw_cgb,
            self.dlg.tv_cw_cgb,
            self.dlg.ch_cw_cgb,
            self.dlg.sv_cw_cgb,
            self.dlg.hp_cw_cgb,
        ]
        sd_grps = [
            self.dlg.sc_sd_cgb,
            self.dlg.bv_sd_cgb,
            self.dlg.dv_sd_cgb,
            self.dlg.tv_sd_cgb,
            self.dlg.ch_sd_cgb,
            self.dlg.sd_sd_cgb,
            self.dlg.sv_sd_cgb,
            self.dlg.hp_sd_cgb,
        ]
        md_grps = [
            self.dlg.sc_mf_cgb,
            self.dlg.bv_mf_cgb,
            self.dlg.dv_mf_cgb,
            self.dlg.tv_mf_cgb,
            self.dlg.ch_mf_cgb,
            self.dlg.mf_mf_cgb,
            self.dlg.sv_mf_cgb,
            self.dlg.hp_mf_cgb,
        ]
        tp_grps = [
            self.dlg.sc_tp_cgb,
            self.dlg.bv_tp_cgb,
            self.dlg.dv_tp_cgb,
            self.dlg.tv_tp_cgb,
            self.dlg.ch_tp_cgb,
            self.dlg.sv_tp_cgb,
            self.dlg.mv_tp_cgb,
            self.dlg.sdv_tp_cgb,
            self.dlg.hp_tp_cgb,
        ]
        hm_grps = [
            self.dlg.australian_hm_cgb,
            self.dlg.austrian_hm_cgb,
            self.dlg.flo_hm_cgb,
            self.dlg.swiss_hm_cgb,
            self.dlg.uk_hm_cgb,
            self.dlg.usbr_hm_cgb,
            self.dlg.fema_hz_cgb,
        ]
        storm_drain_grps = [
            self.dlg.nodes_cgb,
            self.dlg.links_cgb,
            # self.dlg.profile_plot_cgb,
            self.dlg.graphics_plot_cgb,
        ]

        if self.dlg.tab0.isEnabled():
            for grp in sd_grps:
                if grp.isEnabled():
                    grp.setCollapsed(False)
        if self.dlg.tab1.isEnabled():
            for grp in cw_grps:
                if grp.isEnabled():
                    grp.setCollapsed(False)
        if self.dlg.tab2.isEnabled():
            for grp in md_grps:
                if grp.isEnabled():
                    grp.setCollapsed(False)
        if self.dlg.tab3.isEnabled():
            for grp in tp_grps:
                if grp.isEnabled():
                    grp.setCollapsed(False)
        if self.dlg.tab5.isEnabled():
            for grp in hm_grps:
                if grp.isEnabled():
                    grp.setCollapsed(False)
        if self.dlg.tab.isEnabled():
            for grp in storm_drain_grps:
                if grp.isEnabled():
                    grp.setCollapsed(False)

    def clear_chboxes(self, *_):
        """
        Clear all QCheckBox widgets on all tabs whenever the tab changes.
        """
        # Iterate all pages in the QTabWidget
        for i in range(self.dlg.tabs.count()):
            page = self.dlg.tabs.widget(i)
            # Use QtWidgets.QCheckBox (matches how the UI is created in QGIS)
            for cb in page.findChildren(QtWidgets.QCheckBox):
                cb.setChecked(False)


