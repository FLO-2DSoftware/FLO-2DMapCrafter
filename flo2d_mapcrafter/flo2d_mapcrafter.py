# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FLO2DMapCrafter
                                 A QGIS plugin
 This plugin creates maps from FLO-2D output files.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-09-21
        git sha              : $Format:%H$
        copyright            : (C) 2023 by FLO-2D
        email                : contact@flo-2d.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QColor
from qgis.PyQt import QtWidgets
from PyQt5.QtWidgets import QMessageBox, QApplication, QCheckBox, QTableWidgetItem, QHeaderView, QSizePolicy
from PyQt5.QtXml import QDomDocument
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from qgis._core import (
    QgsCoordinateReferenceSystem,
    QgsRasterBandStats,
    QgsColorRampShader,
    QgsRasterShader,
    QgsSingleBandPseudoColorRenderer,
    QgsProject,
    QgsVectorLayer,
    QgsPrintLayout,
    QgsReadWriteContext,
    QgsMessageLog, QgsProcessingUtils, Qgis,
)
from qgis._gui import QgsProjectionSelectionDialog
from .mapping.flood import FloodMaps
from .mapping.hazard import HazardMaps
from .mapping.mudflow import MudflowMaps
from .mapping.scripts import set_icon
from .mapping.sd_results_viewer import SDResultsViewer
from .mapping.sediment import SedimentMaps
from .mapping.storm_drain import StormDrainPlots
from .mapping.twophase import TwophaseMaps
from .resources import *
from .flo2d_mapcrafter_dialog import FLO2DMapCrafterDialog
import re, os, processing, time
from datetime import datetime
from typing import List, Tuple
from .simple_swmm_parser import SimpleSWMMModel


class FLO2DMapCrafter:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.units_switch = None
        self.toler_value = None
        self.iface = iface
        self.dlg = FLO2DMapCrafterDialog()
        self._prime_sim_summary_table()
        self.actions = []
        self.menu = self.tr("&FLO-2D MapCrafter ")

        self._swmm_model = None  # Cache for parsed SWMM model.
        self._sim_type = None  # Cache for simulation type
        self._update_summary_fields()
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value("locale/userLocale")[0:2]
        locale_path = os.path.join(
            self.plugin_dir, "i18n", "FLO2DMapCrafter_{}.qm".format(locale)
        )

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        # Adjust CRS
        self.crs = QgsCoordinateReferenceSystem(QgsProject.instance().crs().authid())
        self.dlg.crsselector.crsChanged.connect(self.set_crs)

        # Select export folder
        self.dlg.flo2d_out_folder.fileChanged.connect(self.check_files)

        # Run Button
        self.dlg.runButton.clicked.connect(self.run_map_creator)

        # Cancel Button
        self.dlg.cancelButton.clicked.connect(self.closeDialog)

        # Export project Summary Button
        self.dlg.sumExportRptBtn.clicked.connect(self._export_summary_to_rpt)

        # Check all available maps
        self.dlg.check_cw_cb.stateChanged.connect(self.check_cw)
        self.dlg.check_mf_cb.stateChanged.connect(self.check_mf)
        self.dlg.check_tp_cb.stateChanged.connect(self.check_tp)
        self.dlg.check_sd_cb.stateChanged.connect(self.check_sd)
        self.dlg.check_hm_cb.stateChanged.connect(self.check_hm)
        self.dlg.check_storm_drain_chbox.stateChanged.connect(self.check_storm_drain)

        self.dlg.runButton_2.clicked.connect(self.run_open_layout)

        self.dlg.tab0.setEnabled(False)
        self.dlg.tab1.setEnabled(False)
        self.dlg.tab2.setEnabled(False)
        self.dlg.tab3.setEnabled(False)
        self.dlg.tab4.setEnabled(False)
        self.dlg.tab5.setEnabled(False)
        self.dlg.tab.setEnabled(False)
        self.dlg.tabs.currentChanged.connect(self.clear_chboxes)

        self.dlg.cg_cw_btn.clicked.connect(self.collapse_all_groups)
        self.dlg.eg_cw_btn.clicked.connect(self.expand_all_groups)
        self.dlg.cg_sd_btn.clicked.connect(self.collapse_all_groups)
        self.dlg.eg_sd_btn.clicked.connect(self.expand_all_groups)
        self.dlg.cg_md_btn.clicked.connect(self.collapse_all_groups)
        self.dlg.eg_md_btn.clicked.connect(self.expand_all_groups)
        self.dlg.cg_tp_btn.clicked.connect(self.collapse_all_groups)
        self.dlg.eg_tp_btn.clicked.connect(self.expand_all_groups)
        self.dlg.cg_hm_btn.clicked.connect(self.collapse_all_groups)
        self.dlg.eg_hm_btn.clicked.connect(self.expand_all_groups)
        self.dlg.cg_storm_drain_btn.clicked.connect(self.collapse_all_groups)
        self.dlg.eg_storm_drain_btn.clicked.connect(self.expand_all_groups)

        set_icon(self.dlg.cg_cw_btn, "collapse_groups.svg")
        set_icon(self.dlg.eg_cw_btn, "expand_groups.svg")
        set_icon(self.dlg.cg_sd_btn, "collapse_groups.svg")
        set_icon(self.dlg.eg_sd_btn, "expand_groups.svg")
        set_icon(self.dlg.cg_md_btn, "collapse_groups.svg")
        set_icon(self.dlg.eg_md_btn, "expand_groups.svg")
        set_icon(self.dlg.cg_tp_btn, "collapse_groups.svg")
        set_icon(self.dlg.eg_tp_btn, "expand_groups.svg")
        set_icon(self.dlg.cg_hm_btn, "collapse_groups.svg")
        set_icon(self.dlg.eg_hm_btn, "expand_groups.svg")
        set_icon(self.dlg.cg_storm_drain_btn, "collapse_groups.svg")
        set_icon(self.dlg.eg_storm_drain_btn, "expand_groups.svg")

        # Storm Drain subplots
        self.dlg.see_nodes_results_btn.clicked.connect(self.see_nodes_results)

    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate("FLO2DMapCrafter", message)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None,
    ):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        self.actions.append(action)

        if not hasattr(self, "menu") or not self.menu:
            self.menu = self.tr("&FLO-2D MapCrafter ")

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ":/plugins/flo2d_mapcrafter/icon.png"
        self.add_action(
            icon_path,
            text=self.tr("FLO-2D MapCrafter"),
            callback=self.open,
            parent=self.iface.mainWindow(),
        )

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(self.tr("&FLO-2D MapCrafter "), action)
            self.iface.removeToolBarIcon(action)

    def set_crs(self):
        """
        Function to set the CRS
        """
        self.crs = self.dlg.crsselector.crs()
        self.projected_crs()
        QgsProject.instance().setCrs(self.crs)

    def projected_crs(self):
        """
        Function to allow only projected crs
        """
        is_geographic = self.crs.isGeographic()
        while is_geographic:
            dialog = QgsProjectionSelectionDialog()
            if dialog.exec_():
                self.crs = dialog.crs()
                is_geographic = self.crs.isGeographic()
                if is_geographic:
                    self.iface.messageBar().pushMessage("MapCrafter requires a projected Coordinate Reference System!",
                                                        level=Qgis.Info, duration=5)
                else:
                    self.dlg.crsselector.setCrs(self.crs)
                    QgsProject.instance().setCrs(self.crs)
                    return True
            else:
                return False
        return True

    # Opening the dialog
    def open(self):
        """Shows the dialog"""

        # Adjust the CRS
        self.crs = QgsCoordinateReferenceSystem(QgsProject.instance().crs().authid())

        is_projected = self.projected_crs()
        if is_projected:
            self.dlg.crsselector.setCrs(self.crs)

            # Set the grid layer as extent, if it exists
            layer = QgsProject.instance().mapLayersByName("Grid")
            if layer:
                # Add the layer to the QgsMapLayerComboBox
                self.dlg.layer_extent_cb.setLayer(layer[0])

            self.dlg.show()
            self.dlg.activateWindow()

    def closeDialog(self):
        """Closes the Dialog"""

        checkboxes = self.dlg.tabs.findChildren(QtWidgets.QCheckBox)
        for checkBox in checkboxes:
            checkBox.setChecked(False)

        self.collapse_all_groups()

        self.dlg.close()

    # ---------------------------------------------------------------------------------------------------------#
    #                                             Helpers                                                      #
    # ---------------------------------------------------------------------------------------------------------#
    def _is_simulation_complete(self, summary_path: str) -> bool:
        if not summary_path or not os.path.isfile(summary_path):
            return False
        pat = re.compile(
            r"GRID\s+ELEMENT\s+SIZE\s*:?",
            re.IGNORECASE
        )
        try:
            with open(summary_path, "r", errors="ignore") as f:
                for line in f:
                    if pat.search(line):
                        return True
        except Exception:
            return False
        return False

    # -----------------------------------#
    # Project Summary: Units Helper      #
    # -----------------------------------#
    def _export_folder(self):
        """Return the path from the FLO-2D Export Folder widget."""
        w = getattr(self.dlg, "flo2d_out_folder", None) or getattr(self.dlg, "flo2dExportFolder", None)
        return w.filePath() if w else ""

    def _find_cont_dat(self, base):
        # Look for CONT.DAT in base folder.
        if not base:
            return None
        for name in ("CONT.DAT", "cont.dat"):
            p = os.path.join(base, name)
            if os.path.isfile(p):
                return p
        return None

    def _detect_units_from_cont(self, cont_path: str):
        """Return 'English (Imperial)' or 'SI (Metric)' from CONT.DAT line 1, token 4."""
        if not cont_path or not os.path.isfile(cont_path):
            return None
        try:
            with open(cont_path, "r", errors="ignore") as f:
                first_line = f.readline()
            if not first_line:
                return None

            # Split on any whitespace; token #4 (index 3) is the units flag.
            toks = first_line.split()
            if len(toks) >= 4 and toks[3].isdigit():
                return "SI (Metric)" if toks[3] == "1" else "English (Imperial)"
            return None
        except Exception:
            return None

    # -----------------------------------#
    # Project Summary: Build No. Helper #
    # -----------------------------------#

    def _find_summary_out(self, base):
        if not base:
            return None
        for name in ("SUMMARY.OUT", "summary.out"):
            p = os.path.join(base, name)
            if os.path.isfile(p):
                return p
        return None

    def _detect_build_from_summary(self, summary_path):
        """
        Parse 'Build No.' from SUMMARY.OUT.
        Finds the line containing 'SUMMARY.OUT FILE' and then reads the *next* line,
        which should contain 'Build No.' text. Returns the build number string.
        """
        if not summary_path or not os.path.isfile(summary_path):
            return None
        try:
            with open(summary_path, "r", errors="ignore") as f:
                lines = f.readlines()
        except Exception:
            return None

        for idx, line in enumerate(lines):
            if "SUMMARY.OUT FILE" in line.upper():
                if idx + 1 < len(lines):
                    next_line = lines[idx + 1]
                    # Extract build number from that line
                    m = re.search(r"Build\s*No\.?\s*([0-9][0-9\.\-]+)", next_line, flags=re.IGNORECASE)
                    if m:
                        return m.group(1).strip()
                    # Fallback: return whole line stripped if regex fails
                    return next_line.strip()
        return None

    # ------------------------------------#
    # Project Summary: Grid (Cell) Size  #
    # ------------------------------------#
    def _detect_cellsize_from_summary(self, summary_path: str):
        """
        Return grid cell size with units (e.g., '30.0 FT' or '10.0 M')
        by reading the 'GRID ELEMENT SIZE:' line in SUMMARY.OUT.
        """
        if not summary_path or not os.path.isfile(summary_path):
            return None
        try:
            with open(summary_path, "r", errors="ignore") as f:
                for line in f:
                    if "GRID ELEMENT SIZE" in line.upper():
                        # Accept variations in spacing/case, capture number + unit token
                        m = re.search(
                            r"GRID\s+ELEMENT\s+SIZE\s*:\s*([0-9]+(?:\.[0-9]+)?)\s*([A-Za-z]+)",
                            line, flags=re.IGNORECASE
                        )
                        if m:
                            val = m.group(1)
                            unit = m.group(2).upper()  # FT, M, etc.
                            return f"{val} {unit}"
                        # Fallback: whole line trimmed if regex fails
                        return line.strip()
        except Exception:
            return None
        return None

    # ------------------------------------#
    # Project Summary: No. of Elements   #
    # ------------------------------------#

    def _detect_elements_from_summary(self, summary_path: str):
        """
        Return the total number of grid elements as a string (e.g., '54,306')
        by parsing the 'TOTAL NUMBER OF GRID ELEMENTS:' line in SUMMARY.OUT.
        """
        if not summary_path or not os.path.isfile(summary_path):
            return None
        try:
            pat = re.compile(r"TOTAL\s+NUMBER\s+OF\s+GRID\s+ELEMENTS\s*:\s*([0-9,]+)",
                             flags=re.IGNORECASE)
            with open(summary_path, "r", errors="ignore") as f:
                for line in f:
                    m = pat.search(line)
                    if m:
                        digits = m.group(1).replace(",", "").strip()
                        if digits.isdigit():
                            return f"{int(digits):,}"
                        return m.group(1).strip()
        except Exception:
            return None
        return None

    # ----------------------------------------#
    # Project Summary: Simulation Date        #
    # ----------------------------------------#

    def _detect_simulation_date_from_summary(self, summary_path: str):
        """
        Find the line like:
            THIS OUTPUT FILE WAS TERMINATED ON:   5/15/2025  AT:   8:14:28
        and return a readable timestamp, e.g. '2025-05-15 08:14:28'.
        If parsing fails, return the raw 'date [time]' substring.
        """
        if not summary_path or not os.path.isfile(summary_path):
            return None

        pat = re.compile(
            r"TERMINATED\s+ON:\s*([0-9]{1,2}[/-][0-9]{1,2}[/-][0-9]{2,4})"
            r"(?:\s+AT:\s*([0-9]{1,2}:[0-9]{2}:[0-9]{2}(?:\s*[APMapm]{2})?))?",
            re.IGNORECASE
        )
        try:
            with open(summary_path, "r", errors="ignore") as f:
                for line in f:
                    if "TERMINATED ON" not in line.upper():
                        continue
                    m = pat.search(line)
                    if not m:
                        continue
                    date_str = m.group(1).strip()
                    time_str = (m.group(2) or "").strip()

                    # Try to normalize to ISO-ish 'YYYY-MM-DD HH:MM:SS'
                    # Accept MM/DD/YYYY or MM-DD-YYYY (or 2-digit year)
                    for fmt in ("%m/%d/%Y", "%m/%d/%y", "%m-%d-%Y", "%m-%d-%y"):
                        try:
                            d = datetime.strptime(date_str, fmt)
                            break
                        except ValueError:
                            d = None
                    if d is None:
                        # fallback: return raw substring
                        return (date_str + (" " + time_str if time_str else "")).strip()

                    if time_str:
                        # Try 24h first, then 12h with AM/PM
                        for tfmt in ("%H:%M:%S", "%I:%M:%S %p", "%I:%M:%S%p"):
                            try:
                                t = datetime.strptime(time_str.upper().replace(".", ""), tfmt)
                                # merge date+time
                                merged = d.replace(hour=t.hour, minute=t.minute, second=t.second)
                                return merged.strftime("%Y-%m-%d %H:%M:%S")
                            except ValueError:
                                pass
                        # if time unparseable, return date + raw time
                        return f"{d.strftime('%Y-%m-%d')} {time_str}"
                    else:
                        return d.strftime("%Y-%m-%d")
        except Exception:
            return None
        return None

    # Project Summary: Simulation Duration
    def detect_computer_run_time(self, summary_path: str):
        if not summary_path or not os.path.isfile(summary_path):
            return None

        pat = re.compile(r"COMPUTER\s+RUN\s+TIME\s*:\s*([0-9]+(?:\.[0-9]+)?)\s*HRS", re.IGNORECASE)

        try:
            with open(summary_path, "r", errors="ignore") as f:
                for line in f:
                    m = pat.search(line)
                    if not m:
                        continue
                    hours = float(m.group(1))
                    total_seconds = int(round(hours * 3600))

                    hh = total_seconds //3600
                    mm = (total_seconds % 3600) //60
                    ss = total_seconds % 60

                    return f"{hh:02d}:{mm:02d}:{ss:02d}"
        except Exception:
            return None

        return None

    # --------------------------------------------#
    # Project Summary: Coordinate System (EPSG)  #
    # --------------------------------------------#

    def _detect_epsg_code(self):
        """
        Return the project's EPSG code (e.g., 'EPSG:32637').
        """
        try:
            crs = QgsProject.instance().crs()
            if crs.isValid():
                return crs.authid()
        except Exception:
            pass
        return None

    def _reset_sim_summary_table(self, tbl):
        """Hard reset the 3-column Summary table to a clean, consistent state."""
        tbl.setUpdatesEnabled(False)
        try:
            tbl.setSortingEnabled(False)
            tbl.clear()
            try:
                tbl.clearSpans()
            except Exception:
                pass
            tbl.setRowCount(0)
            tbl.setColumnCount(3)
            tbl.setHorizontalHeaderLabels(["Simulation Summary", "Status", "Action"])

            h = tbl.horizontalHeader()
            # Use the SAME modes in all states for consistency:
            h.setSectionResizeMode(0, QHeaderView.Stretch)
            h.setSectionResizeMode(1, QHeaderView.ResizeToContents)
            h.setSectionResizeMode(2, QHeaderView.Stretch)
            h.setMinimumSectionSize(80)  # keeps "Status" from collapsing
            h.setStretchLastSection(False)

            tbl.verticalHeader().setVisible(False)
            tbl.setAlternatingRowColors(False)
            tbl.setWordWrap(True)
        finally:
            tbl.setUpdatesEnabled(True)

    def _show_sim_summary_placeholder(self, tbl, message: str):
        self._reset_sim_summary_table(tbl)
        tbl.setRowCount(1)
        item = QTableWidgetItem(message)
        f = item.font();
        f.setItalic(True);
        item.setFont(f)
        item.setTextAlignment(Qt.AlignCenter)
        item.setFlags(Qt.ItemIsEnabled)
        tbl.setItem(0, 0, item)
        tbl.setSpan(0, 0, 1, 3)  # this span will be cleared next rebuild

    def _extract_simulation_summary_table(self, summary_path: str) -> List[Tuple[str, str, str]]:
        """
        Parse the three columns under the SIMULATION SUMMARY section of SUMMARY.OUT.
        Returns a list of (summary, status, action).
        Robust to variable spacing; stops at blank line or next section.
        """
        rows: List[Tuple[str, str, str]] = []
        if not summary_path:
            return rows

        try:
            with open(summary_path, "r", errors="ignore") as f:
                lines = f.readlines()
        except Exception:
            return rows

        # 1) Find the section start: the line that has 'SIMULATION SUMMARY'
        start = None
        for i, line in enumerate(lines):
            if re.search(r"\bSIMULATION SUMMARY\b", line, re.IGNORECASE):
                start = i
                break
        if start is None:
            return rows

        # 2) Skip blanks to find the header row that contains both STATUS and ACTION
        i = start + 1
        while i < len(lines) and not lines[i].strip():
            i += 1

        # header row
        if i < len(lines) and re.search(r"\bSTATUS\b", lines[i], re.IGNORECASE) and re.search(r"\bACTION\b", lines[i],
                                                                                              re.IGNORECASE):
            i += 1  # move to first data row

        # 3) Read data rows until a blank spacer or another header-like line
        while i < len(lines):
            raw = lines[i].rstrip("\n")
            i += 1

            if not raw.strip():
                break

            if re.search(r"\b(UNITS|BUILD|GRID SIZE|NO\.? OF ELEMENTS|SIMULATION TYPE|COORD\.?|FLO-2D|SUMMARY)\b", raw,
                         re.IGNORECASE):
                break

            # split into up to 3 columns by 2+ spaces
            parts = re.split(r"\s{2,}", raw.strip(), maxsplit=2)
            if len(parts) == 3:
                s, status, action = parts
            elif len(parts) == 2:
                s, status = parts
                action = ""
            else:
                # single token: treat as continuation of previous row's action if present
                if rows:
                    prev = list(rows[-1])
                    prev[2] = (prev[2] + " " + parts[0]).strip()
                    rows[-1] = tuple(prev)
                continue

            rows.append((s, status, action))
        return rows

    # Prime the Simulation Summary table headers before data exists
    def _prime_sim_summary_table(self):
        tbl = getattr(self.dlg, "sumSimSummaryTable", None)
        if not tbl:
            return
        # keep it a good height even when empty
        tbl.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.MinimumExpanding)
        tbl.setMinimumHeight(220)
        self._reset_sim_summary_table(tbl)

    def _update_summary_fields(self):
        base = self._export_folder()

        # If no export folder chosen yet reset all summary fields to "—"
        if not base or not os.path.isdir(base):
            self.dlg.sumUnits.setText("—")
            self.dlg.sumBuild.setText("—")
            self.dlg.sumCellSize.setText("—")
            self.dlg.sumNElems.setText("—")
            self.dlg.sumSimType.setText("—")
            self.dlg.sumSimDate.setText("—")
            self.dlg.sumSimDur.setText("—")
            self.dlg.sumEPSG.setText("—")

            if hasattr(self.dlg, "sumSimSummaryTable") and self.dlg.sumSimSummaryTable:
                self._prime_sim_summary_table()
            return

        cont_path = self._find_cont_dat(base)
        summary_path = self._find_summary_out(base)

        # Fill values
        units = self._detect_units_from_cont(cont_path)
        build = self._detect_build_from_summary(summary_path)
        cell = self._detect_cellsize_from_summary(summary_path)
        nelems = self._detect_elements_from_summary(summary_path)
        # simtype = self._detect_simulation_type(base, cont_path, summary_path)
        simdate = self._detect_simulation_date_from_summary(summary_path)
        sim_duration = self.detect_computer_run_time(summary_path)
        epsg = self._detect_epsg_code()
        simtype = getattr(self, "_sim_type", None)

        self.dlg.sumUnits.setText(units or "—")
        self.dlg.sumBuild.setText(build or "—")
        self.dlg.sumCellSize.setText(cell or "—")
        self.dlg.sumNElems.setText(nelems or "—")
        self.dlg.sumSimType.setText(simtype or "—")
        self.dlg.sumSimDate.setText(simdate or "—")
        self.dlg.sumSimDur.setText(sim_duration or "—")
        self.dlg.sumEPSG.setText(epsg or "—")

        # --- Simulation Summary (3-column table) ---
        if hasattr(self.dlg, "sumSimSummaryTable") and self.dlg.sumSimSummaryTable:
            tbl = self.dlg.sumSimSummaryTable

            # 1) SUMMARY.OUT missing, use placeholder
            if not summary_path:
                self._show_sim_summary_placeholder(
                    tbl, "— SUMMARY.OUT not found in the selected folder —"
                )
                return

            # 2) Parse rows + completion flag
            sim_table_rows = self._extract_simulation_summary_table(summary_path)
            is_complete = self._is_simulation_complete(summary_path)

            # 3) If the run looks incomplete, use placeholder
            if not is_complete:
                self._show_sim_summary_placeholder(tbl, "— Simulation Incomplete —")
                return

            # 4) If there’s no SIMULATION SUMMARY section, use placeholder
            if not sim_table_rows:
                self._show_sim_summary_placeholder(
                    tbl, "— No 'Simulation Summary' information found in SUMMARY.OUT —"
                )
                return

            # 5) Otherwise build the real table
            self._reset_sim_summary_table(tbl)
            tbl.setRowCount(len(sim_table_rows))
            for r, (summary_txt, status_txt, action_txt) in enumerate(sim_table_rows):
                tbl.setItem(r, 0, QTableWidgetItem(summary_txt))
                tbl.setItem(r, 1, QTableWidgetItem(status_txt))
                tbl.setItem(r, 2, QTableWidgetItem(action_txt))

    def _export_summary_to_rpt(self):
        """
        Export the 'Summary' tab contents to report_proj.rpt.
        If a file with the same name already exists, ask the user to Overwrite or Cancel.
        """
        try:
            # Ensure UI is up to date
            self._update_summary_fields()

            # Prefer MapCrafter Output Folder; fallback to export folder
            out_dir = ""
            try:
                out_dir = self.dlg.mapper_out_folder.filePath().strip()
            except Exception:
                pass
            if not out_dir:
                out_dir = (self._export_folder() or "").strip()

            if not out_dir:
                self.iface.messageBar().pushMessage(
                    "Please set an output folder (MapCrafter or FLO-2D Export Folder) before exporting.",
                    level=Qgis.Warning, duration=5
                )
                return

            os.makedirs(out_dir, exist_ok=True)
            out_path = os.path.join(out_dir, "report_proj.rpt")

            # If file exists, ask user whether to overwrite or cancel
            if os.path.exists(out_path):
                mb = QMessageBox(self.dlg)
                mb.setIcon(QMessageBox.Warning)
                mb.setWindowTitle("File already exists")
                mb.setText(
                    f"A file named 'report_proj.rpt' already exists in:\n\n{out_dir}\n\n"
                    "Do you want to overwrite it?"
                )
                overwrite_btn = mb.addButton("Overwrite", QMessageBox.YesRole)
                cancel_btn = mb.addButton("Cancel", QMessageBox.RejectRole)
                mb.setDefaultButton(cancel_btn)
                mb.exec_()

                if mb.clickedButton() is not overwrite_btn:
                    # User cancelled the export
                    self.iface.messageBar().pushMessage("Export cancelled.", level=Qgis.Info, duration=4)
                    return

            # Gather fields from the Summary tab
            g = self.dlg

            def txt(w):
                try:
                    return (w.text() or "").strip()
                except Exception:
                    return ""

            project_id = txt(g.project_id)
            units = txt(g.sumUnits)
            build_no = txt(g.sumBuild)
            cell_size = txt(g.sumCellSize)
            n_elems = txt(g.sumNElems)
            sim_type = txt(g.sumSimType)
            sim_date = txt(g.sumSimDate)
            epsg_code = txt(g.sumEPSG)

            # Simulation Summary table rows
            rows = []
            tbl = getattr(g, "sumSimSummaryTable", None)
            if tbl:
                for r in range(tbl.rowCount()):
                    c0 = tbl.item(r, 0).text().strip() if tbl.item(r, 0) else ""
                    c1 = tbl.item(r, 1).text().strip() if tbl.item(r, 1) else ""
                    c2 = tbl.item(r, 2).text().strip() if tbl.item(r, 2) else ""
                    rows.append((c0, c1, c2))

            hdr = ("Simulation Summary", "Status", "Action")
            w0 = max(len(hdr[0]), *(len(r[0]) for r in rows)) if rows else len(hdr[0])
            w1 = max(len(hdr[1]), *(len(r[1]) for r in rows)) if rows else len(hdr[1])

            def line3(a, b, c):
                return f"{a.ljust(w0)}  |  {b.ljust(w1)}  |  {c}"

            now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            header = [
                "FLO-2D MapCrafter — Project Summary",
                f"Generated: {now}",
                ""
            ]
            meta = [
                "Project metadata:",
                f"  Units:               {units or '—'}",
                f"  Build No.:           {build_no or '—'}",
                f"  Grid Size:           {cell_size or '—'}",
                f"  No. of Elements:     {n_elems or '—'}",
                f"  Simulation Type:     {sim_type or '—'}",
                f"  Simulation Date:     {sim_date or '—'}",
                f"  Coord. Ref. System:  {epsg_code or '—'}",
                ""
            ]
            table = [line3(*hdr)]
            table.append("-" * (w0 + 2 + 2 + w1 + 2 + 2 + 40))
            if rows:
                for r in rows:
                    table.append(line3(*r))
            else:
                table.append("(no simulation summary rows parsed)")

            content = "\n".join(header + meta + ["Simulation Summary Table:", ""] + table) + "\n"

            # Write file
            with open(out_path, "w", encoding="utf-8") as f:
                f.write(content)

            QMessageBox.information(self.dlg, "Summary exported",
                                    f"Summary written to:\n{out_path}")

        except Exception as e:
            self.iface.messageBar().pushMessage(
                f"Export failed: {e}", level=Qgis.Critical, duration=6
            )

    def _load_swmm_model(self, inp_file, rpt_file):
        """Load and cache SWMM model. Re-parse only if .rpt file changed."""
        rpt_mtime = os.path.getmtime(rpt_file) if os.path.isfile(rpt_file) else None
        model = getattr(self, "_swmm_model", None)
        if (model is None) or (getattr(model, "_rpt_mtime", None) != rpt_mtime):
            self._swmm_model = SimpleSWMMModel(inp_file, rpt_file)
            self._swmm_model._rpt_mtime = rpt_mtime
        return self._swmm_model

    # Custom logic for TOPO_SDElev.RGH availability.
    def mge_availability(self, results_dir: str) -> bool:
        if not results_dir or not os.path.isdir(results_dir):
            return False
        files_results = set(os.listdir(results_dir))
        files_map = set()
        try:
            files_map = set(os.listdir(self.dlg.mapper_out_folder.filePath()))
        except Exception:
            pass
        has_mge = "TOPO_SDElev.RGH" in files_results or "TOPO_SDElev.RGH" in files_map
        can_generate_mge = "TOPO.DAT" in files_results and "FPREV.NEW" in files_results
        return has_mge or can_generate_mge

    # Custom logic for FINAL_WSE.DAT availability
    def final_wse_availability(self, results_dir: str) -> bool:
        if not results_dir or not os.path.isdir(results_dir):
            return False
        files_results = set(os.listdir(results_dir))
        files_map = set()
        try:
            files_map = set(os.listdir(self.dlg.mapper_out_folder.filePath()))
        except Exception:
            pass
        has_finaldep = "FINALDEP.OUT" in files_results
        has_final_wse = "FINAL_WSE.DAT" in files_map
        has_topo_sd = "TOPO_SDElev.RGH" in files_results or "TOPO_SDElev.RGH" in files_map
        can_generate_topo_sd = "TOPO.DAT" in files_results and "FPREV.NEW" in files_results
        has_topo = "TOPO.DAT" in files_results
        return has_final_wse or (has_finaldep and (has_topo_sd or can_generate_topo_sd or has_topo))

    def check_files(self):
        """Function to check the type of files present on the simulation"""

        tabs = self.dlg.tabs
        tabs.blockSignals(True)

        output_directory = self.dlg.flo2d_out_folder.filePath()

        # Return immediately when folder is empty or invalid
        if not output_directory or not os.path.isdir(output_directory):
            return

        files_in_directory = os.listdir(output_directory)

        # --- Decide sim type FIRST (from CONT.DAT) ---
        self._sim_type = None  # reset for new folder
        cont_path = os.path.join(output_directory, "CONT.DAT")
        try:
            if os.path.isfile(cont_path):
                with open(cont_path, "r") as f:
                    lines = f.readlines()
                self.units_switch = lines[0].split()[3]
                elements = lines[2].split()
                mud_switch = elements[3]
                sed_switch = elements[4]

                if mud_switch == "0" and sed_switch == "0":
                    self._sim_type = "Flood"
                elif mud_switch == "0" and sed_switch == "1":
                    self._sim_type = "Sediment"
                elif mud_switch == "1" and sed_switch == "0":
                    self._sim_type = "Mudflow"
                elif mud_switch == "2" and sed_switch == "0":
                    self._sim_type = "Two-phase"
                # else: leave as None
        except Exception:
            # Leave _sim_type = None on any parsing issue
            pass

        toler_path = os.path.join(output_directory, "TOLER.DAT")
        if os.path.isfile(toler_path):
            with open(toler_path, "r") as f:
                lines = f.readlines()
            self.toler_value = float(lines[0].split()[0])

        # --- Refresh the Summary tab with the NEW sim type ---
        self._update_summary_fields()

        # In future version, calculate the Cell size from the DEPTH.OUT file
        if "DEPTH.OUT" in files_in_directory and "CONT.DAT" in files_in_directory:
            self.dlg.runButton.setEnabled(True)
            self.dlg.label_2.setEnabled(True)
            self.dlg.mapper_out_folder.setEnabled(True)
            self.dlg.tab4.setEnabled(True)
        else:
            msg_box = QMessageBox()
            msg_box.setIcon(QMessageBox.Warning)
            msg_box.setWindowTitle("Warning")
            msg_box.setText("No CONT.DAT and *.OUT files were found in this directory!")
            msg_box.exec_()
            return

        with open(output_directory + r"\CONT.DAT", "r") as file:
            lines = file.readlines()
            elements = lines[2].split()
            self.units_switch = lines[0].split()[3]
            mud_switch = elements[3]
            sed_switch = elements[4]
            file.close()

        max_vector_scale = self.dlg.max_vector_scale_sb.value()
        min_vector_scale = self.dlg.min_vector_scale_sb.value()
        vector_scale = [max_vector_scale, min_vector_scale]

        self._sim_type = None


        # Flood simulation
        if mud_switch == "0" and sed_switch == "0":
            self._sim_type = "Flood"
            self.dlg.tab0.setEnabled(False)
            self.dlg.tab1.setEnabled(True)
            self.dlg.tab2.setEnabled(False)
            self.dlg.tab3.setEnabled(False)
            self.dlg.tabs.setCurrentIndex(1)

            flood_maps = FloodMaps(self.iface, self.units_switch, vector_scale, self.toler_value)
            flood_files_dict = flood_maps.check_flood_files(output_directory)

            # Flood TOPO_SDElev.RGH availability
            flood_files_dict[r"TOPO_SDElev.RGH"] = self.mge_availability(output_directory)

            # Flood FINAL_WSE.DAT availability
            flood_files_dict[r"FINAL_WSE.DAT"] = self.final_wse_availability(output_directory)

            flood_rbs = {
                r"TOPO.DAT": self.dlg.ge_cw_cb,
                r"TOPO_SDElev.RGH": self.dlg.mge_cw_cb,
                r"DEPTH.OUT": self.dlg.md_cw_cb,
                r"VELFP.OUT": self.dlg.mv_cw_cb,
                r"VELDIREC.OUT": self.dlg.mvv_cw_cb,
                r"MAXWSELEV.OUT": self.dlg.mwse_cw_cb,
                r"FINALDEP.OUT": self.dlg.fd_cw_cb,
                r"FINALVEL.OUT": self.dlg.fv_cw_cb,
                r"FINALDIR.OUT": self.dlg.fvv_cw_cb,
                r"VEL_X_DEPTH.OUT": self.dlg.dv_cw_cb,
                r"VEL_SQUARED_X_DEPTH.OUT": self.dlg.v2xd_cw_cb,
                r"TIMEONEFT.OUT": self.dlg.t1ft_cw_cb,
                r"TIMETWOFT.OUT": self.dlg.t2ft_cw_cb,
                r"TIMETOPEAK.OUT": self.dlg.tmax_cw_cb,
                r"DEPCH.OUT": self.dlg.cd_cw_cb,
                r"VELOC.OUT": self.dlg.cv_cw_cb,
                r"VELCHFINAL.OUT": self.dlg.fcv_cw_cb,
                r"DEPCHFINAL.OUT": self.dlg.fcd_cw_cb,
                r"LEVEEDEFIC.OUT": self.dlg.ld_cw_cb,
                r"SPECENERGY.OUT": self.dlg.se_cw_cb,
                r"STATICPRESS.OUT": self.dlg.sp_cw_cb,
                r"IMPACT.OUT": self.dlg.if_cw_cb,
                r"FINAL_WSE.DAT": self.dlg.fwse_cw_cb,
            }

            for key, value in flood_files_dict.items():
                if value:
                    flood_rbs[key].setEnabled(True)
                else:
                    flood_rbs[key].setEnabled(False)

        # Sediment simulation
        if mud_switch == "0" and sed_switch == "1":
            self._sim_type = "Sediment"
            self.dlg.tab1.setEnabled(False)
            self.dlg.tab2.setEnabled(False)
            self.dlg.tab0.setEnabled(True)
            self.dlg.tab3.setEnabled(False)
            self.dlg.tabs.setCurrentIndex(2)

            sediment_maps = SedimentMaps(self.iface, self.units_switch, vector_scale, self.toler_value)
            sediment_files_dict = sediment_maps.check_sediment_files(output_directory)

            # Sediments TOPO_SDElev.RGH availability
            sediment_files_dict[r"TOPO_SDElev.RGH"] = self.mge_availability(output_directory)

            # Sediments FINAL_WSE.DAT availability
            sediment_files_dict[r"FINAL_WSE.DAT"] = self.final_wse_availability(output_directory)

            sediment_rbs = {
                r"TOPO.DAT": self.dlg.ge_sd_cb,
                r"TOPO_SDElev.RGH": self.dlg.mge_sd_cb,
                r"DEPTH.OUT": self.dlg.md_sd_cb,
                r"VELFP.OUT": self.dlg.mv_sd_cb,
                r"VELDIREC.OUT": self.dlg.mvv_sd_cb,
                r"MAXWSELEV.OUT": self.dlg.mwse_sd_cb,
                r"FINALDEP.OUT": self.dlg.fd_sd_cb,
                r"FINALVEL.OUT": self.dlg.fv_sd_cb,
                r"FINALDIR.OUT": self.dlg.fvv_sd_cb,
                r"VEL_X_DEPTH.OUT": self.dlg.dv_sd_cb,
                r"VEL_SQUARED_X_DEPTH.OUT": self.dlg.v2xd_sd_cb,
                r"TIMEONEFT.OUT": self.dlg.t1ft_sd_cb,
                r"TIMETWOFT.OUT": self.dlg.t2ft_sd_cb,
                r"TIMETOPEAK.OUT": self.dlg.tmax_sd_cb,
                r"DEPCH.OUT": self.dlg.cd_sd_cb,
                r"VELOC.OUT": self.dlg.cv_sd_cb,
                r"VELCHFINAL.OUT": self.dlg.fcv_sd_cb,
                r"DEPCHFINAL.OUT": self.dlg.fcd_sd_cb,
                r"LEVEEDEFIC.OUT": self.dlg.ld_sd_cb,
                r"SPECENERGY.OUT": self.dlg.se_sd_cb,
                r"STATICPRESS.OUT": self.dlg.sp_sd_cb,
                r"SEDFP.OUT": [
                    self.dlg.mdep_sd_cb,
                    self.dlg.msco_sd_cb,
                    self.dlg.fbd_sd_cb
                ],
                r"IMPACT.OUT": self.dlg.if_sd_cb,
                r"FINAL_WSE.DAT": self.dlg.fwse_sd_cb,
            }

            for key, value in sediment_files_dict.items():
                if value:
                    if isinstance(sediment_rbs[key], list):
                        for cb in sediment_rbs[key]:
                            cb.setEnabled(True)
                    else:
                        sediment_rbs[key].setEnabled(True)
                else:
                    if isinstance(sediment_rbs[key], list):
                        for cb in sediment_rbs[key]:
                            cb.setEnabled(False)
                    else:
                        sediment_rbs[key].setEnabled(False)

        # Mudflow simulation
        if mud_switch == "1" and sed_switch == "0":
            self._sim_type = "Mudflow"
            self.dlg.tab0.setEnabled(False)
            self.dlg.tab1.setEnabled(False)
            self.dlg.tab2.setEnabled(True)
            self.dlg.tab3.setEnabled(False)
            self.dlg.tabs.setCurrentIndex(3)

            mudflow_maps = MudflowMaps(self.iface, self.units_switch, vector_scale, self.toler_value)
            mudflow_files_dict = mudflow_maps.check_mudflow_files(output_directory)

            # Mudflow TOPO_SDElev.RGH availability
            mudflow_files_dict[r"TOPO_SDElev.RGH"] = self.mge_availability(output_directory)

            # Mudflow FINAL_WSE.DAT availability
            mudflow_files_dict[r"FINAL_WSE.DAT"] = self.final_wse_availability(output_directory)

            mudflow_rbs = {
                r"TOPO.DAT": self.dlg.ge_mf_cb,
                r"TOPO_SDElev.RGH": self.dlg.mge_mf_cb,
                r"DEPTH.OUT": self.dlg.md_mf_cb,
                r"VELFP.OUT": self.dlg.mv_mf_cb,
                r"VELDIREC.OUT": self.dlg.mvv_mf_cb,
                r"MAXWSELEV.OUT": self.dlg.mwse_mf_cb,
                r"FINALDEP.OUT": self.dlg.fd_mf_cb,
                r"FINALVEL.OUT": self.dlg.fv_mf_cb,
                r"FINALDIR.OUT": self.dlg.fvv_mf_cb,
                r"VEL_X_DEPTH.OUT": self.dlg.dv_mf_cb,
                r"VEL_SQUARED_X_DEPTH.OUT": self.dlg.v2xd_mf_cb,
                r"TIMEONEFT.OUT": self.dlg.t1ft_mf_cb,
                r"TIMETWOFT.OUT": self.dlg.t2ft_mf_cb,
                r"TIMETOPEAK.OUT": self.dlg.tmax_mf_cb,
                r"DEPCH.OUT": self.dlg.cd_mf_cb,
                r"VELOC.OUT": self.dlg.cv_mf_cb,
                r"VELCHFINAL.OUT": self.dlg.fcv_mf_cb,
                r"DEPCHFINAL.OUT": self.dlg.fcd_mf_cb,
                r"LEVEEDEFIC.OUT": self.dlg.ld_mf_cb,
                r"SPECENERGY.OUT": self.dlg.se_mf_cb,
                r"STATICPRESS.OUT": self.dlg.sp_mf_cb,
                r"CVFPMAX.OUT": self.dlg.ms_mf_cb,
                r"FINALCVFP.OUT": self.dlg.fs_mf_cb,
                r"IMPACT.OUT": self.dlg.if_mf_cb,
                r"FINAL_WSE.DAT": self.dlg.fwse_mf_cb,
            }

            for key, value in mudflow_files_dict.items():
                if value:
                    mudflow_rbs[key].setEnabled(True)
                else:
                    mudflow_rbs[key].setEnabled(False)

        # Two-phase simulation
        if mud_switch == "2" and sed_switch == "0":
            self._sim_type = "Two-phase"
            self.dlg.tab0.setEnabled(False)
            self.dlg.tab1.setEnabled(False)
            self.dlg.tab2.setEnabled(False)
            self.dlg.tab3.setEnabled(True)
            self.dlg.tabs.setCurrentIndex(4)

            twophase_maps = TwophaseMaps(self.iface, self.units_switch, vector_scale, self.toler_value)
            twophase_files_dict = twophase_maps.check_twophase_files(output_directory)

            # Two-phase TOPO_SDElev.RGH availability
            twophase_files_dict[r"TOPO_SDElev.RGH"] = self.mge_availability(output_directory)
            # Two-phase FINAL_WSE.DAT availability
            twophase_files_dict[r"FINAL_WSE.DAT"] = self.final_wse_availability(output_directory)

            twophase_rbs = {
                r"TOPO.DAT": self.dlg.ge_tp_cb,
                r"TOPO_SDElev.RGH": self.dlg.mge_tp_cb,
                r"DEPTH.OUT": self.dlg.mfd_tp_cb,
                r"DEPFPMAX_MUD.OUT": self.dlg.mmd_tp_cb,
                r"DEPTHMAX_2PHASE_COMBINED.OUT": self.dlg.cmd_tp_cb,
                r"VELFP.OUT": self.dlg.mfv_tp_cb,
                r"VELFP_MUD.OUT": self.dlg.mmv_tp_cb,
                r"VELDIREC.OUT": self.dlg.mfvv_tp_cb,
                r"VELDIREC_MUD.OUT": self.dlg.mmvv_tp_cb,
                r"CVFPMAX.OUT": self.dlg.mfsc_tp_cb,
                r"CVFPMAX_MUD.OUT": self.dlg.mmsc_tp_cb,
                # r"FINALCVFP.OUT": self.dlg.ffsc_tp_cb,
                r"FINALCVFP_MUD.OUT": self.dlg.fmsc_tp_cb,
                # r"MAXWSELEV.OUT": self.dlg.mwse_mf_cb,
                r"FINALDEP.OUT": self.dlg.ffd_tp_cb,
                r"FINALDEP_MUD.OUT": self.dlg.fmd_tp_cb,
                r"FINALDIR.OUT": self.dlg.ffvv_tp_cb,
                r"FINALDIR_MUD.OUT": self.dlg.fmvv_tp_cb,
                r"FINALDEP_COMBO.OUT": self.dlg.fcd_tp_cb,
                r"FINALVEL.OUT": self.dlg.ffv_tp_cb,
                r"FINALVEL_MUD.OUT": self.dlg.fmv_tp_cb,
                r"VEL_X_DEPTH.OUT": self.dlg.dv_tp_cb,
                r"VEL_SQUARED_X_DEPTH.OUT": self.dlg.v2xd_tp_cb,
                r"TIMEONEFT.OUT": self.dlg.t1ft_tp_cb,
                r"TIMETWOFT.OUT": self.dlg.t2ft_tp_cb,
                r"TIMETOPEAK.OUT": self.dlg.tmax_tp_cb,
                r"DEPCH.OUT": self.dlg.mchd_tp_cb,
                r"VELOC.OUT": self.dlg.mchv_tp_cb,
                r"VELCHFINAL.OUT": self.dlg.fchv_tp_cb,
                r"DEPCHFINAL.OUT": self.dlg.fchd_tp_cb,
                r"LEVEEDEFIC.OUT": self.dlg.ld_tp_cb,
                r"SPECENERGY.OUT": self.dlg.se_tp_cb,
                r"STATICPRESS.OUT": self.dlg.sp_tp_cb,
                r"IMPACT.OUT": self.dlg.if_tp_cb,
                r"SEDFP.OUT": [
                    self.dlg.ms_tp_cb,
                    self.dlg.md_tp_cb,
                    self.dlg.fdb_tp_cb
                ],
                r"FP_BED_CHANGE_MUD.OUT": self.dlg.fdbmcd_tp_cb,
                r"FINAL_WSE.DAT": self.dlg.fwse_tp_cb,
            }

            for key, value in twophase_files_dict.items():
                if value:
                    if isinstance(twophase_rbs[key], list):
                        for cb in twophase_rbs[key]:
                            cb.setEnabled(True)
                    else:
                        twophase_rbs[key].setEnabled(True)
                else:
                    if isinstance(twophase_rbs[key], list):
                        for cb in twophase_rbs[key]:
                            cb.setEnabled(False)
                    else:
                        twophase_rbs[key].setEnabled(False)

        # Hazard Maps
        self.dlg.tab5.setEnabled(True)
        hazard_maps = HazardMaps(self.iface, self.units_switch, self.toler_value)
        hazard_maps_dict = hazard_maps.check_hazard_files(output_directory)

        hazard_rbs = {
            "ARR": self.dlg.fh_australian_cb,
            "Austrian": self.dlg.fh_austrian_cb,
            "FLO-2D": self.dlg.flo_hm_cb,
            "Swiss": [self.dlg.fi_swiss_cb, self.dlg.di_swiss_cb],
            "UK": self.dlg.fh_uk_cb,
            "USBR": [
                self.dlg.usbrh_hm_cb,
                self.dlg.usbrm_hm_cb,
                self.dlg.usbrv_hm_cb,
                self.dlg.usbra_hm_cb,
                self.dlg.usbrc_hm_cb,
            ],
            "FEMA": self.dlg.fema_hm_cb,
        }

        for key, value in hazard_maps_dict.items():
            if value:
                if isinstance(hazard_rbs[key], list):
                    for cb in hazard_rbs[key]:
                        cb.setEnabled(True)
                else:
                    hazard_rbs[key].setEnabled(True)
            else:
                if isinstance(hazard_rbs[key], list):
                    for cb in hazard_rbs[key]:
                        cb.setEnabled(False)
                else:
                    hazard_rbs[key].setEnabled(False)

        # Add MapCrafter to the output folder
        map_output_dir = output_directory + r"\MapCrafter"
        self.dlg.mapper_out_folder.setFilePath(map_output_dir)
        if not os.path.exists(map_output_dir):
            os.makedirs(map_output_dir)

        inp_present = False
        rpt_present = False

        for file_name in files_in_directory:
            if file_name.lower() == 'swmm.inp':
                inp_present = True
            elif file_name.lower() == 'swmm.rpt':
                rpt_present = True

        if inp_present and rpt_present:
            self.dlg.tab.setEnabled(True)

            # Try lowercase first, fallback to uppercase
            inp_file = os.path.join(output_directory, "swmm.inp")
            rpt_file = os.path.join(output_directory, "swmm.rpt")

            if not os.path.isfile(inp_file):
                inp_file = os.path.join(output_directory, "SWMM.INP")
            if not os.path.isfile(rpt_file):
                rpt_file = os.path.join(output_directory, "SWMM.RPT")

            mymodel = self._load_swmm_model(inp_file, rpt_file)

            nodes_list = mymodel.nodes
            links_list = mymodel.links
            node_results = mymodel.node_results
            link_results = mymodel.link_results

            # self.dlg.start_cbo.addItems(sorted(nodes_list))
            # self.dlg.end_cbo.addItems(sorted(nodes_list))

            self.dlg.hours_lbl.setText("hrs")
            if self.units_switch == "0":
                self.dlg.max_flood_lbl.setText("cfs")
                self.dlg.total_flood_lbl.setText("mgd")
                self.dlg.max_pond_lbl.setText("ft")
            else:
                self.dlg.max_flood_lbl.setText("cms")
                self.dlg.total_flood_lbl.setText("mld")
                self.dlg.max_pond_lbl.setText("m")

            # Check if there are results available in output folders
            sd_results_dir = os.path.join(map_output_dir, "StormDrain")
            if os.path.isdir(sd_results_dir):
                nodes_dir = os.path.join(sd_results_dir, "Nodes")
                links_dir = os.path.join(sd_results_dir, "Links")

                # Use scandir (much faster than os.walk) and check only top-level entries
                def has_files(path):
                    return os.path.isdir(path) and any(entry.is_file() for entry in os.scandir(path))

                if has_files(nodes_dir) or has_files(links_dir):
                    self.dlg.see_nodes_results_btn.setEnabled(True)

            self._update_summary_fields()

            # Always land in the Summary tab after project folder selection
            self.dlg.tabs.setCurrentIndex(0)
            tabs.blockSignals(False)

    def run_map_creator(self):
        """
        Run method that performs all the real work
        """

        try:

            QApplication.setOverrideCursor(Qt.WaitCursor)

            # input & output directories
            flo2d_results_dir = self.dlg.flo2d_out_folder.filePath()
            map_output_dir = self.dlg.mapper_out_folder.filePath()
            # Ensure MapCrafter output folder exists
            if not map_output_dir:
                map_output_dir = os.path.join(flo2d_results_dir, "MapCrafter")
            os.makedirs(map_output_dir, exist_ok=True)
            self.crs = self.dlg.crsselector.crs()
            project_id = self.dlg.project_id.text()
            max_vector_scale = self.dlg.max_vector_scale_sb.value()
            min_vector_scale = self.dlg.min_vector_scale_sb.value()
            vector_scale = [max_vector_scale, min_vector_scale]

            if map_output_dir == "":
                map_output_dir = QgsProcessingUtils.tempFolder()

            if not self.check_checkboxes():
                QApplication.restoreOverrideCursor()  # restore cursor
                return

            with open(flo2d_results_dir + r"\CONT.DAT", "r") as file:
                lines = file.readlines()
                self.units_switch = lines[0].split()[3]
                elements = lines[2].split()
                mud_switch = elements[3]
                sed_switch = elements[4]
                file.close()

            """
            GROUPS CREATION
            """

            root = QgsProject.instance().layerTreeRoot()

            mapping_group_name = "FLO-2D MapCrafter"
            if root.findGroup(mapping_group_name):
                mapping_group = root.findGroup(mapping_group_name)
            else:
                mapping_group = root.insertGroup(0, mapping_group_name)

            """        
            FLOOD MAPS        
            """

            if mud_switch == "0" and sed_switch == "0":
                flood_rbs = {
                    r"TOPO.DAT": self.dlg.ge_cw_cb.isChecked(),
                    r"TOPO_SDElev.RGH": self.dlg.mge_cw_cb.isChecked(),
                    r"DEPTH.OUT": self.dlg.md_cw_cb.isChecked(),
                    r"VELFP.OUT": self.dlg.mv_cw_cb.isChecked(),
                    r"VELDIREC.OUT": self.dlg.mvv_cw_cb.isChecked(),
                    r"MAXWSELEV.OUT": self.dlg.mwse_cw_cb.isChecked(),
                    r"FINALDEP.OUT": self.dlg.fd_cw_cb.isChecked(),
                    r"FINALVEL.OUT": self.dlg.fv_cw_cb.isChecked(),
                    r"FINALDIR.OUT": self.dlg.fvv_cw_cb.isChecked(),
                    r"VEL_X_DEPTH.OUT": self.dlg.dv_cw_cb.isChecked(),
                    r"VEL_SQUARED_X_DEPTH.OUT": self.dlg.v2xd_cw_cb.isChecked(),
                    r"TIMEONEFT.OUT": self.dlg.t1ft_cw_cb.isChecked(),
                    r"TIMETWOFT.OUT": self.dlg.t2ft_cw_cb.isChecked(),
                    r"TIMETOPEAK.OUT": self.dlg.tmax_cw_cb.isChecked(),
                    r"DEPCH.OUT": self.dlg.cd_cw_cb.isChecked(),
                    r"VELOC.OUT": self.dlg.cv_cw_cb.isChecked(),
                    r"VELCHFINAL.OUT": self.dlg.fcv_cw_cb.isChecked(),
                    r"DEPCHFINAL.OUT": self.dlg.fcd_cw_cb.isChecked(),
                    r"LEVEEDEFIC.OUT": self.dlg.ld_cw_cb.isChecked(),
                    r"SPECENERGY.OUT": self.dlg.se_cw_cb.isChecked(),
                    r"STATICPRESS.OUT": self.dlg.sp_cw_cb.isChecked(),
                    r"IMPACT.OUT": self.dlg.if_cw_cb.isChecked(),
                    r"FINAL_WSE.DAT": self.dlg.fwse_cw_cb.isChecked(),
                }

                flood_maps = FloodMaps(self.iface, self.units_switch, vector_scale, self.toler_value)
                flood_maps.create_maps(
                    flood_rbs, flo2d_results_dir, map_output_dir, mapping_group, self.crs, project_id, sim_type=self._sim_type
                )

            """
            SEDIMENT MAPS
            """

            if mud_switch == "0" and sed_switch == "1":
                sediment_rbs = {
                    r"TOPO.DAT": self.dlg.ge_sd_cb.isChecked(),
                    r"TOPO_SDElev.RGH": self.dlg.mge_sd_cb.isChecked(),
                    r"DEPTH.OUT": self.dlg.md_sd_cb.isChecked(),
                    r"VELFP.OUT": self.dlg.mv_sd_cb.isChecked(),
                    r"VELDIREC.OUT": self.dlg.mvv_sd_cb.isChecked(),
                    r"MAXWSELEV.OUT": self.dlg.mwse_sd_cb.isChecked(),
                    r"FINALDEP.OUT": self.dlg.fd_sd_cb.isChecked(),
                    r"FINALVEL.OUT": self.dlg.fv_sd_cb.isChecked(),
                    r"FINALDIR.OUT": self.dlg.fvv_sd_cb.isChecked(),
                    r"VEL_X_DEPTH.OUT": self.dlg.dv_sd_cb.isChecked(),
                    r"VEL_SQUARED_X_DEPTH.OUT": self.dlg.v2xd_sd_cb.isChecked(),
                    r"TIMEONEFT.OUT": self.dlg.t1ft_sd_cb.isChecked(),
                    r"TIMETWOFT.OUT": self.dlg.t2ft_sd_cb.isChecked(),
                    r"TIMETOPEAK.OUT": self.dlg.tmax_sd_cb.isChecked(),
                    r"DEPCH.OUT": self.dlg.cd_sd_cb.isChecked(),
                    r"VELOC.OUT": self.dlg.cv_sd_cb.isChecked(),
                    r"VELCHFINAL.OUT": self.dlg.fcv_sd_cb.isChecked(),
                    r"DEPCHFINAL.OUT": self.dlg.fcd_sd_cb.isChecked(),
                    r"LEVEEDEFIC.OUT": self.dlg.ld_sd_cb.isChecked(),
                    r"SPECENERGY.OUT": self.dlg.se_sd_cb.isChecked(),
                    r"STATICPRESS.OUT": self.dlg.sp_sd_cb.isChecked(),
                    r"SEDFP.OUT": [
                        self.dlg.mdep_sd_cb.isChecked(),
                        self.dlg.msco_sd_cb.isChecked(),
                        self.dlg.fbd_sd_cb.isChecked()
                    ],
                    r"IMPACT.OUT": self.dlg.if_sd_cb.isChecked(),
                    r"FINAL_WSE.DAT": self.dlg.fwse_sd_cb.isChecked(),
                }

                sediment_maps = SedimentMaps(self.iface, self.units_switch, vector_scale, self.toler_value)
                sediment_maps.create_maps(
                    sediment_rbs, flo2d_results_dir, map_output_dir, mapping_group, self.crs, project_id, sim_type=self._sim_type
                )

            """"
            MUDFLOW MAPS
            """

            if mud_switch == "1" and sed_switch == "0":
                mudflow_rbs = {
                    r"TOPO.DAT": self.dlg.ge_mf_cb.isChecked(),
                    r"TOPO_SDElev.RGH": self.dlg.mge_mf_cb.isChecked(),
                    r"DEPTH.OUT": self.dlg.md_mf_cb.isChecked(),
                    r"VELFP.OUT": self.dlg.mv_mf_cb.isChecked(),
                    r"VELDIREC.OUT": self.dlg.mvv_mf_cb.isChecked(),
                    r"MAXWSELEV.OUT": self.dlg.mwse_mf_cb.isChecked(),
                    r"FINALDEP.OUT": self.dlg.fd_mf_cb.isChecked(),
                    r"FINALVEL.OUT": self.dlg.fv_mf_cb.isChecked(),
                    r"FINALDIR.OUT": self.dlg.fvv_mf_cb.isChecked(),
                    r"VEL_X_DEPTH.OUT": self.dlg.dv_mf_cb.isChecked(),
                    r"VEL_SQUARED_X_DEPTH.OUT": self.dlg.v2xd_mf_cb.isChecked(),
                    r"TIMEONEFT.OUT": self.dlg.t1ft_mf_cb.isChecked(),
                    r"TIMETWOFT.OUT": self.dlg.t2ft_mf_cb.isChecked(),
                    r"TIMETOPEAK.OUT": self.dlg.tmax_mf_cb.isChecked(),
                    r"DEPCH.OUT": self.dlg.cd_mf_cb.isChecked(),
                    r"VELOC.OUT": self.dlg.cv_mf_cb.isChecked(),
                    r"VELCHFINAL.OUT": self.dlg.fcv_mf_cb.isChecked(),
                    r"DEPCHFINAL.OUT": self.dlg.fcd_mf_cb.isChecked(),
                    r"LEVEEDEFIC.OUT": self.dlg.ld_mf_cb.isChecked(),
                    r"SPECENERGY.OUT": self.dlg.se_mf_cb.isChecked(),
                    r"STATICPRESS.OUT": self.dlg.sp_mf_cb.isChecked(),
                    r"CVFPMAX.OUT": self.dlg.ms_mf_cb.isChecked(),
                    r"FINALCVFP.OUT": self.dlg.fs_mf_cb.isChecked(),
                    r"IMPACT.OUT": self.dlg.if_mf_cb.isChecked(),
                    r"FINAL_WSE.DAT": self.dlg.fwse_mf_cb.isChecked(),
                }

                mudflow_maps = MudflowMaps(self.iface, self.units_switch, vector_scale, self.toler_value)
                mudflow_maps.create_maps(
                    mudflow_rbs, flo2d_results_dir, map_output_dir, mapping_group, self.crs, project_id, sim_type=self._sim_type
                )

            """"
            TWO-PHASE MAPS
            """

            if mud_switch == "2" and sed_switch == "0":
                twophase_rbs = {
                    r"TOPO.DAT": self.dlg.ge_tp_cb.isChecked(),
                    r"TOPO_SDElev.RGH": self.dlg.mge_tp_cb.isChecked(),
                    r"DEPTH.OUT": self.dlg.mfd_tp_cb.isChecked(),
                    r"DEPFPMAX_MUD.OUT": self.dlg.mmd_tp_cb.isChecked(),
                    r"DEPTHMAX_2PHASE_COMBINED.OUT": self.dlg.cmd_tp_cb.isChecked(),
                    r"VELFP.OUT": self.dlg.mfv_tp_cb.isChecked(),
                    r"VELFP_MUD.OUT": self.dlg.mmv_tp_cb.isChecked(),
                    r"VELDIREC.OUT": self.dlg.mfvv_tp_cb.isChecked(),
                    r"VELDIREC_MUD.OUT": self.dlg.mmvv_tp_cb.isChecked(),
                    r"CVFPMAX.OUT": self.dlg.mfsc_tp_cb.isChecked(),
                    r"CVFPMAX_MUD.OUT": self.dlg.mmsc_tp_cb.isChecked(),
                    # r"FINALCVFP.OUT": self.dlg.ffsc_tp_cb,
                    r"FINALCVFP_MUD.OUT": self.dlg.fmsc_tp_cb.isChecked(),
                    # r"MAXWSELEV.OUT": self.dlg.mwse_mf_cb,
                    r"FINALDEP.OUT": self.dlg.ffd_tp_cb.isChecked(),
                    r"FINALDEP_MUD.OUT": self.dlg.fmd_tp_cb.isChecked(),
                    r"FINALDIR.OUT": self.dlg.ffvv_tp_cb.isChecked(),
                    r"FINALDIR_MUD.OUT": self.dlg.fmvv_tp_cb.isChecked(),
                    r"FINALDEP_COMBO.OUT": self.dlg.fcd_tp_cb.isChecked(),
                    r"FINALVEL.OUT": self.dlg.ffv_tp_cb.isChecked(),
                    r"FINALVEL_MUD.OUT": self.dlg.fmv_tp_cb.isChecked(),
                    r"VEL_X_DEPTH.OUT": self.dlg.dv_tp_cb.isChecked(),
                    r"VEL_SQUARED_X_DEPTH.OUT": self.dlg.v2xd_tp_cb.isChecked(),
                    r"TIMEONEFT.OUT": self.dlg.t1ft_tp_cb.isChecked(),
                    r"TIMETWOFT.OUT": self.dlg.t2ft_tp_cb.isChecked(),
                    r"TIMETOPEAK.OUT": self.dlg.tmax_tp_cb.isChecked(),
                    r"DEPCH.OUT": self.dlg.mchd_tp_cb.isChecked(),
                    r"VELOC.OUT": self.dlg.mchv_tp_cb.isChecked(),
                    r"VELCHFINAL.OUT": self.dlg.fchv_tp_cb.isChecked(),
                    r"DEPCHFINAL.OUT": self.dlg.fchd_tp_cb.isChecked(),
                    r"LEVEEDEFIC.OUT": self.dlg.ld_tp_cb.isChecked(),
                    r"SPECENERGY.OUT": self.dlg.se_tp_cb.isChecked(),
                    r"STATICPRESS.OUT": self.dlg.sp_tp_cb.isChecked(),
                    r"IMPACT.OUT": self.dlg.if_tp_cb.isChecked(),
                    r"SEDFP.OUT": [
                        self.dlg.md_tp_cb.isChecked(),
                        self.dlg.ms_tp_cb.isChecked(),
                        self.dlg.fdb_tp_cb.isChecked()
                    ],
                    r"FP_BED_CHANGE_MUD.OUT": self.dlg.fdbmcd_tp_cb.isChecked(),
                    r"FINAL_WSE.DAT": self.dlg.fwse_tp_cb.isChecked(),
                }

                twophase_maps = TwophaseMaps(self.iface, self.units_switch, vector_scale, self.toler_value)
                twophase_maps.create_maps(
                    twophase_rbs, flo2d_results_dir, map_output_dir, mapping_group, self.crs, project_id, sim_type=self._sim_type
                )

            """
            HYDRODYNAMIC RISK MAPS
            """

            hazard_rbs = {
                "ARR": self.dlg.fh_australian_cb.isChecked(),
                "Austrian": self.dlg.fh_austrian_cb.isChecked(),
                "Swiss": [
                    self.dlg.fi_swiss_cb.isChecked(),
                    self.dlg.di_swiss_cb.isChecked()
                ],
                "UK": self.dlg.fh_uk_cb.isChecked(),
                "USBR": [
                    self.dlg.usbrh_hm_cb.isChecked(),
                    self.dlg.usbrm_hm_cb.isChecked(),
                    self.dlg.usbrv_hm_cb.isChecked(),
                    self.dlg.usbra_hm_cb.isChecked(),
                    self.dlg.usbrc_hm_cb.isChecked(),
                ],
                "FEMA": self.dlg.fema_hm_cb.isChecked()
            }

            at_least_one_checked = any(
                value if not isinstance(value, list) else any(value) for value in hazard_rbs.values())

            if at_least_one_checked:
                hazard_maps = HazardMaps(self.iface, self.units_switch, self.toler_value)
                hazard_maps.create_maps(
                    hazard_rbs, flo2d_results_dir, map_output_dir, mapping_group, self.crs, project_id
                )

            # remove empty groups
            groups = mapping_group.findGroups()
            for group in groups:
                subgroups = group.findGroups()
                for subgroup in subgroups:
                    all_subgrup_layers = subgroup.findLayers()
                    if len(all_subgrup_layers) == 0:
                        group.removeChildNode(subgroup)
                all_group_layers = group.findLayers()
                if len(all_group_layers) == 0:
                    mapping_group.removeChildNode(group)

            """
            STORM DRAIN PLOTS
            """

            storm_drain_rbs = {
                "Inflow": [self.dlg.inflow_chbox.isChecked()],
                "Flooding": [self.dlg.flooding_chbox.isChecked()],
                "Node Depth": [self.dlg.node_depth_chbox.isChecked()],
                "Head": [self.dlg.head_chbox.isChecked()],
                "Flow": [self.dlg.flow_chbox.isChecked()],
                "Velocity": [self.dlg.velocity_chbox.isChecked()],
                "Link Depth": [self.dlg.link_depth_chbox.isChecked()],
                "Percent Full": [self.dlg.percent_full_chbox.isChecked()],
                "Hours Flooded": [
                    self.dlg.hours_flooded_chbox.isChecked(),
                    self.dlg.hours_flooded_dsb.value()
                ],
                "Maximum Flooding": [
                    self.dlg.max_flood_chbox.isChecked(),
                    self.dlg.max_flood_dsb.value()
                ],
                "Total Flooding": [
                    self.dlg.total_flood_chbox.isChecked(),
                    self.dlg.total_flood_dsb.value()
                ],
                "Maximum Pond": [
                    self.dlg.max_pond_chbox.isChecked(),
                    self.dlg.max_pond_dsb.value()
                ],
                # "Profile": [
                #     self.dlg.plot_profile_chbox.isChecked(),
                #     self.dlg.start_cbo.currentText(),
                #     self.dlg.end_cbo.currentText()
                # ],
            }

            at_least_one_checked = any(
                value[0] if isinstance(value, list) and len(value) > 0 else value
                for value in storm_drain_rbs.values()
            )

            if at_least_one_checked:
                if project_id:
                    sd_output_dir = map_output_dir + rf"\StormDrain - {project_id}"
                else:
                    sd_output_dir = map_output_dir + rf"\StormDrain"
                if not os.path.exists(sd_output_dir):
                    os.makedirs(sd_output_dir)
                # Resolve swmm files
                inp_file = os.path.join(flo2d_results_dir, "swmm.inp")
                rpt_file = os.path.join(flo2d_results_dir, "swmm.rpt")
                if not os.path.isfile(inp_file): inp_file = os.path.join(flo2d_results_dir, "SWMM.INP")
                if not os.path.isfile(rpt_file): rpt_file = os.path.join(flo2d_results_dir, "SWMM.RPT")

                model = self._load_swmm_model(inp_file, rpt_file)

                # Give the cached model to StormDrainPlots so it never re-parses
                storm_drain_plots = StormDrainPlots(self.units_switch, self.iface, swmm_model=model)
                t0 = time.perf_counter()
                plots = storm_drain_plots.create_plots(storm_drain_rbs, flo2d_results_dir, sd_output_dir)
                if plots:
                    self.dlg.see_nodes_results_btn.setEnabled(True)
                t1 = time.perf_counter()
                storm_drain_plots.plot_graphics(storm_drain_rbs, flo2d_results_dir, sd_output_dir, self.crs.authid(),
                                                mapping_group)
                t2 = time.perf_counter()
                storm_drain_plots.storm_drain_profile(storm_drain_rbs, flo2d_results_dir, sd_output_dir, True)
                t3 = time.perf_counter()
                QgsMessageLog.logMessage(
                    f"SD timings: create_plots={t1 - t0:.2f}s, plot_graphics={t2 - t1:.2f}s, profile={t3 - t2:.2f}s",
                    'FLO-2D', Qgis.Info)

            QApplication.restoreOverrideCursor()
            msg_box = QMessageBox()
            msg_box.setIcon(QMessageBox.Information)
            msg_box.setWindowTitle("Mapping complete!")
            msg_box.setText("The selected maps were created!")
            msg_box.exec_()

        except Exception as e:
            QApplication.restoreOverrideCursor()
            self.iface.messageBar().pushMessage(
                "ERROR: Error while creating the maps! See log messages for more information.", level=Qgis.Critical,
                duration=5)
            QgsMessageLog.logMessage(str(e))

        finally:
            QApplication.restoreOverrideCursor()

    def see_storm_drain_profile(self):
        """
        Function to show the storm drain profile
        """
        storm_drain_plots = StormDrainPlots(self.units_switch, self.iface)
        flo2d_results_dir = self.dlg.flo2d_out_folder.filePath()
        map_output_dir = self.dlg.mapper_out_folder.filePath()
        project_id = self.dlg.project_id.text()
        if project_id:
            sd_output_dir = map_output_dir + rf"\StormDrain - {project_id}"
        else:
            sd_output_dir = map_output_dir + rf"\StormDrain"
        if not os.path.exists(sd_output_dir):
            os.makedirs(sd_output_dir)
        # storm_drain_rbs = {
        #     "Profile": [
        #         True,
        #         self.dlg.start_cbo.currentText(),
        #         self.dlg.end_cbo.currentText()
        #     ],
        # }
        # storm_drain_plots.storm_drain_profile(storm_drain_rbs, flo2d_results_dir, sd_output_dir)

    def see_nodes_results(self):
        """
        Function to open the results viewer
        """
        flo2d_results_dir = self.dlg.output_dir_le.text()
        sd_output_dir = os.path.join(flo2d_results_dir, "Maps", "StormDrain")

        # Define possible file names (lowercase / uppercase)
        inp_file = os.path.join(flo2d_results_dir, "swmm.inp")
        rpt_file = os.path.join(flo2d_results_dir, "swmm.rpt")
        INP_file = os.path.join(flo2d_results_dir, "SWMM.INP")
        RPT_file = os.path.join(flo2d_results_dir, "swmm.RPT")

        # Prefer lowercase, fallback to uppercase
        if not os.path.isfile(inp_file):
            inp_file = INP_file
        if not os.path.isfile(rpt_file):
            rpt_file = RPT_file

        # Parse SWMM model with lightweight parser
        mymodel = self._load_swmm_model(inp_file, rpt_file)
        nodes_list = mymodel.nodes
        links_list = mymodel.links
        node_results = mymodel.node_results
        link_results = mymodel.link_results

        # Get FLO-2D grid names for matching results
        nname_grid = StormDrainPlots(self.units_switch, self.iface).get_nname_grid(flo2d_results_dir)

        # Launch the results viewer
        sd_results_viewer = SDResultsViewer(
            sd_output_dir,
            nodes_list,
            links_list,
            nname_grid,
            node_results=node_results,
            link_results=link_results
        )
        sd_results_viewer.exec_()

    def set_raster_style(self, layer, style):
        """Define the raster styles"""
        colDic = {
            "white": "#ffffff",
            "lightblue": "#9ecae1",
            "blue": "#4292c6",
            "darkblue": "#08306b",
            "lightgreen": "#a1d99b",
            "green": "#41ab5d",
            "darkgreen": "#006d2c",
            "black": "#000000",
            "grey": "#808080",
            "red": "#FF0000",
            "yellow": "#FFFF00",
            "risk_red": "#FF0000",
            "risk_orange": "#FFC000",
            "risk_lightgreen": "#92D050",
            "risk_green": "#006600",
            "risk_lightblue": "#BDD6EE",
            "risk_blue": "#0033CC",
            "mud_lightbrown": "#be4d24",
            "mud_brown": "#752c12",
            "mud_darkbrown": "#2c0c00",
        }

        provider = layer.dataProvider()
        extent = layer.extent()

        script_directory = os.path.dirname(os.path.realpath(__file__))
        style_directory = script_directory + r"/raster_styles"

        # Hydrodynamic Risk
        if style == 2:
            layer.loadNamedStyle(style_directory + r"/hydro_risk.qml")
        elif style == 3:
            layer.loadNamedStyle(style_directory + r"/time.qml")
        # Other styles
        else:
            stats = provider.bandStatistics(1, QgsRasterBandStats.All, extent, 0)
            if stats.minimumValue <= 0.001:
                min = 0.001
            else:
                min = stats.minimumValue

            max = stats.maximumValue
            range = max - min
            add = range / 2
            interval = min + add
            valueList = [min, interval, max]

            dep_lst = [
                QgsColorRampShader.ColorRampItem(
                    valueList[0], QColor(colDic["lightblue"])
                ),
                QgsColorRampShader.ColorRampItem(valueList[1], QColor(colDic["blue"])),
                QgsColorRampShader.ColorRampItem(
                    valueList[2], QColor(colDic["darkblue"])
                ),
            ]

            vel_lst = [
                QgsColorRampShader.ColorRampItem(
                    valueList[0], QColor(colDic["lightgreen"])
                ),
                QgsColorRampShader.ColorRampItem(valueList[1], QColor(colDic["green"])),
                QgsColorRampShader.ColorRampItem(
                    valueList[2], QColor(colDic["darkgreen"])
                ),
            ]

            time_lst = [
                QgsColorRampShader.ColorRampItem(valueList[0], QColor(colDic["green"])),
                QgsColorRampShader.ColorRampItem(
                    valueList[1], QColor(colDic["yellow"])
                ),
                QgsColorRampShader.ColorRampItem(valueList[2], QColor(colDic["red"])),
            ]

            q_lst = [
                QgsColorRampShader.ColorRampItem(valueList[0], QColor(colDic["white"])),
                QgsColorRampShader.ColorRampItem(
                    valueList[1], QColor(colDic["lightblue"])
                ),
                QgsColorRampShader.ColorRampItem(valueList[2], QColor(colDic["blue"])),
            ]

            mud_lst = [
                QgsColorRampShader.ColorRampItem(
                    valueList[0], QColor(colDic["mud_lightbrown"])
                ),
                QgsColorRampShader.ColorRampItem(
                    valueList[1], QColor(colDic["mud_brown"])
                ),
                QgsColorRampShader.ColorRampItem(
                    valueList[2], QColor(colDic["mud_darkbrown"])
                ),
            ]

            style_dict = {
                0: dep_lst,
                1: vel_lst,
                5: mud_lst,
                3: time_lst,
                4: q_lst,
            }

            myRasterShader = QgsRasterShader()
            myColorRamp = QgsColorRampShader(minimumValue=min, maximumValue=max)

            myColorRamp.setColorRampItemList(style_dict[style])
            myColorRamp.setColorRampType(QgsColorRampShader.Interpolated)
            myColorRamp.setClip(True)

            myRasterShader.setRasterShaderFunction(myColorRamp)

            myPseudoRenderer = QgsSingleBandPseudoColorRenderer(
                layer.dataProvider(), layer.type(), myRasterShader
            )

            layer.setRenderer(myPseudoRenderer)

        layer.triggerRepaint()

    def set_vector_style(self, layer, style):
        """Define the vector styles"""

        script_directory = os.path.dirname(os.path.realpath(__file__))
        style_directory = script_directory + r"/vector_styles"

        # Extent red
        if style == 0:
            layer.loadNamedStyle(style_directory + r"/extent.qml")

        # Extent blue
        if style == 1:
            layer.loadNamedStyle(style_directory + r"/fluid_extent.qml")

        # Extent brown
        if style == 2:
            layer.loadNamedStyle(style_directory + r"/mud_extent.qml")

    def remove_layer(self, layer_name):
        """Function to remove layer name based on name"""
        for layer in QgsProject.instance().mapLayers().values():
            if layer.name() == layer_name:
                QgsProject.instance().removeMapLayers([layer.id()])

    def get_extent(self, raster, flood_extent_vector, name):
        """Function to get the extent of a raster layer"""
        vectorized = processing.run(
            "gdal:polygonize",
            {
                "INPUT": raster,
                "BAND": 1,
                "FIELD": "DN",
                "EIGHT_CONNECTEDNESS": False,
                "EXTRA": "",
                "OUTPUT": "TEMPORARY_OUTPUT",
            },
        )["OUTPUT"]

        processing.run(
            "native:dissolve",
            {
                "INPUT": vectorized,
                "FIELD": [],
                "SEPARATE_DISJOINT": False,
                "OUTPUT": flood_extent_vector,
            },
        )
        extent = QgsVectorLayer(flood_extent_vector, name)

        return extent

    def check_checkboxes(self):
        """Function to check if at least one map checkbox was checked"""

        checkboxes = self.dlg.tabs.findChildren(QtWidgets.QCheckBox)

        none_checked = not any(checkbox.isChecked() for checkbox in checkboxes)

        if none_checked:
            msg_box = QMessageBox()
            msg_box.setIcon(QMessageBox.Warning)
            msg_box.setWindowTitle("Warning")
            msg_box.setText("Check at least one map option!")
            msg_box.exec_()
            return False
        else:
            return True

    def run_open_layout(self):
        """Function to open the selected layout"""

        map_title = self.dlg.map_title_le.text()
        map_description = self.dlg.map_description.toPlainText()
        layer_extent = self.dlg.layer_extent_cb.currentLayer()

        lm = QgsProject.instance().layoutManager()
        l = QgsPrintLayout(QgsProject.instance())
        l.initializeDefaults()

        script_directory = os.path.dirname(os.path.realpath(__file__))
        template_directory = script_directory + r"/layout_templates"
        template_source = ""
        if self.dlg.a4_land.isChecked():
            template_source = template_directory + r"/FLO-2D A4 Landscape.qpt"
            layout_name = self.layout_exists("FLO-2D A4 Landscape")

        if self.dlg.a4_port.isChecked():
            template_source = template_directory + r"/FLO-2D A4 Portrait.qpt"
            layout_name = self.layout_exists("FLO-2D A4 Portrait")

        if self.dlg.a3_land.isChecked():
            template_source = template_directory + r"/FLO-2D A3 Landscape.qpt"
            layout_name = self.layout_exists("FLO-2D A3 Landscape")

        if self.dlg.a3_port.isChecked():
            template_source = template_directory + r"/FLO-2D A3 Portrait.qpt"
            layout_name = self.layout_exists("FLO-2D A3 Portrait")

        if template_source == "":
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText("Please, select a layout.")
            msg.exec_()
            return

        # template_source = template_directory + r"/FLO-2D A4 Landscape.qpt"

        template_file = open(template_source, "r+", encoding="utf-8")
        template_content = template_file.read()
        template_file.close()
        document = QDomDocument()
        document.setContent(template_content)
        context = QgsReadWriteContext()
        l.loadFromTemplate(document, context)

        l.setName(layout_name)

        # canvas = self.iface.mapCanvas()
        for item in l.items():
            if item.type() == 65639:  # Map
                item.zoomToExtent(layer_extent.extent())
            if item.type() == 65641:  # Label
                item.setText(item.text().replace("{{title}}", map_title))
                item.setText(item.text().replace("{{description}}", map_description))

        # Add layout to layout manager
        l.refresh()
        lm.addLayout(l)

        # Open and show the layout in designer
        # try:
        self.iface.openLayoutDesigner(l)
        # except:
        #     msg = QMessageBox()
        #     msg.setIcon(QMessageBox.Warning)
        #     msg.setText(self.tr(
        #         f'Error trying to open the layout ({l.name()}) returned errors.'
        #             ))
        #     msg.exec_()

    def layout_exists(self, layout_name):
        """Check if a layout already exists and return a correct name"""
        lm = QgsProject.instance().layoutManager()
        layouts = []
        n_layouts = 0
        for l in lm.layouts():
            layouts.append(l.name())
        if layout_name in layouts:
            n_layouts = sum(layout_name in s for s in layouts)

        if n_layouts == 0:
            return layout_name
        else:
            return layout_name + f" ({n_layouts})"

    def check_cw(self):
        """
        Function to check all available flood maps
        """

        flood_rbs = [
            self.dlg.ge_cw_cb,
            self.dlg.mge_cw_cb,
            self.dlg.md_cw_cb,
            self.dlg.mv_cw_cb,
            self.dlg.mwse_cw_cb,
            self.dlg.fd_cw_cb,
            self.dlg.fv_cw_cb,
            self.dlg.dv_cw_cb,
            self.dlg.v2xd_cw_cb,
            self.dlg.t1ft_cw_cb,
            self.dlg.t2ft_cw_cb,
            self.dlg.tmax_cw_cb,
            self.dlg.cd_cw_cb,
            self.dlg.cv_cw_cb,
            self.dlg.fcd_cw_cb,
            self.dlg.fcv_cw_cb,
            self.dlg.ld_cw_cb,
            self.dlg.se_cw_cb,
            self.dlg.sp_cw_cb,
            self.dlg.mvv_cw_cb,
            self.dlg.fvv_cw_cb,
            self.dlg.if_cw_cb,
            self.dlg.fwse_cw_cb,
        ]

        if self.dlg.check_cw_cb.isChecked():
            for cb in flood_rbs:
                if cb.isEnabled():
                    cb.setChecked(True)
                else:
                    cb.setChecked(False)
        else:
            for cb in flood_rbs:
                cb.setChecked(False)

    def check_sd(self):
        """
        Function to check all available sediment maps
        """
        sediment_rbs = [
            self.dlg.ge_sd_cb,
            self.dlg.mge_sd_cb,
            self.dlg.md_sd_cb,
            self.dlg.mv_sd_cb,
            self.dlg.mwse_sd_cb,
            self.dlg.fd_sd_cb,
            self.dlg.fv_sd_cb,
            self.dlg.dv_sd_cb,
            self.dlg.v2xd_sd_cb,
            self.dlg.t1ft_sd_cb,
            self.dlg.t2ft_sd_cb,
            self.dlg.tmax_sd_cb,
            self.dlg.cd_sd_cb,
            self.dlg.cv_sd_cb,
            self.dlg.fcv_sd_cb,
            self.dlg.fcd_sd_cb,
            self.dlg.ld_sd_cb,
            self.dlg.se_sd_cb,
            self.dlg.sp_sd_cb,
            self.dlg.mdep_sd_cb,
            self.dlg.msco_sd_cb,
            self.dlg.fbd_sd_cb,
            self.dlg.mvv_sd_cb,
            self.dlg.fvv_sd_cb,
            self.dlg.if_sd_cb,
            self.dlg.fwse_sd_cb,
        ]

        if self.dlg.check_sd_cb.isChecked():
            for cb in sediment_rbs:
                if cb.isEnabled():
                    cb.setChecked(True)
                else:
                    cb.setChecked(False)
        else:
            for cb in sediment_rbs:
                cb.setChecked(False)

    def check_storm_drain(self):
        """
        Function to check all storm drain plots
        """
        storm_drain_rbs = [
            self.dlg.inflow_chbox,
            self.dlg.flooding_chbox,
            self.dlg.node_depth_chbox,
            self.dlg.head_chbox,
            self.dlg.flow_chbox,
            self.dlg.velocity_chbox,
            self.dlg.link_depth_chbox,
            self.dlg.percent_full_chbox,
            self.dlg.hours_flooded_chbox,
            self.dlg.max_flood_chbox,
            self.dlg.total_flood_chbox,
            self.dlg.max_pond_chbox,
        ]

        if self.dlg.check_storm_drain_chbox.isChecked():
            for cb in storm_drain_rbs:
                if cb.isEnabled():
                    cb.setChecked(True)
                else:
                    cb.setChecked(False)
        else:
            for cb in storm_drain_rbs:
                cb.setChecked(False)

    def check_hm(self):
        """
        Function to check all available hazard maps
        """
        hazard_rbs = [
            self.dlg.fh_australian_cb,
            self.dlg.fh_austrian_cb,
            self.dlg.flo_hm_cb,
            self.dlg.fi_swiss_cb,
            self.dlg.di_swiss_cb,
            self.dlg.fh_uk_cb,
            self.dlg.usbrh_hm_cb,
            self.dlg.usbrm_hm_cb,
            self.dlg.usbrv_hm_cb,
            self.dlg.usbra_hm_cb,
            self.dlg.usbrc_hm_cb,
            self.dlg.fema_hm_cb,
        ]

        if self.dlg.check_hm_cb.isChecked():
            for cb in hazard_rbs:
                if cb.isEnabled():
                    cb.setChecked(True)
                else:
                    cb.setChecked(False)
        else:
            for cb in hazard_rbs:
                cb.setChecked(False)

    def check_mf(self):
        """
        Function to check all available mudflow maps
        """
        mudflow_rbs = [
            self.dlg.ge_mf_cb,
            self.dlg.mge_mf_cb,
            self.dlg.md_mf_cb,
            self.dlg.mv_mf_cb,
            self.dlg.mvv_mf_cb,
            self.dlg.mwse_mf_cb,
            self.dlg.fd_mf_cb,
            self.dlg.fv_mf_cb,
            self.dlg.fvv_mf_cb,
            self.dlg.dv_mf_cb,
            self.dlg.v2xd_mf_cb,
            self.dlg.t1ft_mf_cb,
            self.dlg.t2ft_mf_cb,
            self.dlg.tmax_mf_cb,
            self.dlg.cd_mf_cb,
            self.dlg.cv_mf_cb,
            self.dlg.fcd_mf_cb,
            self.dlg.fcv_mf_cb,
            self.dlg.ld_mf_cb,
            self.dlg.se_mf_cb,
            self.dlg.sp_mf_cb,
            self.dlg.ms_mf_cb,
            self.dlg.fs_mf_cb,
            self.dlg.if_mf_cb,
            self.dlg.fwse_mf_cb,
        ]

        if self.dlg.check_mf_cb.isChecked():
            for cb in mudflow_rbs:
                if cb.isEnabled():
                    cb.setChecked(True)
                else:
                    cb.setChecked(False)
        else:
            for cb in mudflow_rbs:
                cb.setChecked(False)

    def check_tp(self):
        """
        Function to check all available twophase maps
        """
        twophase_rbs = [
            self.dlg.ge_tp_cb,
            self.dlg.mge_tp_cb,
            self.dlg.mfd_tp_cb,
            self.dlg.mmd_tp_cb,
            self.dlg.cmd_tp_cb,
            self.dlg.mfv_tp_cb,
            self.dlg.mmv_tp_cb,
            self.dlg.mfsc_tp_cb,
            self.dlg.mmsc_tp_cb,
            # self.dlg.ffsc_tp_cb,
            self.dlg.fmsc_tp_cb,
            self.dlg.mwse_mf_cb,
            self.dlg.ffd_tp_cb,
            self.dlg.fmd_tp_cb,
            self.dlg.fcd_tp_cb,
            self.dlg.ffv_tp_cb,
            self.dlg.fwse_tp_cb,
            self.dlg.fmv_tp_cb,
            self.dlg.dv_tp_cb,
            self.dlg.v2xd_tp_cb,
            self.dlg.t1ft_tp_cb,
            self.dlg.t2ft_tp_cb,
            self.dlg.tmax_tp_cb,
            self.dlg.mchd_tp_cb,
            self.dlg.mchv_tp_cb,
            self.dlg.fchd_tp_cb,
            self.dlg.fchv_tp_cb,
            self.dlg.ld_tp_cb,
            self.dlg.se_tp_cb,
            self.dlg.sp_tp_cb,
            self.dlg.md_tp_cb,
            self.dlg.ms_tp_cb,
            self.dlg.fdb_tp_cb,
            self.dlg.fdbmcd_tp_cb,
            self.dlg.mfvv_tp_cb,
            self.dlg.ffvv_tp_cb,
            self.dlg.fmvv_tp_cb,
            self.dlg.mmvv_tp_cb,
            self.dlg.if_tp_cb,
        ]

        if self.dlg.check_tp_cb.isChecked():
            for cb in twophase_rbs:
                if cb.isEnabled():
                    cb.setChecked(True)
                else:
                    cb.setChecked(False)
        else:
            for cb in twophase_rbs:
                cb.setChecked(False)

    def collapse_all_groups(self):
        """
        Function to collapse all groups
        """
        cw_grps = [
            self.dlg.sc_cw_cgb,
            self.dlg.bv_cw_cgb,
            self.dlg.dv_cw_cgb,
            self.dlg.tv_cw_cgb,
            self.dlg.ch_cw_cgb,
            self.dlg.sv_cw_cgb,
            self.dlg.hp_cw_cgb,
        ]
        sd_grps = [
            self.dlg.sc_sd_cgb,
            self.dlg.bv_sd_cgb,
            self.dlg.dv_sd_cgb,
            self.dlg.tv_sd_cgb,
            self.dlg.ch_sd_cgb,
            self.dlg.sd_sd_cgb,
            self.dlg.sv_sd_cgb,
            self.dlg.hp_sd_cgb,
        ]
        md_grps = [
            self.dlg.sc_mf_cgb,
            self.dlg.bv_mf_cgb,
            self.dlg.dv_mf_cgb,
            self.dlg.tv_mf_cgb,
            self.dlg.ch_mf_cgb,
            self.dlg.mf_mf_cgb,
            self.dlg.sv_mf_cgb,
            self.dlg.hp_mf_cgb,
        ]
        tp_grps = [
            self.dlg.sc_tp_cgb,
            self.dlg.bv_tp_cgb,
            self.dlg.dv_tp_cgb,
            self.dlg.tv_tp_cgb,
            self.dlg.ch_tp_cgb,
            self.dlg.sv_tp_cgb,
            self.dlg.mv_tp_cgb,
            self.dlg.sdv_tp_cgb,
            self.dlg.tp_tp_cgb,
            self.dlg.hp_tp_cgb,
        ]
        hm_grps = [
            self.dlg.australian_hm_cgb,
            self.dlg.austrian_hm_cgb,
            self.dlg.flo_hm_cgb,
            self.dlg.swiss_hm_cgb,
            self.dlg.uk_hm_cgb,
            self.dlg.usbr_hm_cgb,
            self.dlg.fema_hz_cgb,
        ]
        storm_drain_grps = [
            self.dlg.nodes_cgb,
            self.dlg.links_cgb,
            # self.dlg.profile_plot_cgb,
            self.dlg.graphics_plot_cgb,
        ]

        if self.dlg.tab0.isEnabled():
            for grp in sd_grps:
                if grp.isEnabled():
                    grp.setCollapsed(True)
        if self.dlg.tab1.isEnabled():
            for grp in cw_grps:
                if grp.isEnabled():
                    grp.setCollapsed(True)
        if self.dlg.tab2.isEnabled():
            for grp in md_grps:
                if grp.isEnabled():
                    grp.setCollapsed(True)
        if self.dlg.tab3.isEnabled():
            for grp in tp_grps:
                if grp.isEnabled():
                    grp.setCollapsed(True)
        if self.dlg.tab5.isEnabled():
            for grp in hm_grps:
                if grp.isEnabled():
                    grp.setCollapsed(True)
        if self.dlg.tab.isEnabled():
            for grp in storm_drain_grps:
                if grp.isEnabled():
                    grp.setCollapsed(True)

    def expand_all_groups(self):
        """
        Function to expand all groups
        """
        cw_grps = [
            self.dlg.sc_cw_cgb,
            self.dlg.bv_cw_cgb,
            self.dlg.dv_cw_cgb,
            self.dlg.tv_cw_cgb,
            self.dlg.ch_cw_cgb,
            self.dlg.sv_cw_cgb,
            self.dlg.hp_cw_cgb,
        ]
        sd_grps = [
            self.dlg.sc_sd_cgb,
            self.dlg.bv_sd_cgb,
            self.dlg.dv_sd_cgb,
            self.dlg.tv_sd_cgb,
            self.dlg.ch_sd_cgb,
            self.dlg.sd_sd_cgb,
            self.dlg.sv_sd_cgb,
            self.dlg.hp_sd_cgb,
        ]
        md_grps = [
            self.dlg.sc_mf_cgb,
            self.dlg.bv_mf_cgb,
            self.dlg.dv_mf_cgb,
            self.dlg.tv_mf_cgb,
            self.dlg.ch_mf_cgb,
            self.dlg.mf_mf_cgb,
            self.dlg.sv_mf_cgb,
            self.dlg.hp_mf_cgb,
        ]
        tp_grps = [
            self.dlg.sc_tp_cgb,
            self.dlg.bv_tp_cgb,
            self.dlg.dv_tp_cgb,
            self.dlg.tv_tp_cgb,
            self.dlg.ch_tp_cgb,
            self.dlg.sv_tp_cgb,
            self.dlg.mv_tp_cgb,
            self.dlg.sdv_tp_cgb,
            self.dlg.tp_tp_cgb,
            self.dlg.hp_tp_cgb,
        ]
        hm_grps = [
            self.dlg.australian_hm_cgb,
            self.dlg.austrian_hm_cgb,
            self.dlg.flo_hm_cgb,
            self.dlg.swiss_hm_cgb,
            self.dlg.uk_hm_cgb,
            self.dlg.usbr_hm_cgb,
            self.dlg.fema_hz_cgb,
        ]
        storm_drain_grps = [
            self.dlg.nodes_cgb,
            self.dlg.links_cgb,
            # self.dlg.profile_plot_cgb,
            self.dlg.graphics_plot_cgb,
        ]

        if self.dlg.tab0.isEnabled():
            for grp in sd_grps:
                if grp.isEnabled():
                    grp.setCollapsed(False)
        if self.dlg.tab1.isEnabled():
            for grp in cw_grps:
                if grp.isEnabled():
                    grp.setCollapsed(False)
        if self.dlg.tab2.isEnabled():
            for grp in md_grps:
                if grp.isEnabled():
                    grp.setCollapsed(False)
        if self.dlg.tab3.isEnabled():
            for grp in tp_grps:
                if grp.isEnabled():
                    grp.setCollapsed(False)
        if self.dlg.tab5.isEnabled():
            for grp in hm_grps:
                if grp.isEnabled():
                    grp.setCollapsed(False)
        if self.dlg.tab.isEnabled():
            for grp in storm_drain_grps:
                if grp.isEnabled():
                    grp.setCollapsed(False)

    def clear_chboxes(self, *_):
        """
        Clear all QCheckBox widgets on all tabs whenever the tab changes.
        """
        # Iterate all pages in the QTabWidget
        for i in range(self.dlg.tabs.count()):
            page = self.dlg.tabs.widget(i)
            # Use QtWidgets.QCheckBox (matches how the UI is created in QGIS)
            for cb in page.findChildren(QtWidgets.QCheckBox):
                cb.setChecked(False)


