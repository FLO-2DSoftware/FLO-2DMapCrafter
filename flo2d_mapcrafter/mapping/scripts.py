# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FLO2DMapCrafter
                                 A QGIS plugin
 This plugin creates maps from FLO-2D output files.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-09-21
        git sha              : $Format:%H$
        copyright            : (C) 2023 by FLO-2D
        email                : contact@flo-2d.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os

import numpy as np
from PyQt5.QtGui import QColor, QIcon
from qgis._core import (
    QgsProject,
    QgsRasterLayer,
    QgsVectorLayer,
    QgsRasterBandStats,
    QgsColorRampShader,
    QgsRasterShader,
    QgsSingleBandPseudoColorRenderer,
    QgsMessageLog, QgsSvgMarkerSymbolLayer, QgsMarkerSymbol, QgsSymbol, QgsCentroidFillSymbolLayer, QgsFillSymbol,
    QgsRuleBasedRenderer, QgsGraduatedSymbolRenderer, QgsClassificationEqualInterval, QgsStyle,
    QgsClassificationQuantile, QgsCategorizedSymbolRenderer, QgsRendererCategory, QgsPointXY, QgsExpression,
    QgsExpressionContext, QgsExpressionContextUtils, QgsProperty, QgsPropertyCollection, QgsSymbolLayer,
    QgsSimpleMarkerSymbolLayer,
)
from osgeo import gdal

import processing


def read_ASCII(file_path, output_path, name, crs):
    """Read ASCII file and extract the required fields"""

    values = []
    cellSize_data = []
    with open(file_path, "r") as file:
        for line in file:
            line = line.strip()
            fields = line.split()
            if name.split()[0] == "GROUND_ELEVATION":
                x, y, value = (
                    float(fields[0]),
                    float(fields[1]),
                    float(fields[2]),
                )
                values.append((x, y, value))
                if len(cellSize_data) < 2:
                    cellSize_data.append((x, y))
            elif name.split()[0] == "MAXIMUM_DEPOSITION":
                cell, x, y, value = (
                    float(fields[0]),
                    float(fields[1]),
                    float(fields[2]),
                    float(fields[3]),
                )
                values.append((x, y, value))
                if len(cellSize_data) < 2:
                    cellSize_data.append((x, y))
            elif name.split()[0] == "MAXIMUM_SCOUR":
                cell, x, y, value = (
                    float(fields[0]),
                    float(fields[1]),
                    float(fields[2]),
                    float(fields[4]),
                )
                values.append((x, y, value))
                if len(cellSize_data) < 2:
                    cellSize_data.append((x, y))
            elif name.split()[0] == "FINAL_BED_DIFFERENCE":
                cell, x, y, value = (
                    float(fields[0]),
                    float(fields[1]),
                    float(fields[2]),
                    float(fields[5]),
                )
                values.append((x, y, value))
                if len(cellSize_data) < 2:
                    cellSize_data.append((x, y))
            else:
                if fields[0].isnumeric():
                    cell, x, y, value = (
                        float(fields[0]),
                        float(fields[1]),
                        float(fields[2]),
                        float(fields[3]),
                    )
                    values.append((x, y, value))
                    if len(cellSize_data) < 2:
                        cellSize_data.append((x, y))

    # Calculate the differences in X and Y coordinates
    dx = cellSize_data[1][0] - cellSize_data[0][0]
    dy = cellSize_data[1][1] - cellSize_data[0][1]

    if dx != 0:
        cellSize = int(abs(dx))
    if dy != 0:
        cellSize = int(abs(dy))

    # Get the extent and number of rows and columns
    min_x = min(point[0] for point in values)
    max_x = max(point[0] for point in values)
    min_y = min(point[1] for point in values)
    max_y = max(point[1] for point in values)
    num_cols = int((max_x - min_x) / cellSize) + 1
    num_rows = int((max_y - min_y) / cellSize) + 1

    # Convert the list of values to an array.
    raster_data = np.full((num_rows, num_cols), -9999, dtype=np.float32)
    for point in values:
        if point[2] != 0:
            col = int((point[0] - min_x) / cellSize)
            row = int((max_y - point[1]) / cellSize)
            raster_data[row, col] = point[2]

    # Initialize the raster
    driver = gdal.GetDriverByName("GTiff")
    raster = driver.Create(output_path, num_cols, num_rows, 1, gdal.GDT_Float32)
    raster.SetGeoTransform(
        (
            min_x - cellSize / 2,
            cellSize,
            0,
            max_y + cellSize / 2,
            0,
            -cellSize,
        )
    )
    raster.SetProjection(crs.toWkt())

    band = raster.GetRasterBand(1)
    band.SetNoDataValue(-9999)  # Set a no-data value if needed
    band.WriteArray(raster_data)

    raster.FlushCache()

    layer = QgsRasterLayer(output_path, name)

    return layer


def get_extent(raster, flood_extent_vector, name):
    """Function to get the extent of a raster layer"""
    vectorized = processing.run(
        "gdal:polygonize",
        {
            "INPUT": raster,
            "BAND": 1,
            "FIELD": "DN",
            "EIGHT_CONNECTEDNESS": False,
            "EXTRA": "",
            "OUTPUT": "TEMPORARY_OUTPUT",
        },
    )["OUTPUT"]

    processing.run(
        "native:dissolve",
        {
            "INPUT": vectorized,
            "FIELD": [],
            "SEPARATE_DISJOINT": False,
            "OUTPUT": flood_extent_vector,
        },
    )
    extent = QgsVectorLayer(flood_extent_vector, name)

    return extent


def set_icon(btn, icon_file):
    """
    Function to set the icon
    """
    parent_dir = os.path.dirname(os.path.abspath(__file__))
    idir = os.path.join(os.path.dirname(parent_dir), "img")
    btn.setIcon(QIcon(os.path.join(idir, icon_file)))


def set_raster_style(layer, style):
    """Define the raster styles"""
    colDic = {
        "white": "#ffffff",
        "lightblue": "#9ecae1",
        "blue": "#4292c6",
        "darkblue": "#08306b",
        "lightgreen": "#a1d99b",
        "green": "#41ab5d",
        "darkgreen": "#006d2c",
        "black": "#000000",
        "grey": "#808080",
        "red": "#FF0000",
        "yellow": "#FFFF00",
        "risk_red": "#FF0000",
        "risk_orange": "#FFC000",
        "risk_lightgreen": "#92D050",
        "risk_green": "#006600",
        "risk_lightblue": "#BDD6EE",
        "risk_blue": "#0033CC",
        "mud_lightbrown": "#be4d24",
        "mud_brown": "#752c12",
        "mud_darkbrown": "#2c0c00",
        "elev1": "#66cdaa",
        "elev2": "#ffff00",
        "elev3": "#008000",
        "elev4": "#ffa500",
        "elev5": "#8b0000",
        "elev6": "#a52a2a",
        "elev7": "#808080",
        "elev8": "#fffafa",
        "dv1": "#fde725",
        "dv2": "#20928c",
        "dv3": "#440154",
        "sed1": "#440154",
        "sed2": "#27808e",
        "sed3": "#fde725"
    }

    provider = layer.dataProvider()
    extent = layer.extent()

    script_directory = os.path.dirname(os.path.realpath(__file__))
    style_directory = script_directory[:-8] + r"\raster_styles"

    # Hydrodynamic Risk
    if style == 2:
        layer.loadNamedStyle(style_directory + r"\hydro_risk.qml")
    elif style == 3:
        layer.loadNamedStyle(style_directory + r"\timeoneft.qml")
    # Other styles
    else:
        stats = provider.bandStatistics(1, QgsRasterBandStats.All, extent, 0)
        if stats.minimumValue <= 0.001:
            min = 0.001
        else:
            min = stats.minimumValue

        max = stats.maximumValue
        range = max - min
        add = range / 2
        interval = min + add
        valueList = [min, interval, max]

        addGE = range / 8
        valueListGE = [
            min,
            min + addGE,
            min + 2 * addGE,
            min + 3 * addGE,
            min + 4 * addGE,
            min + 5 * addGE,
            min + 6 * addGE,
            max,
        ]

        dep_lst = [
            QgsColorRampShader.ColorRampItem(valueList[0], QColor(colDic["lightblue"])),
            QgsColorRampShader.ColorRampItem(valueList[1], QColor(colDic["blue"])),
            QgsColorRampShader.ColorRampItem(valueList[2], QColor(colDic["darkblue"])),
        ]

        vel_lst = [
            QgsColorRampShader.ColorRampItem(valueList[0], QColor(colDic["lightgreen"])),
            QgsColorRampShader.ColorRampItem(valueList[1], QColor(colDic["green"])),
            QgsColorRampShader.ColorRampItem(valueList[2], QColor(colDic["darkgreen"])),
        ]

        # time_lst = [
        #     QgsColorRampShader.ColorRampItem(valueList[0], QColor(colDic["green"])),
        #     QgsColorRampShader.ColorRampItem(valueList[1], QColor(colDic["yellow"])),
        #     QgsColorRampShader.ColorRampItem(valueList[2], QColor(colDic["red"])),
        # ]

        q_lst = [
            QgsColorRampShader.ColorRampItem(valueList[0], QColor(colDic["white"])),
            QgsColorRampShader.ColorRampItem(valueList[1], QColor(colDic["lightblue"])),
            QgsColorRampShader.ColorRampItem(valueList[2], QColor(colDic["blue"])),
        ]

        mud_lst = [
            QgsColorRampShader.ColorRampItem(valueList[0], QColor(colDic["mud_lightbrown"])),
            QgsColorRampShader.ColorRampItem(valueList[1], QColor(colDic["mud_brown"])),
            QgsColorRampShader.ColorRampItem(valueList[2], QColor(colDic["mud_darkbrown"])),
        ]

        ge_lst = [
            QgsColorRampShader.ColorRampItem(valueListGE[0], QColor(colDic["elev1"])),
            QgsColorRampShader.ColorRampItem(valueListGE[1], QColor(colDic["elev2"])),
            QgsColorRampShader.ColorRampItem(valueListGE[2], QColor(colDic["elev3"])),
            QgsColorRampShader.ColorRampItem(valueListGE[3], QColor(colDic["elev4"])),
            QgsColorRampShader.ColorRampItem(valueListGE[4], QColor(colDic["elev5"])),
            QgsColorRampShader.ColorRampItem(valueListGE[5], QColor(colDic["elev6"])),
            QgsColorRampShader.ColorRampItem(valueListGE[6], QColor(colDic["elev7"])),
            QgsColorRampShader.ColorRampItem(valueListGE[7], QColor(colDic["elev8"])),
        ]

        dv_lst = [
            QgsColorRampShader.ColorRampItem(valueList[0], QColor(colDic["dv1"])),
            QgsColorRampShader.ColorRampItem(valueList[1], QColor(colDic["dv2"])),
            QgsColorRampShader.ColorRampItem(valueList[2], QColor(colDic["dv3"])),
        ]

        sp_lst = [
            QgsColorRampShader.ColorRampItem(valueList[0], QColor(colDic["blue"])),
            QgsColorRampShader.ColorRampItem(valueList[1], QColor(colDic["yellow"])),
            QgsColorRampShader.ColorRampItem(valueList[2], QColor(colDic["red"])),
        ]

        se_lst = [
            QgsColorRampShader.ColorRampItem(valueList[0], QColor(colDic["green"])),
            QgsColorRampShader.ColorRampItem(valueList[1], QColor(colDic["yellow"])),
            QgsColorRampShader.ColorRampItem(valueList[2], QColor(colDic["red"])),
        ]

        sed_lst = [
            QgsColorRampShader.ColorRampItem(valueList[0], QColor(colDic["sed1"])),
            QgsColorRampShader.ColorRampItem(valueList[1], QColor(colDic["sed2"])),
            QgsColorRampShader.ColorRampItem(valueList[2], QColor(colDic["sed3"])),
        ]

        style_dict = {
            0: dep_lst,
            1: vel_lst,
            # 3: time_lst,
            4: q_lst,
            5: mud_lst,
            6: ge_lst,
            7: dv_lst,
            8: sp_lst,
            9: se_lst,
            10: sed_lst
        }

        myRasterShader = QgsRasterShader()
        myColorRamp = QgsColorRampShader(minimumValue=min, maximumValue=max)

        myColorRamp.setColorRampItemList(style_dict[style])
        myColorRamp.setColorRampType(QgsColorRampShader.Interpolated)
        myColorRamp.setClip(True)

        myRasterShader.setRasterShaderFunction(myColorRamp)

        myPseudoRenderer = QgsSingleBandPseudoColorRenderer(
            layer.dataProvider(), layer.type(), myRasterShader
        )

        layer.setRenderer(myPseudoRenderer)

    layer.triggerRepaint()


def remove_layer(layer_name):
    """Function to remove layer name based on name"""
    for layer in QgsProject.instance().mapLayers().values():
        if layer.name() == layer_name:
            QgsProject.instance().removeMapLayers([layer.id()])


def set_velocity_vector_style(layer_name):
    """
    Function to set the velocity vector style
    """
    vector_style_directory = os.path.dirname(os.path.realpath(__file__))[:-8] + r"\vector_styles"

    svg_symbol_layer = QgsSvgMarkerSymbolLayer(vector_style_directory + r"\Arrow_06.svg")

    svg_symbol_layer.setDataDefinedProperty(QgsSymbolLayer.PropertyAngle,
                                            QgsProperty().fromField("Direction"))
    svg_symbol_layer.setDataDefinedProperty(QgsSymbolLayer.PropertyHeight,
                                            QgsProperty().fromField("Velocity"))
    svg_symbol_layer.setDataDefinedProperty(QgsSymbolLayer.PropertyWidth,
                                            QgsProperty().fromValue(4, True))

    # Create a symbol using the SVGMarker layer
    symbol = QgsSymbol.defaultSymbol(layer_name.geometryType())  # Assuming your layer is a point layer
    symbol.changeSymbolLayer(0, svg_symbol_layer)

    # Create a graduated symbol renderer
    renderer = QgsGraduatedSymbolRenderer()
    renderer.setClassAttribute("Velocity")

    # Set up the color ramp and classification
    default_style = QgsStyle().defaultStyle()
    color_ramp = default_style.colorRamp("Turbo")
    n_classes = 10
    classification = QgsClassificationQuantile()

    # Update classes and color ramp
    renderer.updateClasses(layer_name, n_classes)
    renderer.updateColorRamp(color_ramp)
    renderer.setClassificationMethod(classification)

    # Set the symbol for the renderer
    renderer.setSourceSymbol(symbol)
    renderer.updateClasses(layer_name, n_classes)

    # Set the renderer to the layer
    layer_name.setRenderer(renderer)

    # Refresh the layer to apply the changes
    layer_name.triggerRepaint()
