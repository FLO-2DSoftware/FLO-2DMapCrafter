# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FLO2DMapCrafter
                                 A QGIS plugin
 This plugin creates maps from FLO-2D output files.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-09-21
        git sha              : $Format:%H$
        copyright            : (C) 2023 by FLO-2D
        email                : contact@flo-2d.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os, processing
from functools import partial
from qgis.PyQt.QtWidgets import QProgressDialog, QApplication
from PyQt5.QtCore import QMetaType, QVariant, Qt
from qgis._core import QgsProject, QgsVectorLayer, QgsField, QgsFeature, QgsPointXY, QgsGeometry, QgsVectorFileWriter, \
    QgsMessageLog

from flo2d_mapcrafter.mapping.check_data import check_project_id, check_mapping_group, check_raster_file, \
    check_vector_file
from flo2d_mapcrafter.mapping.scripts import read_ASCII, set_raster_style, set_velocity_vector_style


class TwophaseMaps:

    def __init__(self, iface, units_switch, vector_scale, toler_value):
        """
        Class constructor
        :param units_switch: 0 english 1 metric
        """
        self.iface = iface
        self.units_switch = units_switch
        self.max_vector_scale = vector_scale[0]
        self.min_vector_scale = vector_scale[1]
        self.toler_value = toler_value

    # Helper 1 for progress bar
    def _make_progress(self, text: str, maximum: int) -> QProgressDialog:
        dlg = QProgressDialog(text, "Cancel", 0, max(1, int(maximum)), self.iface.mainWindow())
        dlg.setWindowTitle("QGIS3")
        dlg.setWindowModality(Qt.WindowModal)
        dlg.setMinimumDuration(0)
        dlg.setAutoClose(True)
        dlg.setAutoReset(True)
        dlg.setValue(0)
        return dlg

    # Helper 2 for progress bar
    def _tick(self, dlg: QProgressDialog, label: str):
        if dlg.wasCanceled():
            raise KeyboardInterrupt
        dlg.setLabelText(label)
        dlg.setValue(dlg.value() + 1)
        QApplication.processEvents()

    def check_twophase_files(self, output_dir):
        """
        Function to check the two-phase files and return a dictionary with the available maps
        """

        twophase_files = {
            r"TOPO.DAT": None,
            r"DEPTH.OUT": None,
            r"DEPFPMAX_MUD.OUT": None,
            r"DEPTHMAX_2PHASE_COMBINED.OUT": None,
            r"VELFP.OUT": None,
            r"VELFP_MUD.OUT": None,
            r"VELDIREC.OUT": None,
            r"VELDIREC_MUD.OUT": None,
            r"CVFPMAX.OUT": None,
            r"CVFPMAX_MUD.OUT": None,
            # r"FINALCVFP.OUT": None,
            r"FINALCVFP_MUD.OUT": None,
            # r"MAXWSELEV.OUT": None,
            r"FINALDEP.OUT": None,
            r"FINALDEP_MUD.OUT": None,
            r"FINALDEP_COMBO.OUT": None,
            r"FINALVEL.OUT": None,
            r"FINALVEL_MUD.OUT": None,
            r"FINALDIR.OUT": None,
            r"FINALDIR_MUD.OUT": None,
            r"VEL_X_DEPTH.OUT": None,
            r"TIMEONEFT.OUT": None,
            r"TIMETWOFT.OUT": None,
            r"TIMETOPEAK.OUT": None,
            r"DEPCH.OUT": None,
            r"VELCHFINAL.OUT": None,
            r"VELOC.OUT": None,
            r"DEPCHFINAL.OUT": None,
            r"LEVEEDEFIC.OUT": None,
            r"SPECENERGY.OUT": None,
            r"STATICPRESS.OUT": None,
            r"IMPACT.OUT": None,
            r"SEDFP.OUT": False,
        }

        files = os.listdir(output_dir)
        for file in files:
            for key, value in twophase_files.items():
                if file.startswith(key):
                    twophase_files[key] = True

        return twophase_files

    def create_maps(self, twophase_rbs, flo2d_results_dir, map_output_dir, mapping_group, crs, project_id):
        """
        Function to create the maps
        """
        total_steps = sum(1 for _, v in twophase_rbs.items() if v)

        dlg = self._make_progress("Preparing...", max(1, total_steps))

        try:
            # ----------------------- Groups ----------------------------

            mapping_group_name = check_project_id("Two-phase Maps", project_id)
            mapping_group = check_mapping_group(mapping_group_name, mapping_group)

            vector_style_directory = os.path.dirname(os.path.realpath(__file__))[:-8] + r"\vector_styles"
            raster_style_directory = os.path.dirname(os.path.realpath(__file__))[:-8] + r"\raster_styles"

            # Site Characteristics
            sc_group_name = "Site Characteristics"
            if mapping_group.findGroup(sc_group_name):
                sc_group = mapping_group.findGroup(sc_group_name)
            else:
                sc_group = mapping_group.insertGroup(0, sc_group_name)

            # Basic
            bv_group_name = "Basic"
            if mapping_group.findGroup(bv_group_name):
                bv_group = mapping_group.findGroup(bv_group_name)
            else:
                bv_group = mapping_group.insertGroup(0, bv_group_name)

            # Derived
            dv_group_name = "Derived"
            if mapping_group.findGroup(dv_group_name):
                dv_group = mapping_group.findGroup(dv_group_name)
            else:
                dv_group = mapping_group.insertGroup(0, dv_group_name)

            # Derived
            tv_group_name = "Time"
            if mapping_group.findGroup(tv_group_name):
                tv_group = mapping_group.findGroup(tv_group_name)
            else:
                tv_group = mapping_group.insertGroup(0, tv_group_name)

            # Channel
            cv_group_name = "Channel"
            if mapping_group.findGroup(cv_group_name):
                cv_group = mapping_group.findGroup(cv_group_name)
            else:
                cv_group = mapping_group.insertGroup(0, cv_group_name)

            # Mudflow
            md_group_name = "Mudflow"
            if mapping_group.findGroup(md_group_name):
                md_group = mapping_group.findGroup(md_group_name)
            else:
                md_group = mapping_group.insertGroup(0, md_group_name)

            # Sediment
            sd_group_name = "Sediment"
            if mapping_group.findGroup(sd_group_name):
                sd_group = mapping_group.findGroup(sd_group_name)
            else:
                sd_group = mapping_group.insertGroup(0, sd_group_name)

            # Structures
            sv_group_name = "Structures"
            if mapping_group.findGroup(sv_group_name):
                sv_group = mapping_group.findGroup(sv_group_name)
            else:
                sv_group = mapping_group.insertGroup(0, sv_group_name)

            # Hydraulics
            hv_group_name = "Hydraulics"
            if mapping_group.findGroup(hv_group_name):
                hv_group = mapping_group.findGroup(hv_group_name)
            else:
                hv_group = mapping_group.insertGroup(0, hv_group_name)

            # Ground elevation
            if twophase_rbs.get(r"TOPO.DAT"):
                name = check_project_id("GROUND_ELEVATION", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\TOPO.DAT"
                self.process_maps(name, raster, file, crs, sc_group, 6)
                self._tick(dlg, "Ground elevation")

            # Maximum Flood Depth
            if twophase_rbs.get(r"DEPTH.OUT"):
                name = check_project_id("MAXIMUM_FLOOD_DEPTH", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\DEPTH.OUT"
                self.process_maps(name, raster, file, crs, bv_group, 0)
                self._tick(dlg, "Maximum Flood Depth")

            # Maximum Mudflow Depth
            if twophase_rbs.get(r"DEPFPMAX_MUD.OUT"):
                name = check_project_id("MAXIMUM_MUDFLOW_DEPTH", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\DEPFPMAX_MUD.OUT"
                self.process_maps(name, raster, file, crs, md_group, 5)
                self._tick(dlg, "Maximum Mudflow Depth")

            # Maximum Combined Depth
            if twophase_rbs.get(r"DEPTHMAX_2PHASE_COMBINED.OUT"):
                name = check_project_id("MAXIMUM_COMBINED_DEPTH", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\DEPTHMAX_2PHASE_COMBINED.OUT"
                self.process_maps(name, raster, file, crs, bv_group, 5)
                self._tick(dlg, "Maximum Combined Depth")

            # Maximum Flood Velocity
            if twophase_rbs.get(r"VELFP.OUT"):
                name = check_project_id("MAXIMUM_FLOOD_VELOCITY", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\VELFP.OUT"
                self.process_maps(name, raster, file, crs, bv_group, 1)
                self._tick(dlg, "Maximum Flood Velocity")

            # Maximum Mudflow Velocity
            if twophase_rbs.get(r"VELFP_MUD.OUT"):
                name = check_project_id("MAXIMUM_MUDFLOW_VELOCITY", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\VELFP_MUD.OUT"
                self.process_maps(name, raster, file, crs, md_group, 1)
                self._tick(dlg, "Maximum Mudflow Velocity")

            # Maximum Flood Sediment Concentration
            if twophase_rbs.get(r"CVFPMAX.OUT"):
                name = check_project_id("MAXIMUM_FLOOD_SEDIMENT_CONCENTRATION", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\CVFPMAX.OUT"
                self.process_maps(name, raster, file, crs, bv_group, 10)
                self._tick(dlg, "Maximum Flood Sediment Concentration")

            # Maximum Mudflow Sediment Concentration
            if twophase_rbs.get(r"CVFPMAX_MUD.OUT"):
                name = check_project_id("MAXIMUM_MUDFLOW_SEDIMENT_CONCENTRATION", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\CVFPMAX_MUD.OUT"
                self.process_maps(name, raster, file, crs, md_group, 10)
                self._tick(dlg, "Maximum Mudflow Sediment Concentration")

            # Final Flood Depth
            if twophase_rbs.get(r"FINALDEP.OUT"):
                name = check_project_id("FINAL_FLOOD_DEPTH", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\FINALDEP.OUT"
                self.process_maps(name, raster, file, crs, bv_group, 0)
                self._tick(dlg, "Final Flood Depth")

            # Final Mudflow Depth
            if twophase_rbs.get(r"FINALDEP_MUD.OUT"):
                name = check_project_id("FINAL_MUDFLOW_DEPTH", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\FINALDEP_MUD.OUT"
                self.process_maps(name, raster, file, crs, md_group, 5)
                self._tick(dlg, "Final Mudflow Depth")

            # Final Combined Depth
            if twophase_rbs.get(r"FINALDEP_COMBO.OUT"):
                name = check_project_id("FINAL_COMBINED_DEPTH", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\FINALDEP_COMBO.OUT"
                self.process_maps(name, raster, file, crs, bv_group, 5)
                self._tick(dlg, "Final Combined Depth")

            # Final Flood Velocity
            if twophase_rbs.get(r"FINALVEL.OUT"):
                name = check_project_id("FINAL_FLOOD_VELOCITY", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\FINALVEL.OUT"
                self.process_maps(name, raster, file, crs, bv_group, 1)
                self._tick(dlg, "Final Flood Velocity")

            # Final Mudflow Velocity
            if twophase_rbs.get(r"FINALVEL_MUD.OUT"):
                name = check_project_id("FINAL_MUDFLOW_VELOCITY", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\FINALVEL_MUD.OUT"
                self.process_maps(name, raster, file, crs, md_group, 1)
                self._tick(dlg, "Final Mudflow Velocity")

            # Final Mudflow Sediment Concentration
            if twophase_rbs.get(r"FINALCVFP_MUD.OUT"):
                name = check_project_id("FINAL_MUDFLOW_SEDIMENT_CONCENTRATION", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\FINALCVFP_MUD.OUT"
                self.process_maps(name, raster, file, crs, md_group, 10)
                self._tick(dlg, "Final Mudflow Sediment Concentration")

            # Depth x Velocity
            if twophase_rbs.get(r"VEL_X_DEPTH.OUT"):
                name = check_project_id("DEPTH_X_VELOCITY", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\VEL_X_DEPTH.OUT"
                self.process_maps(name, raster, file, crs, dv_group, 7)
                self._tick(dlg, "Depth x Velocity")

            # Time to One ft
            if twophase_rbs.get(r"TIMEONEFT.OUT"):
                name = check_project_id("TIME_ONE_FT", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\TIMEONEFT.OUT"
                self.process_maps(name, raster, file, crs, tv_group, 3)
                self._tick(dlg, "Time to One ft")

            # Time to two ft
            if twophase_rbs.get(r"TIMETWOFT.OUT"):
                name = check_project_id("TIME_TWO_FT", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\TIMETWOFT.OUT"
                self.process_maps(name, raster, file, crs, tv_group, 3)
                self._tick(dlg, "Time to One ft")

            # Time to peak
            if twophase_rbs.get(r"TIMETOPEAK.OUT"):
                name = check_project_id("TIME_TO_MAX", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\TIMETOPEAK.OUT"
                self.process_maps(name, raster, file, crs, tv_group, 3)
                self._tick(dlg, "TTime to Two ft")

            # Static Pressure
            if twophase_rbs.get(r"STATICPRESS.OUT"):
                name = check_project_id("STATIC_PRESSURE", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\STATICPRESS.OUT"
                self.process_maps(name, raster, file, crs, hv_group, 8)
                self._tick(dlg, "Static Pressure")

            # Sepecific Energy
            if twophase_rbs.get(r"SPECENERGY.OUT"):
                name = check_project_id("SPECIFIC_ENERGY", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\SPECENERGY.OUT"
                self.process_maps(name, raster, file, crs, hv_group, 9)
                self._tick(dlg, "Sepecific Energy")

            # Maximum channel depth
            if twophase_rbs.get(r"DEPCH.OUT"):
                name = check_project_id("MAXIMUM_CHANNEL_DEPTH", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\DEPCH.OUT"
                self.process_maps(name, raster, file, crs, cv_group, 5)
                self._tick(dlg, "Maximum Channel Depth")

            # Final channel depth
            if twophase_rbs.get(r"DEPCHFINAL.OUT"):
                name = check_project_id("FINAL_CHANNEL_DEPTH", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\DEPCHFINAL.OUT"
                self.process_maps(name, raster, file, crs, cv_group, 5)
                self._tick(dlg, "Final Channel Depth")

            # Maximum channel velocity
            if twophase_rbs.get(r"VELOC.OUT"):
                name = check_project_id("MAXIMUM_CHANNEL_VELOCITY", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\VELOC.OUT"
                self.process_maps(name, raster, file, crs, cv_group, 1)
                self._tick(dlg, "Maximum Channel Velocity")

            # Final channel velocity
            if twophase_rbs.get(r"VELCHFINAL.OUT"):
                name = check_project_id("FINAL_CHANNEL_VELOCITY", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\VELCHFINAL.OUT"
                self.process_maps(name, raster, file, crs, cv_group, 1)
                self._tick(dlg, "Final Channel Velocity")

            # Levee Deficit
            if twophase_rbs.get(r"LEVEEDEFIC.OUT"):
                name = check_project_id("LEVEE_DEFICIT", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\LEVEEDEFIC.OUT"
                self.process_maps(name, raster, file, crs, sv_group, 11)
                self._tick(dlg, "Levee Deficit")

            # Maximum Velocity Vector
            if twophase_rbs.get(r"VELDIREC.OUT"):
                name = check_project_id("MAXIMUM_FLOOD_VELOCITY_VECTORS", project_id)
                name, vector = check_vector_file(name, map_output_dir)
                value_file = flo2d_results_dir + r"\VELFP.OUT"
                direction_file = flo2d_results_dir + r"\VELDIREC.OUT"
                self.process_vectors(name, vector, value_file, direction_file, crs, bv_group, self.max_vector_scale)
                self._tick(dlg, "Maximum Velocity Vector")

            # Final Velocity Vector
            if twophase_rbs.get(r"FINALDIR.OUT"):
                name = check_project_id("FINAL_FLOOD_VELOCITY_VECTORS", project_id)
                name, vector = check_vector_file(name, map_output_dir)
                value_file = flo2d_results_dir + r"\FINALVEL.OUT"
                direction_file = flo2d_results_dir + r"\FINALDIR.OUT"
                self.process_vectors(name, vector, value_file, direction_file, crs, bv_group, self.min_vector_scale)
                self._tick(dlg, "Final Velocity Vector")

            # Maximum Velocity Vector
            if twophase_rbs.get(r"VELDIREC_MUD.OUT"):
                name = check_project_id("MAXIMUM_MUDFLOW_VELOCITY_VECTORS", project_id)
                name, vector = check_vector_file(name, map_output_dir)
                value_file = flo2d_results_dir + r"\VELFP_MUD.OUT"
                direction_file = flo2d_results_dir + r"\VELDIREC_MUD.OUT"
                self.process_vectors(name, vector, value_file, direction_file, crs, bv_group, self.max_vector_scale)
                self._tick(dlg, "Maximum Velocity Vector")

            # Final Velocity Vector
            if twophase_rbs.get(r"FINALDIR_MUD.OUT"):
                name = check_project_id("FINAL_MUDFLOW_VELOCITY_VECTORS", project_id)
                name, vector = check_vector_file(name, map_output_dir)
                value_file = flo2d_results_dir + r"\FINALVEL_MUD.OUT"
                direction_file = flo2d_results_dir + r"\FINALDIR_MUD.OUT"
                self.process_vectors(name, vector, value_file, direction_file, crs, bv_group, self.min_vector_scale)
                self._tick(dlg, "Final Velocity Vector")

            # Impact Force
            if twophase_rbs.get(r"IMPACT.OUT"):
                name = check_project_id("IMPACT_FORCE", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\IMPACT.OUT"
                self.process_maps(name, raster, file, crs, hv_group, 1)
                self._tick(dlg, "Impact Force")

            # Maximum Deposition
            sedfp_maps = twophase_rbs.get(r"SEDFP.OUT")
            if sedfp_maps[0]:
                name = check_project_id("MAXIMUM_DEPOSITION", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\SEDFP.OUT"
                self.process_maps(name, raster, file, crs, sd_group, 12)
                self._tick(dlg, "Maximum Deposition")

            # Maximum Scour
            if sedfp_maps[1]:
                name = check_project_id("MAXIMUM_SCOUR", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\SEDFP.OUT"
                self.process_maps(name, raster, file, crs, sd_group, 13)
                self._tick(dlg, "Maximum Scour")

            # Final Bed Difference
            if sedfp_maps[2]:
                name = check_project_id("FINAL_BED_DIFFERENCE", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file = flo2d_results_dir + r"\SEDFP.OUT"
                self.process_maps(name, raster, file, crs, sd_group, 14)
                self._tick(dlg, "Final Bed Difference")

            # Final Bed Difference + Mudflow Cessation Depth
            if twophase_rbs.get(r"FP_BED_CHANGE_MUD.OUT"):
                name = check_project_id("FP_BED_CHANGE_MUD", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                file1 = flo2d_results_dir + r"\FINALDEP_MUD.OUT"
                file2 = flo2d_results_dir + r"\SEDFP.OUT"
                file3 = flo2d_results_dir + r"\FINALVEL_MUD.OUT"
                self.process_maps(name, raster, [file1, file2, file3], crs, sd_group, 14)
                self._tick(dlg, "Final Bed Difference + Mudflow Cessation Depth")

            # Uncheck and Collapse the layers added
            allLayers = mapping_group.findLayers()
            for layer in allLayers:
                if not layer.name().split()[0] == "GROUND_ELEVATION":
                    lyr = QgsProject.instance().layerTreeRoot().findLayer(layer.layerId())
                    lyr.setItemVisibilityChecked(False)
                    lyr.setExpanded(False)

        except KeyboardInterrupt:
            # user cancelled
            return
        finally:
            dlg.close()

    def process_maps(self, name, raster, file, crs, mapping_group, style):
        """
        Function to process the maps
        """

        # Combine the files and create a new OUT file
        if isinstance(file, list) and len(file) == 3:
            combined_file = os.path.join(os.path.dirname(file[0]), "COMBINED.OUT")
            combined_list = []

            # Open both files and process them line by line
            with open(file[0], 'r') as f1, open(file[1], 'r') as f2, open(file[2], 'r') as f3:
                for line1, line2, line3 in zip(f1, f2, f3):
                    line1_parts = line1.split()
                    line2_parts = line2.split()
                    line3_parts = line3.split()

                    cell = line1_parts[0]
                    x = line2_parts[1]
                    y = line2_parts[2]
                    value1 = float(line1_parts[3])
                    value2 = float(line2_parts[5])
                    value3 = float(line3_parts[3])
                    if value3 <= 0.02:
                        value = value1 + value2
                        if abs(value) < 0.01:
                            value = 0
                    else:
                        value = 0

                    combined_list.append((cell, x, y, value))

            # Write the combined data to the output file
            with open(combined_file, 'w') as cf:
                for item in combined_list:
                    cf.write(f"{item[0]} {item[1]} {item[2]} {item[3]}\n")

            file = combined_file

        raster_processed = read_ASCII(
            file, raster, name, crs
        )

        if raster_processed:
            QgsProject.instance().addMapLayer(raster_processed, False)
            set_raster_style(raster_processed, style, self.toler_value)

            mapping_group.insertLayer(0, raster_processed)

    def process_vectors(self, name, shapefile, value_file, direction_file, crs, mapping_group, vector_scale):
        """
        Function to create vector maps
        """
        # Read VELFP.OUT file
        with open(value_file, 'r') as f1:
            vel_fp_lines = f1.readlines()

        # Read VELDIREC.OUT file
        with open(direction_file, 'r') as f2:
            vel_direc_lines = f2.readlines()

        # Combine data based on IDs
        combined_lines = []
        for vel_fp_line, vel_direc_line in zip(vel_fp_lines, vel_direc_lines):
            vel_fp_data = vel_fp_line.split()
            vel_direc_data = vel_direc_line.split()

            if vel_fp_data and vel_direc_data:
                combined_line = f"{vel_fp_data[0]} {vel_fp_data[1]} {vel_fp_data[2]}  {vel_fp_data[3]} {vel_direc_data[1]}\n"
                combined_lines.append(combined_line)

        # Create a temporary memory layer
        vl = QgsVectorLayer(f"Point?crs={crs.authid()}&index=yes", name, 'memory')
        pr = vl.dataProvider()

        # Add fields to the layer
        vl.startEditing()
        try:
            pr.addAttributes([
                QgsField('ID', QMetaType.Type.Int),
                QgsField('Velocity', QMetaType.Type.Double),
                QgsField('Direction', QMetaType.Type.Int)
            ])
        except:
            pr.addAttributes([
                QgsField('ID', QVariant.Int),
                QgsField('Velocity', QVariant.Double),
                QgsField('Direction', QVariant.Int)
            ])
        vl.updateFields()
        vl.commitChanges()

        for line in combined_lines:
            parts = line.split()
            x, y, velocity, direction = float(parts[1]), float(parts[2]), float(parts[3]), int(parts[4])
            if velocity != 0:
                feature = QgsFeature()
                feature.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(x, y)))
                feature.setAttributes([int(parts[0]), velocity, self.dir_to_angle(direction)])
                pr.addFeature(feature)

        # Update the layer's extent
        vl.updateExtents()

        # Save the shapefile
        options = QgsVectorFileWriter.SaveVectorOptions()
        options.driverName = "ESRI Shapefile"
        options.layerName = name
        options.fileEncoding = 'utf-8'

        coordinateTransformContext = QgsProject.instance().transformContext()

        QgsVectorFileWriter.writeAsVectorFormatV3(vl, shapefile, coordinateTransformContext, options)

        # Add the layer to the project
        velocity_vector_lyr = QgsVectorLayer(shapefile, name, 'ogr')
        QgsProject.instance().addMapLayer(velocity_vector_lyr, False)
        set_velocity_vector_style(velocity_vector_lyr, vector_scale)

        mapping_group.insertLayer(0, velocity_vector_lyr)

    def dir_to_angle(self, direction):
        """
        Function to convert FLO-2D direction to angle
        """
        directions = {
            1: 0,  # North
            2: 90,  # East
            3: 180,  # South
            4: 270,  # West
            5: 45,  # Northeast
            6: 135,  # Southeast
            7: 225,  # Southwest
            8: 315  # Northwest
        }
        return directions.get(direction)
