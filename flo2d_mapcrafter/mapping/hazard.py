# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FLO2DMapCrafter
                                 A QGIS plugin
 This plugin creates maps from FLO-2D output files.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-09-21
        git sha              : $Format:%H$
        copyright            : (C) 2023 by FLO-2D
        email                : contact@flo-2d.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
import processing
import numpy as np

try:
    import h5py
except ImportError:
    h5py = None
from osgeo import gdal
from qgis._core import QgsProject, QgsRasterLayer
from qgis.PyQt.QtWidgets import QProgressDialog, QApplication
from PyQt5.QtCore import Qt
from flo2d_mapcrafter.mapping.check_data import check_project_id, check_mapping_group, check_raster_file
from flo2d_mapcrafter.mapping.scripts import read_ASCII, remove_layer, set_raster_style


class HazardMaps:
    def __init__(self, iface, units_switch, toler_value):
        """
        Class constructor
        :param units_switch: 0 english 1 metric
        """
        self.iface = iface
        self.units_switch = units_switch
        self.toler_value = toler_value

        # gravitational acceleration
        self.gravity = 9.80665 if self.units_switch == "1" else 32.174

        # unit (uc)
        self.uc = 1.0 if units_switch == "1" else 3.28

    def make_progress(self, text: str, maximum: int) -> QProgressDialog:
        dlg = QProgressDialog(text, "Cancel", 0, max(1, int(maximum)), self.iface.mainWindow())
        dlg.setWindowTitle("QGIS3")
        dlg.setWindowModality(Qt.WindowModal)
        dlg.setMinimumDuration(0)
        dlg.setAutoClose(True)
        dlg.setAutoReset(True)
        dlg.setValue(0)
        return dlg

    def tick(self, dlg: QProgressDialog, label: str):
        if dlg.wasCanceled():
            raise KeyboardInterrupt
        dlg.setLabelText(label)
        dlg.setValue(dlg.value() + 1)
        QApplication.processEvents()

    def compute_cell_size(self, xy_points):
        """
        Compute FLO-2D grid cell size from at least two (x, y) points.
        """
        if len(xy_points) < 2:
            raise ValueError("At least two points required to compute cell size")

        dx = abs(xy_points[1][0] - xy_points[0][0])
        dy = abs(xy_points[1][1] - xy_points[0][1])

        dx = dx if dx > 0 else 9999
        dy = dy if dy > 0 else 9999

        return min(dx, dy)

    def points_to_raster_array(self, points, cell_size, nodata=-9999, extent_points=None):
        """
        Convert (x, y, value) points to raster array and georeferencing info
        """
        if extent_points is None:
            extent_points = points

        xs = [p[0] for p in extent_points]
        ys = [p[1] for p in extent_points]

        min_x, max_x = min(xs), max(xs)
        min_y, max_y = min(ys), max(ys)

        num_cols = int((max_x - min_x) / cell_size) + 1
        num_rows = int((max_y - min_y) / cell_size) + 1

        raster_data = np.full((num_rows, num_cols), nodata, dtype=np.float32)

        for x, y, v in points:
            col = int((x - min_x) / cell_size)
            row = int((max_y - y) / cell_size)
            raster_data[row, col] = v

        geotransform = (
            min_x - cell_size / 2,
            cell_size,
            0,
            max_y + cell_size / 2,
            0,
            -cell_size,
        )

        return raster_data, geotransform

    def write_geotiff(self, output_path, raster_data, geotransform, crs, nodata=-9999):
        """
        Write a single-band GeoTiff
        """
        rows, cols = raster_data.shape
        driver = gdal.GetDriverByName("GTiff")
        raster = driver.Create(output_path, cols, rows, 1, gdal.GDT_Float32)

        raster.SetGeoTransform(geotransform)
        raster.SetProjection(crs.toWkt())

        band = raster.GetRasterBand(1)
        band.SetNoDataValue(nodata)
        band.WriteArray(raster_data)

        raster.FlushCache()

    def check_hazard_files(self, output_dir):
        """
        Function to check the hazard maps that can be created
        """
        hazard_maps = {
            "ARR": False,
            "Austrian": False,
            "FLO-2D": False,
            "Swiss": [False, False],
            "UK": False,
            "USBR": [False, False, False, False, False],
            "FEMA": False,
            "PIER": False,
            "PIER_TIMDEP": False
        }

        # Australian Rainfall and Runoff (ARR)
        arr_files = {
            r"DEPTH.OUT": False,
            r"VELFP.OUT": False,
            r"VEL_X_DEPTH.OUT": False
        }

        # AUSTRIAN Flood Hazard
        austrian_files = {
            r"DEPTH.OUT": False,
            r"VELFP.OUT": False
        }

        # SWISS FLOOD INTENSITY
        swiss_files = {
            r"DEPTH.OUT": False,
            r"VEL_X_DEPTH.OUT": False,
            r"VELFP.OUT": False
        }

        # UK Hazard Mapping
        uk_files = {
            r"DEPTH.OUT": False,
            r"VELFP.OUT": False
        }

        # US Bureau of Reclamation
        usbr_files = {
            r"DEPTH.OUT": False,
            r"VELFP.OUT": False,
        }

        # US FEMA
        fema_files = {
            r"DEPTH.OUT": False,
            r"VELFP.OUT": False
        }

        # PIER SCOUR
        pier_files_timdep = {
            r"TIMDEP.HDF5": False
        }

        pier_files_max = {
            r"DEPFP.OUT": False,
            r"VELFP.OUT": False
        }

        files = os.listdir(output_dir)

        for file in files:
            filename = os.path.basename(file)

            if filename in arr_files:
                arr_files[filename] = True

            if filename in austrian_files:
                austrian_files[filename] = True

            if filename in swiss_files:
                swiss_files[filename] = True

            if filename in usbr_files:
                usbr_files[filename] = True

            if filename in uk_files:
                uk_files[filename] = True

            if filename in fema_files:
                fema_files[filename] = True

            if filename in pier_files_timdep:
                pier_files_timdep[filename] = True

            if filename in pier_files_max:
                pier_files_max[filename] = True

        # ARR Check if all files are true
        if all(value for value in arr_files.values()):
            hazard_maps["ARR"] = True

        # AUSTRIAN Check if all files are true
        if all(value for value in austrian_files.values()):
            hazard_maps["Austrian"] = True

        # SWISS Check if all files are true
        if all(value for value in swiss_files.values()):
            hazard_maps["Swiss"] = [True, True]

        # UK Check if all files are true
        if all(value for value in uk_files.values()):
            hazard_maps["UK"] = True

        # USBR Check if all files are true
        if all(value for value in usbr_files.values()):
            hazard_maps["USBR"] = [True, True, True, True, True]

        # FEMA Check if all files are true
        if all(value for value in fema_files.values()):
            hazard_maps["FEMA"] = [True]

        # Pier Scour Check if all files are true
        if all(pier_files_timdep.values()) or all(pier_files_max.values()):
            hazard_maps["PIER"] = True

        # Pier Scour timdep Check if timdep is true
        if all(pier_files_timdep.values()):
            hazard_maps["PIER_TIMDEP"] = True

        return hazard_maps

    def create_maps(self, hazard_rbs, flo2d_results_dir, map_output_dir, mapping_group, crs, project_id, pier_params=None):
        pier_params = pier_params or {}
        """
        Function to create the maps
        """
        # ---- count steps (ARR + Swiss flags + USBR flags) ----
        total_steps = 0
        if hazard_rbs.get("ARR"):
            total_steps += 1
        if hazard_rbs.get("Austrian"):
            total_steps += 1
        swiss_maps = hazard_rbs.get("Swiss") or []
        if hazard_rbs.get("UK"):
            total_steps += 1
        total_steps += sum(1 for v in swiss_maps if v)
        usbr_maps = hazard_rbs.get("USBR") or []
        if hazard_rbs.get("FEMA"):
            total_steps += 1
        total_steps += sum(1 for v in usbr_maps if v)
        if hazard_rbs.get("PIER"):
            total_steps += 1

        dlg = self.make_progress("Preparing…", max(1, total_steps))
        try:
            # ----------------- setup / groups -----------------
            mapping_group_name = check_project_id("Hazard Maps", project_id)
            mapping_group = check_mapping_group(mapping_group_name, mapping_group)

            vector_style_directory = os.path.dirname(os.path.realpath(__file__))[:-8] + r"\vector_styles"
            raster_style_directory = os.path.dirname(os.path.realpath(__file__))[:-8] + r"\raster_styles"

            # ARR
            ARR_group_name = "Australian Rainfall and Runoff (ARR)"
            ARR_group = mapping_group.findGroup(ARR_group_name) or mapping_group.insertGroup(0, ARR_group_name)

            # AUSTRIAN
            AUSTRIAN_group_name = "AUSTRIAN"
            AUSTRIAN_group = mapping_group.findGroup(AUSTRIAN_group_name) or mapping_group.insertGroup(0,AUSTRIAN_group_name)

            # SWISS
            SWISS_group_name = "SWISS"
            SWISS_group = mapping_group.findGroup(SWISS_group_name) or mapping_group.insertGroup(0, SWISS_group_name)

            # UK
            UK_group_name = "UK"
            UK_group = mapping_group.findGroup(UK_group_name) or mapping_group.insertGroup(0, UK_group_name)

            # USBR
            USBR_group_name = "US Bureau of Reclamation"
            USBR_group = mapping_group.findGroup(USBR_group_name) or mapping_group.insertGroup(0, USBR_group_name)

            # FEMA
            FEMA_group_name = "FEMA"
            FEMA_group = mapping_group.findGroup(FEMA_group_name) or mapping_group.insertGroup(0, FEMA_group_name)

            # PIER
            PIER_group_name = "PIER SCOUR"
            PIER_group = mapping_group.findGroup(PIER_group_name) or mapping_group.insertGroup(0, PIER_group_name)

            # ----------------- ARR -----------------
            if hazard_rbs.get("ARR"):
                dlg.setLabelText("ARR: computing…");
                QApplication.processEvents()
                name = check_project_id("ARR_FLOOD_HAZARD", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                depth_file = os.path.join(flo2d_results_dir, "DEPTH.OUT")
                vel_file = os.path.join(flo2d_results_dir, "VELFP.OUT")
                vel_x_depth_file = os.path.join(flo2d_results_dir, "VEL_X_DEPTH.OUT")

                hydro_risk_raster = self.create_arr_map(
                    map_output_dir, raster, depth_file, vel_file, vel_x_depth_file, crs, project_id
                )

                QgsProject.instance().addMapLayer(hydro_risk_raster, False)
                set_raster_style(hydro_risk_raster, 2, self.toler_value)
                ARR_group.insertLayer(0, hydro_risk_raster)

                self.tick(dlg, "ARR: done")

            # ----------------- AUSTRIAN Hazard Map ----------------- #
            if hazard_rbs.get("Austrian"):
                dlg.setLabelText("Austrian: computing...")
                QApplication.processEvents()

                depth_file = os.path.join(flo2d_results_dir, "DEPTH.OUT")
                vel_file = os.path.join(flo2d_results_dir, "VELFP.OUT")

                name = check_project_id("AUSTRIAN_HAZARD", project_id)
                name, raster = check_raster_file(name, map_output_dir)

                hydro_risk_raster = self.create_austrian_map(name, raster, depth_file, vel_file, crs)

                QgsProject.instance().addMapLayer(hydro_risk_raster, False)
                set_raster_style(hydro_risk_raster, 18, 1)
                AUSTRIAN_group.insertLayer(0, hydro_risk_raster)

                self.tick(dlg, "AUSTRIAN: done")

            # ----------------- UK Hazard Map ----------------- #
            if hazard_rbs.get("UK"):
                dlg.setLabelText("UK Hazard: computing ...")
                QApplication.processEvents()

                depth_file = os.path.join(flo2d_results_dir, "DEPTH.OUT")
                vel_file = os.path.join(flo2d_results_dir, 'VELFP.OUT')

                name = check_project_id("UK_FLOOD_HAZARD", project_id)
                name, raster = check_raster_file(name, map_output_dir)

                hydro_risk_raster = self.create_uk_map(name, raster, depth_file, vel_file, crs)

                QgsProject.instance().addMapLayer(hydro_risk_raster, False)
                set_raster_style(hydro_risk_raster, 17, 1)
                mapping_group.insertLayer(0, hydro_risk_raster)

                self.tick(dlg, "UK Hazard: done")

            # ----------------- USBR (Houses/Mobile/Vehicles/Adults/Children) -----------------
            usbr_maps = hazard_rbs.get("USBR") or []
            for index, hazard_type in enumerate(usbr_maps):
                if not hazard_type:
                    continue

                labels = ["USBR – Houses", "USBR – Mobile", "USBR – Vehicle", "USBR – Adults", "USBR – Children"]
                dlg.setLabelText(f"{labels[index]}: computing…");
                QApplication.processEvents()

                depth_file = os.path.join(flo2d_results_dir, "DEPTH.OUT")
                vel_file = os.path.join(flo2d_results_dir, "VELFP.OUT")

                vel_data = np.loadtxt(vel_file, skiprows=0)
                depth_data = np.loadtxt(depth_file, skiprows=0)

                if index == 0:
                    name = check_project_id("USBR_HOUSES_HAZARD", project_id)
                elif index == 1:
                    name = check_project_id("USBR_MOBILE_HAZARD", project_id)
                elif index == 2:
                    name = check_project_id("USBR_VEHICLE_HAZARD", project_id)
                elif index == 3:
                    name = check_project_id("USBR_ADULTS_HAZARD", project_id)
                else:
                    name = check_project_id("USBR_CHILDREN_HAZARD", project_id)

                name, raster = check_raster_file(name, map_output_dir)
                hydro_risk_raster = self.create_usbr_map(
                    name, raster, depth_data, vel_data, index, crs
                )
                QgsProject.instance().addMapLayer(hydro_risk_raster, False)
                set_raster_style(hydro_risk_raster, 20, 1)
                USBR_group.insertLayer(0, hydro_risk_raster)

                self.tick(dlg, f"{labels[index]}: done")

            # ----------------- SWISS (Flood intensity / Debris intensity) -----------------
            swiss_maps = hazard_rbs.get("Swiss") or []
            for index, hazard_type in enumerate(swiss_maps):
                if not hazard_type:
                    continue

                labels = ["Swiss Flood Intensity", "Swiss Debris Intensity"]
                dlg.setLabelText(f"{labels[index]}: computing…");
                QApplication.processEvents()

                depth_file = os.path.join(flo2d_results_dir, "DEPTH.OUT")
                vel_file = os.path.join(flo2d_results_dir, "VELFP.OUT")
                vel_x_depth_file = os.path.join(flo2d_results_dir, "VEL_X_DEPTH.OUT")
                vel_x_depth_data = np.loadtxt(vel_x_depth_file, skiprows=0)
                depth_data = np.loadtxt(depth_file, skiprows=0)
                vel_data = np.loadtxt(vel_file, skiprows=0)

                if index == 0:
                    name = check_project_id("SWISS_FLOOD_INTENSITY", project_id)
                else:
                    name = check_project_id("SWISS_DEBRIS_INTENSITY", project_id)

                name, raster = check_raster_file(name, map_output_dir)
                hydro_risk_raster = self.create_swiss_map(
                    name, raster, depth_data, vel_data, vel_x_depth_data, index, crs
                )
                QgsProject.instance().addMapLayer(hydro_risk_raster, False)
                set_raster_style(hydro_risk_raster, 19, 1)
                SWISS_group.insertLayer(0, hydro_risk_raster)

                self.tick(dlg, f"{labels[index]}: done")

            # ------------------ FEMA Hazard Map ----------------- #
            if hazard_rbs.get("FEMA"):
                dlg.setLabelText("FEMA: computing...")
                QApplication.processEvents()

                depth_file = os.path.join(flo2d_results_dir, "DEPTH.OUT")
                vel_file = os.path.join(flo2d_results_dir, "VELFP.OUT")

                name = check_project_id("FEMA_HAZARD", project_id)
                name, raster = check_raster_file(name, map_output_dir)

                hydro_risk_raster = self.create_fema_map(name, raster, depth_file, vel_file, crs)

                QgsProject.instance().addMapLayer(hydro_risk_raster, False)
                set_raster_style(hydro_risk_raster, 16, 1)
                FEMA_group.insertLayer(0, hydro_risk_raster)

                self.tick(dlg, "FEMA: done")

            # ----------------- Pier Scour Maps -----------------
            if hazard_rbs.get("PIER"):
                dlg.setLabelText("PIER: computing…");
                QApplication.processEvents()
                name = check_project_id("PIER SCOUR", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                depth_file = os.path.join(flo2d_results_dir, "DEPTH.OUT")
                vel_file = os.path.join(flo2d_results_dir, "VELFP.OUT")
                timdep_file = os.path.join(flo2d_results_dir, "TIMDEP.HDF5")

                hydro_risk_raster = self.create_pier_scour_map(raster, depth_file, vel_file, timdep_file, crs, pier_params)

                QgsProject.instance().addMapLayer(hydro_risk_raster, False)
                set_raster_style(hydro_risk_raster, 15, self.toler_value, self.units_switch)
                PIER_group.insertLayer(0, hydro_risk_raster)

                self.tick(dlg, "PIER: done")

            # ----------------- collapse new layers -----------------
            allLayers = mapping_group.findLayers()
            for layer in allLayers:
                lyr = QgsProject.instance().layerTreeRoot().findLayer(layer.layerId())
                lyr.setItemVisibilityChecked(False)
                lyr.setExpanded(False)

        except KeyboardInterrupt:
            # user cancelled
            return
        finally:
            dlg.close()

    def create_swiss_map(self, name, hydro_risk, depth_data, vel_data, vel_x_depth_data, map_type, crs):
        """Create the SWISS flood intensity map"""
        values = []
        cell_size_data = []

        # Flood Intensity
        if map_type == 0:
            for (id_v, x, y, depth_x_velocity), (_, _, _, depth) in zip(vel_x_depth_data, depth_data):
                if depth != 0:
                    # Unit conversion
                    depth = depth * self.uc
                    depth_x_velocity = depth_x_velocity * (self.uc ** 2)
                    # low intensity
                    if depth > 2 or depth_x_velocity > 2:
                        values.append((x, y, 3))
                        if len(cell_size_data) < 2:
                            cell_size_data.append((x, y))
                    # moderate intensity
                    elif 0.5 < depth < 2 or 0.5 < depth_x_velocity < 2:
                        values.append((x, y, 2))
                        if len(cell_size_data) < 2:
                            cell_size_data.append((x, y))
                    # high intensity
                    else:
                        values.append((x, y, 1))
                        if len(cell_size_data) < 2:
                            cell_size_data.append((x, y))

        # Debris Intensity
        if map_type == 1:
            for (id_v, x, y, depth), (_, _, _, velocity) in zip(depth_data, vel_data):
                if depth != 0:
                    # Unit conversion
                    depth = depth * self.uc
                    velocity = velocity * self.uc
                    # high intensity
                    if depth > 1 and velocity > 1:
                        values.append((x, y, 3))
                        if len(cell_size_data) < 2:
                            cell_size_data.append((x, y))
                    # moderate intensity
                    elif depth < 1 or velocity < 1:
                        values.append((x, y, 2))
                        if len(cell_size_data) < 2:
                            cell_size_data.append((x, y))

        cell_size = self.compute_cell_size(cell_size_data)
        raster_data, geotransform = self.points_to_raster_array(values, cell_size)  # Convert (x, y, value) points into raster array + geotransform
        self.write_geotiff(hydro_risk, raster_data, geotransform, crs)  # Write GeoTIFF
        return QgsRasterLayer(hydro_risk, name)

    def create_arr_map(self, map_output_dir, hydro_risk, depth_file, vel_file, vel_x_depth_file, crs, project_id):
        """Create the ARR hydrodynamic risk map"""
        name_speed = check_project_id("FLOW_SPEED", project_id)
        name, flow_speed = check_raster_file(name_speed, map_output_dir)

        name_depth = check_project_id("FLOOD_DEPTH", project_id)
        name, flood_depth = check_raster_file(name_depth, map_output_dir)

        name_hxv = check_project_id("HxV", project_id)
        name, h_x_v = check_raster_file(name_hxv, map_output_dir)

        if os.path.isfile(flood_depth):
            QgsProject.instance().addMapLayer(QgsRasterLayer(flood_depth, name_depth), True)
        else:
            raster_processed = read_ASCII(depth_file, flood_depth, name_depth, crs)
            if raster_processed:
                QgsProject.instance().addMapLayer(QgsRasterLayer(flood_depth, name_depth), True)

        if os.path.isfile(flow_speed):
            QgsProject.instance().addMapLayer(QgsRasterLayer(flow_speed, name_speed), True)
        else:
            raster_processed = read_ASCII(vel_file, flow_speed, name_speed, crs)
            if raster_processed:
                QgsProject.instance().addMapLayer(QgsRasterLayer(flow_speed, name_speed), True)

        if os.path.isfile(h_x_v):
            QgsProject.instance().addMapLayer(QgsRasterLayer(h_x_v, name_hxv), True)
        else:
            raster_processed = read_ASCII(vel_x_depth_file, h_x_v, name_hxv, crs)
            if raster_processed:
                QgsProject.instance().addMapLayer(QgsRasterLayer(h_x_v, name_hxv), True)

        r0_e = f'"{name_hxv}@1" = 0 AND "{name_depth}@1" = 0 AND "{name_speed}@1" = 0'
        r1_e = f'"{name_hxv}@1" <= {0.3 * self.uc} AND "{name_depth}@1" < {0.3 * self.uc} AND "{name_speed}@1" < {2 * self.uc}'
        r2_e = f'"{name_hxv}@1" <= {0.6 * self.uc} AND "{name_depth}@1" < {0.5 * self.uc} AND "{name_speed}@1" < {2 * self.uc}'
        r3_e = f'"{name_hxv}@1" <= {0.6 * self.uc} AND "{name_depth}@1" < {1.2 * self.uc} AND "{name_speed}@1" < {2 * self.uc}'
        r4_e = f'"{name_hxv}@1" <= {1.0 * self.uc} AND "{name_depth}@1" < {2.0 * self.uc} AND "{name_speed}@1" < {2 * self.uc}'
        r5_e = f'"{name_hxv}@1" <= {4.0 * self.uc} AND "{name_depth}@1" < {4.0 * self.uc} AND "{name_speed}@1" < {4 * self.uc}'
        r6_e = f'"{name_hxv}@1" > {4.0 * self.uc} OR "{name_depth}@1" >= {4.0 * self.uc} OR "{name_speed}@1" >= {4 * self.uc}'

        # Australian Rainfall and Runoff (ARR) Classification
        arr_class = processing.run(
            "qgis:rastercalculator",
            {
                "EXPRESSION": f"IF({r0_e},0,if({r1_e},1,if({r2_e},2,if({r3_e},3,if({r4_e},4,if({r5_e},5,if({r6_e},6,0)))))))",
                "LAYERS": [flood_depth],
                "CELLSIZE": 0,
                "EXTENT": None,
                "CRS": crs,
                "OUTPUT": hydro_risk,
            },
        )["OUTPUT"]

        remove_layer(name_depth)
        remove_layer(name_speed)
        remove_layer(name_hxv)

        name_arr = os.path.splitext(os.path.basename(hydro_risk))[0]

        return QgsRasterLayer(arr_class, name_arr)

    def create_austrian_map(self, name, hydro_risk, depth_file, vel_file, crs):
        """
        Two classes:
            WR (Red Zone): High hazard
            WG (Yellow Zone): Low hazard
        """
        depth_data = self.read_flo2d_ascii_xyv(depth_file)
        vel_data = self.read_flo2d_ascii_xyv(vel_file)

        depth_map = {cell: (x, y, d) for (cell, x, y, d) in depth_data}
        vel_map = {cell: v for (cell, x, y,  v) in vel_data}

        values = []
        cell_size_data = []

        for cell, (x, y, depth_val) in depth_map.items():
            velocity_val = vel_map.get(cell, 0.0)

            if depth_val <= 0:
                continue

            h = float(depth_val) * self.uc
            v = float(velocity_val) * self.uc

            E = h + (v ** 2) / (2.0 * self.gravity)

            if (h >= 1.5) or (E >= 1.5):
                cls = 2 # WR
            else:
                cls = 1 # GW

            values.append((x, y, cls))
            if len(cell_size_data) < 2:
                cell_size_data.append((x, y))

            if not values:
                all_xy = [(x, y) for (_, x, y, _) in depth_data] if depth_data else [(0, 0), (1, 0)]
                cell_size = self.compute_cell_size(all_xy)
                raster_data, geotransform = self.points_to_raster_array([], cell_size)
                self.write_geotiff(hydro_risk, raster_data, geotransform, crs)
                return QgsRasterLayer(hydro_risk, name)

        cell_size = self.compute_cell_size(cell_size_data if len(cell_size_data) >= 2 else [(x, y) for (_, x, y, _) in depth_data])

        raster_data, geotransform = self.points_to_raster_array(values, cell_size)
        self.write_geotiff(hydro_risk, raster_data, geotransform, crs)
        return QgsRasterLayer(hydro_risk, name)

    def create_uk_map(self, name, hydro_risk, depth_file, vel_file, crs):
        depth_data = self.read_flo2d_ascii_xyv(depth_file)
        vel_data = self.read_flo2d_ascii_xyv(vel_file)

        depth_map = {cell: (x, y, d) for (cell, x, y, d) in depth_data}
        vel_map = {cell: v for (cell, _, _, v) in vel_data}

        values = []
        cell_size_data = []

        for cell, (x, y, depth) in depth_map.items():
            velocity = vel_map.get(cell, 0.0)

            if depth <= 0.0:
                continue

            d = depth * self.uc
            v = velocity * self.uc

            DF = 0.5 if d <= 0.25 else 1.0 # debris factor

            HR = d * (v + 0.5) + DF

            if HR < 0.75:
                cls = 1         # Very low hazard (caution)
            elif HR < 1.25:
                cls = 2         # Danger for some
            elif HR < 2.0:
                cls = 3         # Danger for most
            else:
                cls = 4         # Danger for all

            values.append((x,y, cls))
            if len(cell_size_data) < 2:
                cell_size_data.append((x,y))

        # Raster creation
        if not values:
            all_xy = [(x,y,) for (_, x, y, _) in depth_data]
            cell_size = self.compute_cell_size(all_xy)
            raster_data, geotransform = self.points_to_raster_array([], cell_size)
        else:
            cell_size = self.compute_cell_size(cell_size_data)
            raster_data, geotransform = self.points_to_raster_array(values, cell_size)

        self.write_geotiff(hydro_risk, raster_data, geotransform, crs)

        return QgsRasterLayer(hydro_risk, name)

    def create_usbr_map(self, name, hydro_risk, depth_data, vel_data, map_type, crs):
        """Create the USBR hydrodynamic risk map"""
        # adjust units
        if self.units_switch == "1":
            uc = 3.28
        else:
            uc = 1

        values = []
        cell_size_data = []
        for (id_v, x, y, velocity), (_, _, _, depth) in zip(vel_data, depth_data):

            if depth != 0 and velocity != 0:

                # Unit conversion
                depth = depth * uc
                velocity = velocity * uc

                # Houses
                if map_type == 0:
                    low_curve_value = 0.0004 * velocity ** 3 - 0.0121 * velocity ** 2 - 0.0809 * velocity + 3.076
                    high_curve_value = 0.0007 * velocity ** 3 - 0.0276 * velocity ** 2 + 0.0206 * velocity + 5.9005
                # Mobile
                if map_type == 1:
                    low_curve_value = -0.0007 * velocity ** 2 - 0.0308 * velocity + 1.9458
                    high_curve_value = -0.0009 * velocity ** 2 - 0.0262 * velocity + 2.5373
                # Vehicles
                if map_type == 2:
                    low_curve_value = 0.0002 * velocity ** 3 - 0.0009 * velocity ** 2 - 0.0904 * velocity + 2.0311
                    high_curve_value = 0.0004 * velocity ** 3 - 0.0056 * velocity ** 2 - 0.1036 * velocity + 3.0877
                # Adults
                if map_type == 3:
                    low_curve_value = -0.0053 * velocity ** 3 + 0.1241 * velocity ** 2 - 1.0323 * velocity + 3.1671
                    high_curve_value = -0.0011 * velocity ** 4 + 0.0282 * velocity ** 3 - 0.1888 * velocity ** 2 - 0.2374 * velocity + 4.633
                # Children
                if map_type == 4:
                    low_curve_value = 0.0726 * velocity ** 2 - 0.6786 * velocity + 1.5994
                    high_curve_value = 0.0029 * velocity ** 5 - 0.0526 * velocity ** 4 + 0.3337 * velocity ** 3 - 0.7657 * velocity ** 2 - 0.2936 * velocity + 3.0475

                # low danger
                if depth < low_curve_value:
                    values.append((x, y, 1))
                    if len(cell_size_data) < 2:
                        cell_size_data.append((x, y))
                # high danger
                elif depth > high_curve_value:
                    values.append((x, y, 3))
                    if len(cell_size_data) < 2:
                        cell_size_data.append((x, y))
                # judgment
                else:
                    values.append((x, y, 2))
                    if len(cell_size_data) < 2:
                        cell_size_data.append((x, y))

                # Fix maximums:
                if map_type == 0 and (depth > 10 or velocity > 25):
                    values.append((x, y, 3))
                if map_type == 1 and (depth > 3 or velocity > 16):
                    values.append((x, y, 3))
                if map_type == 2 and (depth > 4 or velocity > 16):
                    values.append((x, y, 3))
                if map_type == 3 and (depth > 5 or velocity > 12):
                    values.append((x, y, 3))
                if map_type == 4 and (depth > 4 or velocity > 8):
                    values.append((x, y, 3))

        cell_size = self.compute_cell_size(cell_size_data)
        raster_data, geotransform = self.points_to_raster_array(values, cell_size)
        self.write_geotiff(hydro_risk, raster_data, geotransform, crs)
        return QgsRasterLayer(hydro_risk, name)

    def create_fema_map(self, name, hydro_risk, depth_file, vel_file, crs):
        depth_data = self.read_flo2d_ascii_xyv(depth_file)
        vel_data = self.read_flo2d_ascii_xyv(vel_file)

        depth_map = {cell: (x, y, d) for (cell, x, y, d) in depth_data}
        vel_map = {cell: v for (cell, x, y, v) in vel_data}

        values = []
        cell_size_data = []

        for cell, (x, y, depth_val) in depth_map.items():
            velocity_val = vel_map.get(cell, 0.0)

            if depth_val <= 0.0:
                continue

            h = float(depth_val) * self.uc
            v = float(velocity_val) * self.uc

            hazard = h * v
            if hazard < 0.2:
                cls = 1     # Low
            elif hazard < 0.5:
                cls = 2 # Medium
            elif hazard < 1.5:
                cls = 3 # High
            elif hazard < 2.5:
                cls = 4 # Very high
            else:
                cls = 5 # Extreme

            values.append((x, y, cls))
            if len(cell_size_data) < 2:
                cell_size_data.append((x, y))

            if not values:
                all_xy = [(x, y) for (_, x, y, _) in depth_data] if depth_data else [(0, 0), (1, 0)]
                cell_size = self.compute_cell_size(all_xy)
                raster_data, geotransform = self.points_to_raster_array([], cell_size)
                self.write_geotiff(hydro_risk, raster_data, geotransform, crs)
                return QgsRasterLayer(hydro_risk, name)

        cell_size = self.compute_cell_size(cell_size_data if len(cell_size_data) >= 2 else [(x, y) for (_, x, y, _) in depth_data])

        raster_data, geotransform = self.points_to_raster_array(values, cell_size)
        self.write_geotiff(hydro_risk, raster_data, geotransform, crs)
        return QgsRasterLayer(hydro_risk, name)


    def create_pier_scour_map(self, hydro_risk, depth_file, vel_file, timdep_file, crs, pier_params):
        """
        Create the HEC-18 CSU Pier Scour map.
        Uses FLO-2D grid-based outputs and writes a GeoTIFF.
        """
        values = []
        all_xy = []  # Initialize here so it's available for both paths

        # Compute scour magnitude per grid element
        if pier_params.get("use_timdep", False):
            # --- TIMDEP path: max scour over time ---
            scour = self.scour_from_timdep(
                os.path.dirname(timdep_file),
                pier_params
            )

            # Geometry comes from DEPTH.OUT (grid order guaranteed)
            depth_data = self.read_flo2d_ascii_xyv(depth_file)

            # Extract all x,y coordinates for cell size calculation
            all_xy = [(x, y) for (_, x, y, _) in depth_data]

            for (_, x, y, _), s in zip(depth_data, scour):
                if s > 0.0:
                    values.append((x, y, float(s)))

        else:
            # --- Max-field path: floodplain-only ---
            results_dir = os.path.dirname(depth_file)

            # Read geometry from DEPFP.OUT (floodplain only)
            depth_data = self.read_flo2d_ascii_xyv(
                os.path.join(results_dir, "DEPFP.OUT")
            )

            all_xy = [(x, y) for (_, x, y, _) in depth_data]

            scour = self.scour_from_max_fields(
                results_dir,
                pier_params
            )

            for (_, x, y, _), s in zip(depth_data, scour):
                if s > 0.0:
                    values.append((x, y, float(s)))

        cell_size = self.compute_cell_size(all_xy)
        raster_data, geotransform = self.points_to_raster_array(values, cell_size, extent_points=all_xy)
        self.write_geotiff(hydro_risk, raster_data, geotransform, crs)
        layer_name = os.path.splitext(os.path.basename(hydro_risk))[0]
        return QgsRasterLayer(hydro_risk, layer_name)

    def compute_scour(self, depth, velocity, a, k1, k2, k3, k4):
        """
        Compute HEC-18 CSU Scour
        """
        depth = np.where(depth > 0.0, depth, np.nan)
        Fr = velocity / np.sqrt(self.gravity * depth)

        scour = (
                2.0 * k1 * k2 * k3 * k4 * a
                * (depth / a) ** 0.35
                * (Fr / 0.65) ** 0.43
        )

        return np.nan_to_num(scour, nan=0.0)

    def read_flo2d_ascii_xyv(self, file_path):
        """
        Read FLO-2D grid-based ASCII output:
        cell, x, y, value
        Returns list of (cell_id, x, y, value)
        """
        data = []
        with open(file_path, "r") as f:
            for line in f:
                fields = line.split()
                if not fields or not fields[0].isdigit():
                    continue
                cell = int(fields[0])
                x = float(fields[1])
                y = float(fields[2])
                value = float(fields[3])
                data.append((cell, x, y, value))
        return data

    def scour_from_timdep(self, results_dir, pier_params):
        """
        Define scour parameters from TIMDEP.HDF5
        Depending on whether TIMDEP.HDF5 includes the 1D
        channel, this data may look different from the pier scour
        from DEPFP.OUT and VELFP.OUT.
        """
        hdf5_path = os.path.join(results_dir, "TIMDEP.HDF5")

        with h5py.File(hdf5_path, "r") as f:
            grp = f["TIMDEP NETCDF OUTPUT RESULTS"]
            depth = grp["FLOW DEPTH"]["Values"][:]
            vel = grp["Velocity MAG"]["Values"][:]

        scour_t = self.compute_scour(
            depth,
            vel,
            pier_params["pier_width"],
            pier_params["k1"],
            pier_params["k2"],
            pier_params["k3"],
            pier_params["k4"],
        )

        return np.max(scour_t, axis=0)

    def scour_from_max_fields(self, results_dir, pier_params):
        """
        Compute pier scour using floodplain-only max-field outputs.
        DEPFP.OUT and VELFP.OUT are used intentionally to exclude 1D channels.
        """
        # Read floodplain-only depth and velocity (grid order preserved)
        depth_data = self.read_flo2d_ascii_xyv(
            os.path.join(results_dir, "DEPFP.OUT")
        )
        vel_data = self.read_flo2d_ascii_xyv(
            os.path.join(results_dir, "VELFP.OUT")
        )

        # Extract numeric arrays (same grid order guaranteed)
        depth = np.array([v for (_, _, _, v) in depth_data], dtype=float)
        vel = np.array([v for (_, _, _, v) in vel_data], dtype=float)

        return self.compute_scour(
            depth,
            vel,
            pier_params["pier_width"],
            pier_params["k1"],
            pier_params["k2"],
            pier_params["k3"],
            pier_params["k4"],
        )

