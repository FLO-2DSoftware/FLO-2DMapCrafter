# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FLO2DMapCrafter
                                 A QGIS plugin
 This plugin creates maps from FLO-2D output files.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-09-21
        git sha              : $Format:%H$
        copyright            : (C) 2023 by FLO-2D
        email                : contact@flo-2d.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
import processing
import numpy as np
import h5py
from osgeo import gdal
from qgis._core import QgsProject, QgsRasterLayer
from qgis.PyQt.QtWidgets import QProgressDialog, QApplication
from PyQt5.QtCore import Qt
from flo2d_mapcrafter.mapping.check_data import check_project_id, check_mapping_group, check_raster_file
from flo2d_mapcrafter.mapping.scripts import read_ASCII, remove_layer, set_raster_style

class HazardMaps:

    def __init__(self, iface, units_switch, toler_value):
        """
        Class constructor
        :param units_switch: 0 english 1 metric
        """
        self.iface = iface
        self.units_switch = units_switch
        self.toler_value = toler_value

        # gravitational acceleration
        self.gravity = 9.80665 if self.units_switch == "1" else 32.174

    def _make_progress(self, text: str, maximum: int) -> QProgressDialog:
        dlg = QProgressDialog(text, "Cancel", 0, max(1, int(maximum)), self.iface.mainWindow())
        dlg.setWindowTitle("QGIS3")
        dlg.setWindowModality(Qt.WindowModal)
        dlg.setMinimumDuration(0)
        dlg.setAutoClose(True)
        dlg.setAutoReset(True)
        dlg.setValue(0)
        return dlg

    def _tick(self, dlg: QProgressDialog, label: str):
        if dlg.wasCanceled():
            raise KeyboardInterrupt
        dlg.setLabelText(label)
        dlg.setValue(dlg.value() + 1)
        QApplication.processEvents()

    def check_hazard_files(self, output_dir):
        """
        Function to check the hazard maps that can be created
        """

        hazard_maps = {
            "ARR": False,
            "Austrian": False,
            "FLO-2D": False,
            "Swiss": [False, False],
            "UK": False,
            "USBR": [False, False, False, False, False],
            "FEMA": False,
            "PIER": False
        }

        # Australian Rainfall and Runoff (ARR)
        arr_files = {
            r"DEPTH.OUT": False,
            r"VELFP.OUT": False,
            r"VEL_X_DEPTH.OUT": False
        }

        # SWISS FLOOD INTENSITY
        swiss_files = {
            r"DEPTH.OUT": False,
            r"VEL_X_DEPTH.OUT": False,
            r"VELFP.OUT": False
        }

        # US Bureau of Reclamation
        usbr_files = {
            r"DEPTH.OUT": False,
            r"VELFP.OUT": False,
        }
        
        # PIER SCOUR
        pier_files_timdep = {
            r"TIMDEP.HDF5": False
        }
        
        pier_files_max = {
            r"DEPFP.OUT": False,
            r"VELFP.OUT": False
        }

        files = os.listdir(output_dir)
        for file in files:
            for key, value in arr_files.items():
                if file.startswith(key):
                    arr_files[key] = True
            for key, value in swiss_files.items():
                if file.startswith(key):
                    swiss_files[key] = True
            for key, value in usbr_files.items():
                if file.startswith(key):
                    usbr_files[key] = True
            for key in pier_files_timdep:
                if file.startswith(key):
                    pier_files_timdep[key] = True
            for key in pier_files_max:
                if file.startswith(key):
                    pier_files_max[key] = True

        # ARR Check if all files are true
        if all(value for value in arr_files.values()):
            hazard_maps["ARR"] = True

        # SWISS Check if all files are true
        if all(value for value in swiss_files.values()):
            hazard_maps["Swiss"] = [True, True]

        if all(value for value in usbr_files.values()):
            hazard_maps["USBR"] = [True, True, True, True, True]
            
        if all(pier_files_timdep.values()) or all(pier_files_max.values()):
            hazard_maps["PIER"] = True

        return hazard_maps

    def create_maps(
        self, 
        hazard_rbs, 
        flo2d_results_dir, 
        map_output_dir, 
        mapping_group, 
        crs, 
        project_id,
        pier_params=None
    ):
        pier_params = pier_params or {}


        """
        Function to create the maps
        """

        # ---- count steps (ARR + Swiss flags + USBR flags) ----
        total_steps = 0
        if hazard_rbs.get("ARR"):
            total_steps += 1
        swiss_maps = hazard_rbs.get("Swiss") or []
        total_steps += sum(1 for v in swiss_maps if v)
        usbr_maps = hazard_rbs.get("USBR") or []
        total_steps += sum(1 for v in usbr_maps if v)
        if hazard_rbs.get("PIER"):
            total_steps += 1

        dlg = self._make_progress("Preparing…", max(1, total_steps))
        try:
            # ----------------- setup / groups -----------------
            mapping_group_name = check_project_id("Hazard Maps", project_id)
            mapping_group = check_mapping_group(mapping_group_name, mapping_group)

            vector_style_directory = os.path.dirname(os.path.realpath(__file__))[:-8] + r"\vector_styles"
            raster_style_directory = os.path.dirname(os.path.realpath(__file__))[:-8] + r"\raster_styles"

            # ARR
            ARR_group_name = "Australian Rainfall and Runoff (ARR)"
            ARR_group = mapping_group.findGroup(ARR_group_name) or mapping_group.insertGroup(0, ARR_group_name)

            # SWISS
            SWISS_group_name = "SWISS"
            SWISS_group = mapping_group.findGroup(SWISS_group_name) or mapping_group.insertGroup(0, SWISS_group_name)

            # USBR
            USBR_group_name = "US Bureau of Reclamation"
            USBR_group = mapping_group.findGroup(USBR_group_name) or mapping_group.insertGroup(0, USBR_group_name)
            
            # PIER
            PIER_group_name = "PIER SCOUR"
            PIER_group = mapping_group.findGroup(PIER_group_name) or mapping_group.insertGroup(0, PIER_group_name)

            # ----------------- ARR -----------------
            if hazard_rbs.get("ARR"):
                dlg.setLabelText("ARR: computing…"); QApplication.processEvents()
                name = check_project_id("ARR_FLOOD_HAZARD", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                depth_file = os.path.join(flo2d_results_dir, "DEPTH.OUT")
                vel_file = os.path.join(flo2d_results_dir, "VELFP.OUT")
                vel_x_depth_file = os.path.join(flo2d_results_dir, "VEL_X_DEPTH.OUT")

                hydro_risk_raster = self.create_arr_map(
                    map_output_dir, raster, depth_file, vel_file, vel_x_depth_file, crs, project_id
                )

                QgsProject.instance().addMapLayer(hydro_risk_raster, False)
                set_raster_style(hydro_risk_raster, 2, self.toler_value)
                ARR_group.insertLayer(0, hydro_risk_raster)

                self._tick(dlg, "ARR: done")

            # ----------------- USBR (Houses/Mobile/Vehicles/Adults/Children) -----------------
            usbr_maps = hazard_rbs.get("USBR") or []
            for index, hazard_type in enumerate(usbr_maps):
                if not hazard_type:
                    continue

                labels = ["USBR – Houses", "USBR – Mobile", "USBR – Vehicle", "USBR – Adults", "USBR – Children"]
                dlg.setLabelText(f"{labels[index]}: computing…"); QApplication.processEvents()

                depth_file = os.path.join(flo2d_results_dir, "DEPTH.OUT")
                vel_file = os.path.join(flo2d_results_dir, "VELFP.OUT")
                vel_data = np.loadtxt(vel_file, skiprows=0)
                depth_data = np.loadtxt(depth_file, skiprows=0)

                if index == 0:
                    name = check_project_id("USBR_HOUSES_HAZARD", project_id)
                elif index == 1:
                    name = check_project_id("USBR_MOBILE_HAZARD", project_id)
                elif index == 2:
                    name = check_project_id("USBR_VEHICLE_HAZARD", project_id)
                elif index == 3:
                    name = check_project_id("USBR_ADULTS_HAZARD", project_id)
                else:
                    name = check_project_id("USBR_CHILDREN_HAZARD", project_id)

                name, raster = check_raster_file(name, map_output_dir)
                hydro_risk_raster = self.create_usbr_map(
                    name, raster, depth_data, vel_data, index, crs
                )
                QgsProject.instance().addMapLayer(hydro_risk_raster, False)
                set_raster_style(hydro_risk_raster, 8, 1)
                USBR_group.insertLayer(0, hydro_risk_raster)

                self._tick(dlg, f"{labels[index]}: done")

            # ----------------- SWISS (Flood intensity / Debris intensity) -----------------
            swiss_maps = hazard_rbs.get("Swiss") or []
            for index, hazard_type in enumerate(swiss_maps):
                if not hazard_type:
                    continue

                labels = ["Swiss Flood Intensity", "Swiss Debris Intensity"]
                dlg.setLabelText(f"{labels[index]}: computing…"); QApplication.processEvents()

                depth_file = os.path.join(flo2d_results_dir, "DEPTH.OUT")
                vel_file = os.path.join(flo2d_results_dir, "VELFP.OUT")
                vel_x_depth_file = os.path.join(flo2d_results_dir, "VEL_X_DEPTH.OUT")
                vel_x_depth_data = np.loadtxt(vel_x_depth_file, skiprows=0)
                depth_data = np.loadtxt(depth_file, skiprows=0)
                vel_data = np.loadtxt(vel_file, skiprows=0)

                if index == 0:
                    name = check_project_id("SWISS_FLOOD_INTENSITY", project_id)
                else:
                    name = check_project_id("SWISS_DEBRIS_INTENSITY", project_id)

                name, raster = check_raster_file(name, map_output_dir)
                hydro_risk_raster = self.create_swiss_map(
                    name, raster, depth_data, vel_data, vel_x_depth_data, index, crs
                )
                QgsProject.instance().addMapLayer(hydro_risk_raster, False)
                set_raster_style(hydro_risk_raster, 8, 1)
                SWISS_group.insertLayer(0, hydro_risk_raster)

                self._tick(dlg, f"{labels[index]}: done")
                
            # ----------------- Pier Scour Maps -----------------
            if hazard_rbs.get("PIER"):
                dlg.setLabelText("PIER: computing…"); QApplication.processEvents()
                name = check_project_id("PIER SCOUR", project_id)
                name, raster = check_raster_file(name, map_output_dir)
                depth_file = os.path.join(flo2d_results_dir, "DEPTH.OUT")
                vel_file = os.path.join(flo2d_results_dir, "VELFP.OUT")
                timdep_file = os.path.join(flo2d_results_dir, "TIMDEP.HDF5")

                hydro_risk_raster = self.create_pier_scour_map(
                    raster, 
                    depth_file, 
                    vel_file, 
                    timdep_file, 
                    crs, 
                    pier_params
                )

                QgsProject.instance().addMapLayer(hydro_risk_raster, False)
                set_raster_style(hydro_risk_raster, 15, self.toler_value, self.units_switch)
                PIER_group.insertLayer(0, hydro_risk_raster)

                self._tick(dlg, "PIER: done")

            # ----------------- collapse new layers -----------------
            allLayers = mapping_group.findLayers()
            for layer in allLayers:
                lyr = QgsProject.instance().layerTreeRoot().findLayer(layer.layerId())
                lyr.setItemVisibilityChecked(False)
                lyr.setExpanded(False)

        except KeyboardInterrupt:
            # user cancelled
            return
        finally:
            dlg.close()



    def create_swiss_map(self, name, hydro_risk, depth_data, vel_data, vel_x_depth_data, map_type, crs):
        """Create the SWISS flood intensity map"""

        # adjust units
        if self.units_switch == "1":
            uc = 1
        else:
            uc = 3.28

        values = []
        cellSize_data = []

        # Flood Intensity
        if map_type == 0:
            for (id_v, x, y, depth_x_velocity), (_, _, _, depth) in zip(vel_x_depth_data, depth_data):
                if depth != 0:
                    # Unit conversion
                    depth = depth * uc
                    depth_x_velocity = depth_x_velocity * (uc ** 2)
                    # low intensity
                    if depth > 2 or depth_x_velocity > 2:
                        values.append((x, y, 3))
                        if len(cellSize_data) < 2:
                            cellSize_data.append((x, y))
                    # moderate intensity
                    elif 0.5 < depth < 2 or 0.5 < depth_x_velocity < 2:
                        values.append((x, y, 2))
                        if len(cellSize_data) < 2:
                            cellSize_data.append((x, y))
                    # high intensity
                    else:
                        values.append((x, y, 1))
                        if len(cellSize_data) < 2:
                            cellSize_data.append((x, y))

        # Debris Intensity
        if map_type == 1:
            for (id_v, x, y, depth), (_, _, _, velocity) in zip(depth_data, vel_data):
                if depth != 0:
                    # Unit conversion
                    depth = depth * uc
                    velocity = velocity * uc
                    # high intensity
                    if depth > 1 and velocity > 1:
                        values.append((x, y, 3))
                        if len(cellSize_data) < 2:
                            cellSize_data.append((x, y))
                    # moderate intensity
                    elif depth < 1 or velocity < 1:
                        values.append((x, y, 2))
                        if len(cellSize_data) < 2:
                            cellSize_data.append((x, y))

        # Calculate the differences in X and Y coordinates
        dx = abs(cellSize_data[1][0] - cellSize_data[0][0])
        dy = abs(cellSize_data[1][1] - cellSize_data[0][1])

        # If the coordinate difference is equal 0, assign a huge number
        if dx == 0:
            dx = 9999
        if dy == 0:
            dy = 9999

        cellSize = min(dx, dy)

        # Get the extent and number of rows and columns
        min_x = min(point[0] for point in values)
        max_x = max(point[0] for point in values)
        min_y = min(point[1] for point in values)
        max_y = max(point[1] for point in values)
        num_cols = int((max_x - min_x) / cellSize) + 1
        num_rows = int((max_y - min_y) / cellSize) + 1

        # Convert the list of values to an array.
        raster_data = np.full((num_rows, num_cols), -9999, dtype=np.float32)
        for point in values:
            if point[2] != 0:
                col = int((point[0] - min_x) / cellSize)
                row = int((max_y - point[1]) / cellSize)
                raster_data[row, col] = point[2]

        # Initialize the raster
        driver = gdal.GetDriverByName("GTiff")
        raster = driver.Create(hydro_risk, num_cols, num_rows, 1, gdal.GDT_Float32)
        raster.SetGeoTransform(
            (
                min_x - cellSize / 2,
                cellSize,
                0,
                max_y + cellSize / 2,
                0,
                -cellSize,
            )
        )
        raster.SetProjection(crs.toWkt())

        band = raster.GetRasterBand(1)
        band.SetNoDataValue(-9999)  # Set a no-data value if needed
        band.WriteArray(raster_data)

        raster.FlushCache()

        layer = QgsRasterLayer(hydro_risk, name)

        return layer

    def create_arr_map(
        self, map_output_dir, hydro_risk, depth_file, vel_file, vel_x_depth_file, crs, project_id
    ):
        """Create the ARR hydrodynamic risk map"""

        name_speed = check_project_id("FLOW_SPEED", project_id)
        name, flow_speed = check_raster_file(name_speed, map_output_dir)

        name_depth = check_project_id("FLOOD_DEPTH", project_id)
        name, flood_depth = check_raster_file(name_depth, map_output_dir)

        name_hxv = check_project_id("HxV", project_id)
        name, h_x_v = check_raster_file(name_hxv, map_output_dir)

        # Check flood depth and flow speed files
        # flow_speed = map_output_dir + r"\FLOW_SPEED.tif"
        # flood_depth = map_output_dir + r"\FLOOD_DEPTH.tif"
        # h_x_v = map_output_dir + r"\HxV.tif"

        if os.path.isfile(flood_depth):
            QgsProject.instance().addMapLayer(QgsRasterLayer(flood_depth, name_depth), True)
        else:
            raster_processed = read_ASCII(depth_file, flood_depth, name_depth, crs)
            if raster_processed:
                QgsProject.instance().addMapLayer(QgsRasterLayer(flood_depth, name_depth), True)

        if os.path.isfile(flow_speed):
            QgsProject.instance().addMapLayer(QgsRasterLayer(flow_speed, name_speed), True)
        else:
            raster_processed = read_ASCII(vel_file, flow_speed, name_speed, crs)
            if raster_processed:
                QgsProject.instance().addMapLayer(QgsRasterLayer(flow_speed, name_speed), True)

        if os.path.isfile(h_x_v):
            QgsProject.instance().addMapLayer(QgsRasterLayer(h_x_v, name_hxv), True)
        else:
            raster_processed = read_ASCII(vel_x_depth_file, h_x_v, name_hxv, crs)
            if raster_processed:
                QgsProject.instance().addMapLayer(QgsRasterLayer(h_x_v, name_hxv), True)

        # if os.path.isfile(hydro_risk):
        #     try:
        #         remove_layer("ARR_FLOOD_HAZARD")
        #         os.remove(hydro_risk)
        #     except OSError as e:
        #         print(f"Error deleting {hydro_risk}: {str(e)}")

        # adjust units
        if self.units_switch == "1":
            uc = 1
        else:
            uc = 3.28

        r0_e = f'"{name_hxv}@1" = 0 AND "{name_depth}@1" = 0 AND "{name_speed}@1" = 0'
        r1_e = f'"{name_hxv}@1" <= {0.3 * uc} AND "{name_depth}@1" < {0.3 * uc} AND "{name_speed}@1" < {2 * uc}'
        r2_e = f'"{name_hxv}@1" <= {0.6 * uc} AND "{name_depth}@1" < {0.5 * uc} AND "{name_speed}@1" < {2 * uc}'
        r3_e = f'"{name_hxv}@1" <= {0.6 * uc} AND "{name_depth}@1" < {1.2 * uc} AND "{name_speed}@1" < {2 * uc}'
        r4_e = f'"{name_hxv}@1" <= {1.0 * uc} AND "{name_depth}@1" < {2.0 * uc} AND "{name_speed}@1" < {2 * uc}'
        r5_e = f'"{name_hxv}@1" <= {4.0 * uc} AND "{name_depth}@1" < {4.0 * uc} AND "{name_speed}@1" < {4 * uc}'
        r6_e = f'"{name_hxv}@1" > {4.0 * uc} OR "{name_depth}@1" >= {4.0 * uc} OR "{name_speed}@1" >= {4 * uc}'

        # Australian Rainfall and Runoff (ARR) Classification
        arr_class = processing.run(
            "qgis:rastercalculator",
            {
                "EXPRESSION": f"IF({r0_e},0,if({r1_e},1,if({r2_e},2,if({r3_e},3,if({r4_e},4,if({r5_e},5,if({r6_e},6,0)))))))",
                "LAYERS": [flood_depth],
                "CELLSIZE": 0,
                "EXTENT": None,
                "CRS": crs,
                "OUTPUT": hydro_risk,
            },
        )["OUTPUT"]

        remove_layer(name_depth)
        remove_layer(name_speed)
        remove_layer(name_hxv)

        name_arr = os.path.splitext(os.path.basename(hydro_risk))[0]

        return QgsRasterLayer(arr_class, name_arr)

    def create_usbr_map(self, name, hydro_risk, depth_data, vel_data, map_type, crs):
        """Create the USBR hydrodynamic risk map"""

        # adjust units
        if self.units_switch == "1":
            uc = 3.28
        else:
            uc = 1

        values = []
        cellSize_data = []
        for (id_v, x, y, velocity), (_, _, _, depth) in zip(vel_data, depth_data):

            if depth != 0 and velocity != 0:

                # Unit conversion
                depth = depth * uc
                velocity = velocity * uc

                # Houses
                if map_type == 0:
                    low_curve_value = 0.0004 * velocity ** 3 - 0.0121 * velocity ** 2 - 0.0809 * velocity + 3.076
                    high_curve_value = 0.0007 * velocity ** 3 - 0.0276 * velocity ** 2 + 0.0206 * velocity + 5.9005
                # Mobile
                if map_type == 1:
                    low_curve_value = -0.0007 * velocity ** 2 - 0.0308 * velocity + 1.9458
                    high_curve_value = -0.0009 * velocity ** 2 - 0.0262 * velocity + 2.5373
                # Vehicles
                if map_type == 2:
                    low_curve_value = 0.0002 * velocity ** 3 - 0.0009 * velocity ** 2 - 0.0904 * velocity + 2.0311
                    high_curve_value = 0.0004 * velocity ** 3 - 0.0056 * velocity ** 2 - 0.1036 * velocity + 3.0877
                # Adults
                if map_type == 3:
                    low_curve_value = -0.0053 * velocity ** 3 + 0.1241 * velocity ** 2 - 1.0323 * velocity + 3.1671
                    high_curve_value = -0.0011 * velocity ** 4 + 0.0282 * velocity ** 3 - 0.1888 * velocity ** 2 - 0.2374 * velocity + 4.633
                # Children
                if map_type == 4:
                    low_curve_value = 0.0726 * velocity ** 2 - 0.6786 * velocity + 1.5994
                    high_curve_value = 0.0029 * velocity ** 5 - 0.0526 * velocity ** 4 + 0.3337 * velocity ** 3 - 0.7657 * velocity ** 2 - 0.2936 * velocity + 3.0475

                # low danger
                if depth < low_curve_value:
                    values.append((x, y, 1))
                    if len(cellSize_data) < 2:
                        cellSize_data.append((x, y))
                # high danger
                elif depth > high_curve_value:
                    values.append((x, y, 3))
                    if len(cellSize_data) < 2:
                        cellSize_data.append((x, y))
                # judgment
                else:
                    values.append((x, y, 2))
                    if len(cellSize_data) < 2:
                        cellSize_data.append((x, y))

                # Fix maximums:
                if map_type == 0 and (depth > 10 or velocity > 25):
                    values.append((x, y, 3))
                if map_type == 1 and (depth > 3 or velocity > 16):
                    values.append((x, y, 3))
                if map_type == 2 and (depth > 4 or velocity > 16):
                    values.append((x, y, 3))
                if map_type == 3 and (depth > 5 or velocity > 12):
                    values.append((x, y, 3))
                if map_type == 4 and (depth > 4 or velocity > 8):
                    values.append((x, y, 3))

        # Calculate the differences in X and Y coordinates
        dx = abs(cellSize_data[1][0] - cellSize_data[0][0])
        dy = abs(cellSize_data[1][1] - cellSize_data[0][1])

        # If the coordinate difference is equal 0, assign a huge number
        if dx == 0:
            dx = 9999
        if dy == 0:
            dy = 9999

        cellSize = min(dx, dy)

        # Get the extent and number of rows and columns
        min_x = min(point[0] for point in values)
        max_x = max(point[0] for point in values)
        min_y = min(point[1] for point in values)
        max_y = max(point[1] for point in values)
        num_cols = int((max_x - min_x) / cellSize) + 1
        num_rows = int((max_y - min_y) / cellSize) + 1

        # Convert the list of values to an array.
        raster_data = np.full((num_rows, num_cols), -9999, dtype=np.float32)
        for point in values:
            if point[2] != 0:
                col = int((point[0] - min_x) / cellSize)
                row = int((max_y - point[1]) / cellSize)
                raster_data[row, col] = point[2]

        # Initialize the raster
        driver = gdal.GetDriverByName("GTiff")
        raster = driver.Create(hydro_risk, num_cols, num_rows, 1, gdal.GDT_Float32)
        raster.SetGeoTransform(
            (
                min_x - cellSize / 2,
                cellSize,
                0,
                max_y + cellSize / 2,
                0,
                -cellSize,
            )
        )
        raster.SetProjection(crs.toWkt())

        band = raster.GetRasterBand(1)
        band.SetNoDataValue(-9999)  # Set a no-data value if needed
        band.WriteArray(raster_data)

        raster.FlushCache()

        layer = QgsRasterLayer(hydro_risk, name)

        return layer


    def create_pier_scour_map(
        self,
        hydro_risk,
        depth_file,
        vel_file,
        timdep_file,
        crs,
        pier_params
    ):
        """
        Create the HEC-18 CSU Pier Scour map.
        Uses FLO-2D grid-based outputs and writes a GeoTIFF.
        """
    
        values = []
        cellSize_data = []
    
        # Compute scour magnitude per grid element
        if pier_params.get("use_timdep", False):
            # --- TIMDEP path: max scour over time ---
            scour = self._scour_from_timdep(
                os.path.dirname(timdep_file),
                pier_params
            )
    
            # Geometry comes from DEPTH.OUT (grid order guaranteed)
            depth_data = self._read_flo2d_ascii_xyv(depth_file)
    
            for (_, x, y, _), s in zip(depth_data, scour):
                if s > 0.0:
                    values.append((x, y, float(s)))
                    if len(cellSize_data) < 2:
                        cellSize_data.append((x, y))
    
        else:
            # --- Max-field path: floodplain-only ---
            results_dir = os.path.dirname(depth_file)
    
            # Read geometry from DEPFP.OUT (floodplain only)
            depth_data = self._read_flo2d_ascii_xyv(
                os.path.join(results_dir, "DEPFP.OUT")
            )
    
            scour = self._scour_from_max_fields(
                results_dir,
                pier_params
            )
    
            for (_, x, y, _), s in zip(depth_data, scour):
                if s > 0.0:
                    values.append((x, y, float(s)))
                    if len(cellSize_data) < 2:
                        cellSize_data.append((x, y))
        
        # cell size
        dx = abs(cellSize_data[1][0] - cellSize_data[0][0])
        dy = abs(cellSize_data[1][1] - cellSize_data[0][1])
        cellSize = min(dx, dy)

        # extent from centers → convert to edges
        min_x = min(p[0] for p in values) - cellSize / 2
        max_x = max(p[0] for p in values) + cellSize / 2
        min_y = min(p[1] for p in values) - cellSize / 2
        max_y = max(p[1] for p in values) + cellSize / 2

        num_cols = int((max_x - min_x) / cellSize)
        num_rows = int((max_y - min_y) / cellSize)

        raster_data = np.full((num_rows, num_cols), -9999, dtype=np.float32)

        for x, y, v in values:
            col = int((x - min_x) / cellSize)
            row = int((max_y - y) / cellSize)
            raster_data[row, col] = v

    
        # create raster file
        driver = gdal.GetDriverByName("GTiff")
        raster = driver.Create(hydro_risk, num_cols, num_rows, 1, gdal.GDT_Float32)
    
        raster.SetGeoTransform((
            min_x - cellSize / 2,
            cellSize,
            0,
            max_y + cellSize / 2,
            0,
            -cellSize
        ))
    
        raster.SetProjection(crs.toWkt())
    
        band = raster.GetRasterBand(1)
        band.SetNoDataValue(-9999)
        band.WriteArray(raster_data)
    
        raster.FlushCache()
    
        layer_name = os.path.splitext(os.path.basename(hydro_risk))[0]
        return QgsRasterLayer(hydro_risk, layer_name)


    def compute_scour(self, depth, velocity, a, k1, k2, k3, k4):
        """
        Compute HEC-18 CSU Scour
        """

        depth = np.where(depth > 0.0, depth, np.nan)
        Fr = velocity / np.sqrt(self.gravity * depth)
    
        scour = (
            2.0 * k1 * k2 * k3 * k4 * a
            * (depth / a) ** 0.35
            * (Fr / 0.65) ** 0.43
        )
    
        return np.nan_to_num(scour, nan=0.0)

    def _read_flo2d_ascii_xyv(self, file_path):
        """
        Read FLO-2D grid-based ASCII output:
        cell, x, y, value
        Returns list of (cell_id, x, y, value)
        """
        data = []
        with open(file_path, "r") as f:
            for line in f:
                fields = line.split()
                if not fields or not fields[0].isdigit():
                    continue
                cell = int(fields[0])
                x = float(fields[1])
                y = float(fields[2])
                value = float(fields[3])
                data.append((cell, x, y, value))
        return data

    def _scour_from_timdep(self, results_dir, pier_params):
        """
        Define scour parameters from TIMDEP.HDF5
        Depending on whether or not TIMDEP.HDF5 includes the 1D
        channel, this data may look different than the pier scour
        from DEPFP.OUT and VELFP.OUT.
        """

        hdf5_path = os.path.join(results_dir, "TIMDEP.HDF5")

        with h5py.File(hdf5_path, "r") as f:
            grp = f["TIMDEP NETCDF OUTPUT RESULTS"]
            depth = grp["FLOW DEPTH"]["Values"][:]
            vel = grp["Velocity MAG"]["Values"][:]

        scour_t = self.compute_scour(
            depth,
            vel,
            pier_params["pier_width"],
            pier_params["k1"],
            pier_params["k2"],
            pier_params["k3"],
            pier_params["k4"],
        )

        return np.max(scour_t, axis=0)


    def _scour_from_max_fields(self, results_dir, pier_params):
        """
        Compute pier scour using floodplain-only max-field outputs.
        DEPFP.OUT and VELFP.OUT are used intentionally to exclude 1D channels.
        """
    
        # Read floodplain-only depth and velocity (grid order preserved)
        depth_data = self._read_flo2d_ascii_xyv(
            os.path.join(results_dir, "DEPFP.OUT")
        )
        vel_data = self._read_flo2d_ascii_xyv(
            os.path.join(results_dir, "VELFP.OUT")
        )
    
        # Extract numeric arrays (same grid order guaranteed)
        depth = np.array([v for (_, _, _, v) in depth_data], dtype=float)
        vel   = np.array([v for (_, _, _, v) in vel_data], dtype=float)
    
        return self.compute_scour(
            depth,
            vel,
            pier_params["pier_width"],
            pier_params["k1"],
            pier_params["k2"],
            pier_params["k3"],
            pier_params["k4"],
        )

