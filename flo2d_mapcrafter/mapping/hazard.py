# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FLO2DMapCrafter
                                 A QGIS plugin
 This plugin creates maps from FLO-2D output files.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-09-21
        git sha              : $Format:%H$
        copyright            : (C) 2023 by FLO-2D
        email                : contact@flo-2d.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os

import numpy as np
from PyQt5.QtWidgets import QMessageBox
from osgeo import gdal
from qgis._core import QgsProject, QgsRasterLayer, QgsUnitTypes, QgsMessageLog

from flo2d_mapcrafter.mapping.scripts import read_ASCII, remove_layer, set_raster_style

import processing

class HazardMaps:

    def __init__(self, units_switch):
        """
        Class constructor
        :param units_switch: 0 english 1 metric
        """
        self.units_switch = units_switch

    def check_hazard_files(self, output_dir):
        """
        Function to check the hazard maps that can be created
        """

        hazard_maps = {
            "ARR": False,
            "Austrian": False,
            "FLO-2D": False,
            "Swiss": False,
            "UK": False,
            "USBR": False,
            "FEMA": False
        }

        # Australian Rainfall and Runoff (ARR)
        arr_files = {
            r"DEPTH.OUT": False,
            r"VELFP.OUT": False,
            r"VEL_X_DEPTH.OUT": False
        }

        # SWISS FLOOD INTENSITY
        swiss_files = {
            r"DEPTH.OUT": False,
            r"VEL_X_DEPTH.OUT": False,
            r"VELFP.OUT": False
        }

        # US Bureau of Reclamation
        usbr_files = {
            r"DEPTH.OUT": False,
            r"VELFP.OUT": False,
        }

        files = os.listdir(output_dir)
        for file in files:
            for key, value in arr_files.items():
                if file.startswith(key):
                    arr_files[key] = True
            for key, value in swiss_files.items():
                if file.startswith(key):
                    swiss_files[key] = True
            for key, value in usbr_files.items():
                if file.startswith(key):
                    usbr_files[key] = True

        # ARR Check if all files are true
        if all(value for value in arr_files.values()):
            hazard_maps["ARR"] = True

        # SWISS Check if all files are true
        if all(value for value in arr_files.values()):
            hazard_maps["Swiss"] = True

        if all(value for value in usbr_files.values()):
            hazard_maps["USBR"] = True

        return hazard_maps

    def create_maps(self, hazard_rbs, flo2d_results_dir, map_output_dir, mapping_group, crs):
        """
        Function to create the maps
        """

        if any(value for value in hazard_rbs.values()):

            mapping_group_name = "Hazard Maps"

            if mapping_group.findGroup(mapping_group_name):
                mapping_group = mapping_group.findGroup(mapping_group_name)
            else:
                mapping_group = mapping_group.insertGroup(0, mapping_group_name)

            vector_style_directory = os.path.dirname(os.path.realpath(__file__))[:-8] + r"\vector_styles"
            raster_style_directory = os.path.dirname(os.path.realpath(__file__))[:-8] + r"\raster_styles"

            # ARR
            if hazard_rbs.get("ARR"):
                hydro_risk = map_output_dir + r"\ARR_FLOOD_HAZARD.tif"
                depth_file = flo2d_results_dir + r"\DEPTH.OUT"
                vel_file = flo2d_results_dir + r"\VELFP.OUT"
                vel_x_depth_file = flo2d_results_dir + r"\VEL_X_DEPTH.OUT"

                hydro_risk_raster = self.create_arr_map(
                    map_output_dir, hydro_risk, depth_file, vel_file, vel_x_depth_file, crs
                )

                QgsProject.instance().addMapLayer(hydro_risk_raster, False)
                set_raster_style(hydro_risk_raster, 2)

                mapping_group.insertLayer(0, hydro_risk_raster)

            usbr_maps = hazard_rbs.get("USBR")
            for index, hazard_type in enumerate(usbr_maps):
                if hazard_type.isChecked():
                    depth_file = flo2d_results_dir + r"\DEPTH.OUT"
                    vel_file = flo2d_results_dir + r"\VELFP.OUT"
                    vel_data = np.loadtxt(vel_file, skiprows=0)
                    depth_data = np.loadtxt(depth_file, skiprows=0)
                    # Houses
                    if index == 0:
                        hydro_risk = map_output_dir + r"\USBR_HOUSES_HAZARD.tif"
                        hydro_risk_raster = self.create_usbr_map(
                            "USBR_HOUSES_HAZARD", hydro_risk, depth_data, vel_data, index, crs
                        )
                        QgsProject.instance().addMapLayer(hydro_risk_raster, False)
                        set_raster_style(hydro_risk_raster, 8)
                        mapping_group.insertLayer(0, hydro_risk_raster)
                    # mobile house
                    if index == 1:
                        hydro_risk = map_output_dir + r"\USBR_MOBILE_HAZARD.tif"
                        hydro_risk_raster = self.create_usbr_map(
                            "USBR_MOBILE_HAZARD", hydro_risk, depth_data, vel_data, index, crs
                        )
                        QgsProject.instance().addMapLayer(hydro_risk_raster, False)
                        set_raster_style(hydro_risk_raster, 8)
                        mapping_group.insertLayer(0, hydro_risk_raster)
                    # vehicle
                    if index == 2:
                        hydro_risk = map_output_dir + r"\USBR_VEHICLE_HAZARD.tif"
                        hydro_risk_raster = self.create_usbr_map(
                            "USBR_VEHICLE_HAZARD", hydro_risk, depth_data, vel_data, index, crs
                        )
                        QgsProject.instance().addMapLayer(hydro_risk_raster, False)
                        set_raster_style(hydro_risk_raster, 8)
                        mapping_group.insertLayer(0, hydro_risk_raster)
                    # adults
                    if index == 3:
                        hydro_risk = map_output_dir + r"\USBR_ADULTS_HAZARD.tif"
                        hydro_risk_raster = self.create_usbr_map(
                            "USBR_ADULTS_HAZARD", hydro_risk, depth_data, vel_data, index, crs
                        )
                        QgsProject.instance().addMapLayer(hydro_risk_raster, False)
                        set_raster_style(hydro_risk_raster, 8)
                        mapping_group.insertLayer(0, hydro_risk_raster)
                    # children
                    if index == 4:
                        hydro_risk = map_output_dir + r"\USBR_CHILDREN_HAZARD.tif"
                        hydro_risk_raster = self.create_usbr_map(
                            "USBR_CHILDREN_HAZARD", hydro_risk, depth_data, vel_data, index, crs
                        )
                        QgsProject.instance().addMapLayer(hydro_risk_raster, False)
                        set_raster_style(hydro_risk_raster, 8)
                        mapping_group.insertLayer(0, hydro_risk_raster)

            swiss_maps = hazard_rbs.get("Swiss")
            for index, hazard_type in enumerate(swiss_maps):
                if hazard_type.isChecked():
                    depth_file = flo2d_results_dir + r"\DEPTH.OUT"
                    vel_file = flo2d_results_dir + r"\VELFP.OUT"
                    vel_x_depth_file = flo2d_results_dir + r"\VEL_X_DEPTH.OUT"
                    vel_x_depth_data = np.loadtxt(vel_x_depth_file, skiprows=0)
                    depth_data = np.loadtxt(depth_file, skiprows=0)
                    vel_data = np.loadtxt(vel_file, skiprows=0)
                    # Flood intensity
                    if index == 0:
                        hydro_risk = map_output_dir + r"\SWISS_FLOOD_INTENSITY.tif"
                        hydro_risk_raster = self.create_swiss_map(
                            "SWISS_FLOOD_INTENSITY", hydro_risk, depth_data, vel_data, vel_x_depth_data, index, crs
                        )
                        QgsProject.instance().addMapLayer(hydro_risk_raster, False)
                        set_raster_style(hydro_risk_raster, 8)
                        mapping_group.insertLayer(0, hydro_risk_raster)
                    if index == 1:
                        hydro_risk = map_output_dir + r"\SWISS_DEBRIS_INTENSITY.tif"
                        hydro_risk_raster = self.create_swiss_map(
                            "SWISS_DEBRIS_INTENSITY", hydro_risk, depth_data, vel_data, vel_x_depth_data, index, crs
                        )
                        QgsProject.instance().addMapLayer(hydro_risk_raster, False)
                        set_raster_style(hydro_risk_raster, 8)
                        mapping_group.insertLayer(0, hydro_risk_raster)

    def create_swiss_map(self, name, hydro_risk, depth_data, vel_data, vel_x_depth_data, map_type, crs):
        """Create the SWISS flood intensity map"""

        # adjust units
        if self.units_switch == "1":
            uc = 1
        else:
            uc = 3.28

        values = []
        cellSize_data = []

        # Flood Intensity
        if map_type == 0:
            for (id_v, x, y, depth_x_velocity), (_, _, _, depth) in zip(vel_x_depth_data, depth_data):
                if depth != 0:
                    # Unit conversion
                    depth = depth * uc
                    depth_x_velocity = depth_x_velocity * (uc ** 2)
                    # low intensity
                    if depth > 2 or depth_x_velocity > 2:
                        values.append((x, y, 3))
                        if len(cellSize_data) < 2:
                            cellSize_data.append((x, y))
                    # moderate intensity
                    elif 0.5 < depth < 2 or 0.5 < depth_x_velocity < 2:
                        values.append((x, y, 2))
                        if len(cellSize_data) < 2:
                            cellSize_data.append((x, y))
                    # high intensity
                    else:
                        values.append((x, y, 1))
                        if len(cellSize_data) < 2:
                            cellSize_data.append((x, y))

        # Debris Intensity
        if map_type == 1:
            for (id_v, x, y, depth), (_, _, _, velocity) in zip(depth_data, vel_data):
                if depth != 0:
                    # Unit conversion
                    depth = depth * uc
                    velocity = velocity * uc
                    # high intensity
                    if depth > 1 and velocity > 1:
                        values.append((x, y, 3))
                        if len(cellSize_data) < 2:
                            cellSize_data.append((x, y))
                    # moderate intensity
                    elif depth < 1 or velocity < 1:
                        values.append((x, y, 2))
                        if len(cellSize_data) < 2:
                            cellSize_data.append((x, y))

        # Calculate the differences in X and Y coordinates
        dx = cellSize_data[1][0] - cellSize_data[0][0]
        dy = cellSize_data[1][1] - cellSize_data[0][1]

        if dx != 0:
            cellSize = int(abs(dx))
        if dy != 0:
            cellSize = int(abs(dy))

        # Get the extent and number of rows and columns
        min_x = min(point[0] for point in values)
        max_x = max(point[0] for point in values)
        min_y = min(point[1] for point in values)
        max_y = max(point[1] for point in values)
        num_cols = int((max_x - min_x) / cellSize) + 1
        num_rows = int((max_y - min_y) / cellSize) + 1

        # Convert the list of values to an array.
        raster_data = np.full((num_rows, num_cols), -9999, dtype=np.float32)
        for point in values:
            if point[2] != 0:
                col = int((point[0] - min_x) / cellSize)
                row = int((max_y - point[1]) / cellSize)
                raster_data[row, col] = point[2]

        # Initialize the raster
        driver = gdal.GetDriverByName("GTiff")
        raster = driver.Create(hydro_risk, num_cols, num_rows, 1, gdal.GDT_Float32)
        raster.SetGeoTransform(
            (
                min_x - cellSize / 2,
                cellSize,
                0,
                max_y + cellSize / 2,
                0,
                -cellSize,
            )
        )
        raster.SetProjection(crs.toWkt())

        band = raster.GetRasterBand(1)
        band.SetNoDataValue(-9999)  # Set a no-data value if needed
        band.WriteArray(raster_data)

        raster.FlushCache()

        layer = QgsRasterLayer(hydro_risk, name)

        return layer

    def create_arr_map(
        self, map_output_dir, hydro_risk, depth_file, vel_file, vel_x_depth_file, crs
    ):
        """Create the ARR hydrodynamic risk map"""

        # Check flood depth and flow speed files
        flow_speed = map_output_dir + r"\FLOW_SPEED.tif"
        flood_depth = map_output_dir + r"\FLOOD_DEPTH.tif"
        h_x_v = map_output_dir + r"\HxV.tif"

        if os.path.isfile(flood_depth):
            QgsProject.instance().addMapLayer(QgsRasterLayer(flood_depth, "FLOOD_DEPTH"), True)
        else:
            read_ASCII(depth_file, flood_depth, "FLOOD_DEPTH", crs)
            QgsProject.instance().addMapLayer(QgsRasterLayer(flood_depth, "FLOOD_DEPTH"), True)

        if os.path.isfile(flow_speed):
            QgsProject.instance().addMapLayer(QgsRasterLayer(flow_speed, "FLOW_SPEED"), True)
        else:
            read_ASCII(vel_file, flow_speed, "FLOW_SPEED", crs)
            QgsProject.instance().addMapLayer(QgsRasterLayer(flow_speed, "FLOW_SPEED"), True)

        if os.path.isfile(h_x_v):
            QgsProject.instance().addMapLayer(QgsRasterLayer(h_x_v, "HxV"), True)
        else:
            read_ASCII(vel_x_depth_file, h_x_v, "HxV", crs)
            QgsProject.instance().addMapLayer(QgsRasterLayer(h_x_v, "HxV"), True)

        if os.path.isfile(hydro_risk):
            try:
                remove_layer("ARR_FLOOD_HAZARD")
                os.remove(hydro_risk)
            except OSError as e:
                print(f"Error deleting {hydro_risk}: {str(e)}")

        # adjust units
        if self.units_switch == "1":
            uc = 1
        else:
            uc = 3.28

        r1_e = f'"HxV@1" <= {0.3 * uc} AND "FLOOD_DEPTH@1" < {0.3 * uc} AND "FLOW_SPEED@1" < {2 * uc}'
        r2_e = f'"HxV@1" <= {0.6 * uc} AND "FLOOD_DEPTH@1" < {0.5 * uc} AND "FLOW_SPEED@1" < {2 * uc}'
        r3_e = f'"HxV@1" <= {0.6 * uc} AND "FLOOD_DEPTH@1" < {1.2 * uc} AND "FLOW_SPEED@1" < {2 * uc}'
        r4_e = f'"HxV@1" <= {1.0 * uc} AND "FLOOD_DEPTH@1" < {2.0 * uc} AND "FLOW_SPEED@1" < {2 * uc}'
        r5_e = f'"HxV@1" <= {4.0 * uc} AND "FLOOD_DEPTH@1" < {4.0 * uc} AND "FLOW_SPEED@1" < {4 * uc}'
        r6_e = f'"HxV@1" > {4.0 * uc} OR "FLOOD_DEPTH@1" >= {4.0 * uc} OR "FLOW_SPEED@1" >= {4 * uc}'

        # Australian Rainfall and Runoff Classification
        arr_class = processing.run(
            "qgis:rastercalculator",
            {
                "EXPRESSION": f"IF({r1_e},1,if({r2_e},2,if({r3_e},3,if({r4_e},4,if({r5_e},5,if({r6_e},6,0))))))",
                "LAYERS": [flood_depth],
                "CELLSIZE": 0,
                "EXTENT": None,
                "CRS": crs,
                "OUTPUT": hydro_risk,
            },
        )["OUTPUT"]

        remove_layer("FLOOD_DEPTH")
        remove_layer("FLOW_SPEED")
        remove_layer("HxV")

        return QgsRasterLayer(arr_class, "ARR_FLOOD_HAZARD")

    def create_usbr_map(self, name, hydro_risk, depth_data, vel_data, map_type, crs):
        """Create the USBR hydrodynamic risk map"""

        # adjust units
        if self.units_switch == "1":
            uc = 3.28
        else:
            uc = 1

        values = []
        cellSize_data = []
        for (id_v, x, y, velocity), (_, _, _, depth) in zip(vel_data, depth_data):

            if depth != 0 and velocity != 0:

                # Unit conversion
                depth = depth * uc
                velocity = velocity * uc

                # Houses
                if map_type == 0:
                    low_curve_value = 0.0004 * velocity ** 3 - 0.0121 * velocity ** 2 - 0.0809 * velocity + 3.076
                    high_curve_value = 0.0007 * velocity ** 3 - 0.0276 * velocity ** 2 + 0.0206 * velocity + 5.9005
                # Mobile
                if map_type == 1:
                    low_curve_value = -0.0007 * velocity ** 2 - 0.0308 * velocity + 1.9458
                    high_curve_value = -0.0009 * velocity ** 2 - 0.0262 * velocity + 2.5373
                # Vehicles
                if map_type == 2:
                    low_curve_value = 0.0002 * velocity ** 3 - 0.0009 * velocity ** 2 - 0.0904 * velocity + 2.0311
                    high_curve_value = 0.0004 * velocity ** 3 - 0.0056 * velocity ** 2 - 0.1036 * velocity + 3.0877
                # Adults
                if map_type == 3:
                    low_curve_value = -0.0053 * velocity ** 3 + 0.1241 * velocity ** 2 - 1.0323 * velocity + 3.1671
                    high_curve_value = -0.0011 * velocity ** 4 + 0.0282 * velocity ** 3 - 0.1888 * velocity ** 2 - 0.2374 * velocity + 4.633
                # Children
                if map_type == 4:
                    low_curve_value = 0.0726 * velocity ** 2 - 0.6786 * velocity + 1.5994
                    high_curve_value = 0.0029 * velocity ** 5 - 0.0526 * velocity ** 4 + 0.3337 * velocity ** 3 - 0.7657 * velocity ** 2 - 0.2936 * velocity + 3.0475

                # low danger
                if depth < low_curve_value:
                    values.append((x, y, 1))
                    if len(cellSize_data) < 2:
                        cellSize_data.append((x, y))
                # high danger
                elif depth > high_curve_value:
                    values.append((x, y, 3))
                    if len(cellSize_data) < 2:
                        cellSize_data.append((x, y))
                # judgment
                else:
                    values.append((x, y, 2))
                    if len(cellSize_data) < 2:
                        cellSize_data.append((x, y))

                # Fix maximums:
                if map_type == 0 and (depth > 10 or velocity > 25):
                    values.append((x, y, 3))
                if map_type == 1 and (depth > 3 or velocity > 16):
                    values.append((x, y, 3))
                if map_type == 2 and (depth > 4 or velocity > 16):
                    values.append((x, y, 3))
                if map_type == 3 and (depth > 5 or velocity > 12):
                    values.append((x, y, 3))
                if map_type == 4 and (depth > 4 or velocity > 8):
                    values.append((x, y, 3))


            # Calculate the differences in X and Y coordinates
        dx = cellSize_data[1][0] - cellSize_data[0][0]
        dy = cellSize_data[1][1] - cellSize_data[0][1]

        if dx != 0:
            cellSize = int(abs(dx))
        if dy != 0:
            cellSize = int(abs(dy))

        # Get the extent and number of rows and columns
        min_x = min(point[0] for point in values)
        max_x = max(point[0] for point in values)
        min_y = min(point[1] for point in values)
        max_y = max(point[1] for point in values)
        num_cols = int((max_x - min_x) / cellSize) + 1
        num_rows = int((max_y - min_y) / cellSize) + 1

        # Convert the list of values to an array.
        raster_data = np.full((num_rows, num_cols), -9999, dtype=np.float32)
        for point in values:
            if point[2] != 0:
                col = int((point[0] - min_x) / cellSize)
                row = int((max_y - point[1]) / cellSize)
                raster_data[row, col] = point[2]

        # Initialize the raster
        driver = gdal.GetDriverByName("GTiff")
        raster = driver.Create(hydro_risk, num_cols, num_rows, 1, gdal.GDT_Float32)
        raster.SetGeoTransform(
            (
                min_x - cellSize / 2,
                cellSize,
                0,
                max_y + cellSize / 2,
                0,
                -cellSize,
            )
        )
        raster.SetProjection(crs.toWkt())

        band = raster.GetRasterBand(1)
        band.SetNoDataValue(-9999)  # Set a no-data value if needed
        band.WriteArray(raster_data)

        raster.FlushCache()

        layer = QgsRasterLayer(hydro_risk, name)

        return layer